<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis ile Senior Seviye Mülakat Soruları</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .code-block {
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.875rem;
        }

        .code-block.bash {
            background-color: #1e293b;
            color: #e2e8f0;
        }

        .code-block.json {
            background-color: #1e3a5f;
            color: #e2e8f0;
        }

        .code-block.yaml {
            background-color: #1e3a1e;
            color: #e2e8f0;
        }

        .code-block.java {
            background-color: #3a1e3a;
            color: #e2e8f0;
        }

        .code-block.dockerfile {
            background-color: #3a1e1e;
            color: #e2e8f0;
        }

        .code-block.xml {
            background-color: #3a2a1e;
            color: #e2e8f0;
        }

        .category-card {
            transition: transform 0.3s ease;
        }

        .category-card:hover {
            transform: translateY(-5px);
        }

        .question-card {
            transition: all 0.3s ease;
        }

        .question-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Redis ile Senior Seviye Mülakat Soruları</h1>
            <p class="text-gray-600">50 adet ileri seviye Redis sorusu ve cevapla hazırlanmış kapsamlı arşiv</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-12">
            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-database text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Redis Temelleri</h2>
                </div>
                <p class="text-gray-600 mb-4">Redis'in temel özellikleri ve veri yapıları</p>
                <button onclick="scrollToCategory('redis-temelleri')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>

            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-code text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Spring Boot & Redis</h2>
                </div>
                <p class="text-gray-600 mb-4">Spring Boot ile Redis entegrasyonu</p>
                <button onclick="scrollToCategory('spring-boot-redis')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>

            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-bolt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Redis Caching</h2>
                </div>
                <p class="text-gray-600 mb-4">Redis ile caching stratejileri</p>
                <button onclick="scrollToCategory('redis-caching')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>

            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-tachometer-alt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Redis Performans</h2>
                </div>
                <p class="text-gray-600 mb-4">Redis performans optimizasyonu</p>
                <button onclick="scrollToCategory('redis-performans')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>

            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-network-wired text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Redis Cluster</h2>
                </div>
                <p class="text-gray-600 mb-4">Redis cluster ve yüksek erişilebilirlik</p>
                <button onclick="scrollToCategory('redis-cluster')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>

            <div class="category-card bg-white rounded-lg shadow-md p-6">
                <div class="flex items-center mb-4">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-shield-alt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-xl font-bold text-gray-800">Redis Güvenlik</h2>
                </div>
                <p class="text-gray-600 mb-4">Redis güvenlik ve en iyi uygulamalar</p>
                <button onclick="scrollToCategory('redis-guvenlik')"
                    class="text-red-600 font-medium hover:text-red-800">Soruları Görüntüle <i
                        class="fas fa-arrow-right ml-1"></i></button>
            </div>
        </div>

        <!-- Redis Temelleri Soruları -->
        <section id="redis-temelleri" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-database text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Redis Temelleri</h2>
                </div>
                <p class="text-gray-600 mb-6">Redis'in temel özellikleri ve veri yapıları ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Redis nedir ve ne için kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis, açık kaynaklı, bellek içi (in-memory) veri yapısı deposudur. 
                            Verileri anahtar-değer (key-value) çiftleri olarak saklar ve çeşitli veri yapılarını destekler. 
                            Genellikle veritabanı, önbellek (cache), mesaj kuyruğu ve broker olarak kullanılır.</p>
                            <p class="mt-2"><strong>Özellikleri:</strong></p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Çok yüksek performanslı (1M+ saniyede işlem)</li>
                                <li>Verileri bellekte saklar</li>
                                <li>Dayanıklılık için diske yazabilir</li>
                                <li>Atomik işlemler destekler</li>
                                <li>Çeşitli veri yapıları (string, hash, list, set, sorted set) destekler</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Redis hangi veri yapılarını destekler?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis 5 ana veri yapısını destekler:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Strings:</strong> Metinler, sayılar, binary veriler</li>
                                <li><strong>Hashes:</strong> Alan-değer çiftleri koleksiyonu</li>
                                <li><strong>Lists:</strong> Sıralı değerler koleksiyonu</li>
                                <li><strong>Sets:</strong> Sırasız benzersiz değerler koleksiyonu</li>
                                <li><strong>Sorted Sets (ZSets):</strong> Sıralı benzersiz değerler koleksiyonu</li>
                            </ul>
                            <p class="mt-2 font-medium">Örnek kullanımlar:</p>
                            <pre class="code-block bash mt-2"># String
SET user:1:name "Ahmet"
GET user:1:name

# Hash
HSET user:1 name "Ahmet" age 30
HGET user:1 name

# List
LPUSH queue:jobs "job1"
RPUSH queue:jobs "job2"
LPOP queue:jobs

# Set
SADD user:1:followers "user2" "user3"
SMEMBERS user:1:followers

# Sorted Set
ZADD leaderboard 100 "player1" 200 "player2"
ZRANGE leaderboard 0 -1</pre>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Redis'in RDB ve AOF dayanıklılık mekanizmaları arasındaki fark nedir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis verilerin kaybolmaması için iki farklı dayanıklılık mekanizması sunar:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>RDB (Redis Database File):</strong> Belirli zaman aralıklarında veri setlerinin anlık görüntüsünü alır ve diske yazar. 
                                Daha hızlı başlangıç süresi ve daha küçük dosya boyutu sağlar. Ancak son anlık görüntüden sonraki veri kayıpları olabilir.</li>
                                <li><strong>AOF (Append Only File):</strong> Her yazma işlemini log dosyasına ekler. 
                                Veri kaybı riski daha düşüktür ancak dosya boyutu büyüktür ve başlangıç süresi daha uzundur.</li>
                            </ul>
                            <p class="mt-2 font-medium">Yapılandırma örnekleri:</p>
                            <pre class="code-block yaml mt-2"># redis.conf
# RDB ayarları
save 900 1      # 900 saniye içinde en az 1 değişiklik olursa kaydet
save 300 10     # 300 saniye içinde en az 10 değişiklik olursa kaydet
save 60 10000   # 60 saniye içinde en az 10000 değişiklik olursa kaydet

# AOF ayarları
appendonly yes  # AOF'yi etkinleştir
appendfsync everysec  # Her saniye diske yaz</pre>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Redis'te pub/sub nasıl çalışır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis pub/sub, mesajlaşma modelinde yayıncı (publisher) ve abone (subscriber) 
                            arasında bir iletişim mekanizmasıdır. Yayıncılar belirli kanallara mesaj gönderir, aboneler ise bu kanalları dinler.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block bash mt-2"># Terminal 1: Kanala abone ol
SUBSCRIBE notifications

# Terminal 2: Kanala mesaj gönder
PUBLISH notifications "Yeni bildirim: Siparişiniz hazır"

# Terminal 3: Pattern ile abone ol
PSUBSCRIBE notification.*</pre>
                            <p class="mt-2">Bu örnekte, "notifications" kanalına gönderilen mesajlar bu kanala abone olan tüm istemcilere iletilir. 
                            PSUBSCRIBE ile belirli bir desene uyan kanallara abone olunabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Redis'te transaction'lar nasıl çalışır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis transaction'ları MULTI, EXEC, DISCARD ve WATCH komutları ile yönetilir. 
                            Transaction'lar atomik bir birim olarak çalışır: ya tüm komutlar uygulanır ya da hiçbiri uygulanmaz.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block bash mt-2"># Transaction başlat
MULTI

# Komutları sırayla ekle
SET user:1:name "Ahmet"
SET user:1:age 30
INCR counter:users

# Transaction'ı uygula
EXEC

# Veya iptal et
DISCARD</pre>
                            <p class="mt-2">WATCH komutu, belirli bir anahtarın değişiklik izlenmesini sağlar. 
                            Eğer transaction çalışırken izlenen anahtar değişirse, transaction başarısız olur.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Redis'te TTL (Time To Live) nedir ve nasıl kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> TTL, bir anahtarın ne kadar süre sonra otomatik olarak silineceğini belirten 
                            saniye cinsinden bir değerdir. Önbellek verilerinin otomatik olarak temizlenmesi için kullanılır.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block bash mt-2"># Anahtara 60 saniyelik TTL ekle
SET session:abc123 "user_data"
EXPIRE session:abc123 60

# Veya SET ile birlikte TTL belirle
SET session:abc123 "user_data" EX 60

# TTL'yi kontrol et
TTL session:abc123

# TTL'yi kaldır
PERSIST session:abc123</pre>
                            <p class="mt-2">TTL, önbellek yönetimi, oturum yönetimi ve geçici veri depolama için önemlidir. 
                            TTL'si biten anahtarlar Redis tarafından otomatik olarak silinir.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Redis'te pipelining nedir ve avantajları nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Pipelining, birden fazla komutu tek bir istekte göndermek ve tüm 
                            yanıtları tek bir seferde almak için kullanılan bir tekniktir. Bu, ağ gecikmesini azaltır ve performansı artırır.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block java mt-2">// Java ile Redis pipelining örneği
Jedis jedis = new Jedis("localhost");
Pipeline pipeline = jedis.pipelined();

// Komutları sırayla ekle
pipeline.set("key1", "value1");
pipeline.get("key1");
pipeline.incr("counter");

// Tüm komutları gönder ve yanıtları al
Response&lt;String&gt; response1 = (Response&lt;String&gt;) pipeline.get("key1");
Response&lt;Long&gt; response2 = (Response&lt;Long&gt;) pipeline.incr("counter");

pipeline.sync();

// Yanıtları kullan
String value = response1.get();
long count = response2.get();</pre>
                            <p class="mt-2">Pipelining, özellikle çok sayıda komutun bir arada gönderilmesi gereken durumlarda 
                            (örneğin, toplu veri işleme) performansı önemli ölçüde artırır.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Redis'te Lua scripting ne işe yarar?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te Lua scripting, sunucu tarafında karmaşık işlemleri atomik olarak 
                            çalıştırmak için kullanılır. EVAL ve EVALSHA komutları ile Lua betikleri çalıştırılabilir.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block lua mt-2"-- Lua betiği: Sayaç artırma ve limit kontrolü
local current = redis.call('GET', KEYS[1])
if current then
    current = tonumber(current) + tonumber(ARGV[1])
else
    current = tonumber(ARGV[1])
end

if current > tonumber(ARGV[2]) then
    return 0  -- Limit aşıldı
else
    redis.call('SET', KEYS[1], current)
    return 1  -- Başarılı
end</pre>
                            <pre class="code-block bash mt-2">-- Betiği çalıştır
EVAL "local current = redis.call('GET', KEYS[1])..." 1 counter 5 10</pre>
                            <p class="mt-2">Lua scripting, birden fazla Redis komutunun atomik olarak çalıştırılması gerektiğinde 
                            (örneğin, banka hesap transferi) çok kullanışlıdır.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Redis'te bitmap nedir ve nasıl kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Bitmap, string veri yapısının özel bir kullanımıdır. Her bit 0 veya 1 
                            değerini alabilir ve genellikle varlık-yokluk durumlarını temsil etmek için kullanılır. Bellek verimliliği 
                            sağlar ve bit düzeyinde işlemlere izin verir.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block bash mt-2">-- Bitmap oluşturma ve bit ayarlama
SETBIT user:100:notifications 1 1  -- 1. gün bildirim açıldı
SETBIT user:100:notifications 7 1  -- 7. gün bildirim açıldı

-- Bit değerini okuma
GETBIT user:100:notifications 1  -- 1 döner (bildirim açık)

-- Belirli bir aralıktaki 1'leri sayma
BITCOUNT user:100:notifications

-- İki bitmap arasındaki farkı bulma
BITOP DIFFERENCE result user:100:notifications user:101:notifications</pre>
                            <p class="mt-2">Bitmap'ler genellikle kullanıcı aktivitelerini takip etmek, özellik bayraklarını 
                            saklamak veya istatistiksel verileri depolamak için kullanılır.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Redis'te HyperLogLog nedir ve hangi durumlarda kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> HyperLogLog, bir kümenin kardinalitesini (benzersiz eleman sayısını) 
                            tahmin etmek için kullanılan bir probalistik veri yapısıdır. Bellek kullanımını optimize eder ve büyük 
                            veri setleri için yaklaşık sonuçlar sunar.</p>
                            <p class="mt-2 font-medium">Örnek:</p>
                            <pre class="code-block bash mt-2">-- HyperLogLog'a eleman ekleme
PFADD visitors:2023-05-15 "user1" "user2" "user3"

-- Benzersiz ziyaretçi sayısını tahmin etme
PFCOUNT visitors:2023-05-15

-- İki HyperLogLog birleştirme
PFMERGE visitors:2023-05-15:total visitors:2023-05-15:day1 visitors:2023-05-15:day2</pre>
                            <p class="mt-2">HyperLogLog, benzersiz sayım işlemlerinde (örneğin, web sitesine gelen benzersiz 
                            ziyaretçi sayısı) kullanılır. Bellek kullanımı küçük olsa da (12 KB) milyarlarca elemanı 
                            işleyebilir. %0.81 hata payı ile çalışır.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spring Boot & Redis Soruları -->
        <section id="spring-boot-redis" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-code text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Spring Boot & Redis</h2>
                </div>
                <p class="text-gray-600 mb-6">Spring Boot ile Redis entegrasyonu ve kullanımı ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Spring Boot uygulamasına Redis nasıl entegre edilir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Spring Boot uygulamasına Redis entegre etmek için aşağıdaki adımlar izlenir:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>Redis bağımlılığını pom.xml'e ekle</li>
                                <li>application.properties veya application.yml'de Redis bağlantı bilgilerini yapılandır</li>
                                <li>RedisTemplate veya StringRedisTemplate kullanarak Redis işlemlerini gerçekleştir</li>
                            </ol>
                            <p class="mt-2 font-medium">pom.xml bağımlılığı:</p>
                            <pre class="code-block xml mt-2">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
                            <p class="mt-2 font-medium">application.yml yapılandırması:</p>
                            <pre class="code-block yaml mt-2">spring:
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms</pre>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Spring Boot'ta RedisTemplate ve StringRedisTemplate arasındaki fark nedir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> İkisi de Redis ile etkileşim kurmak için kullanılır, ancak farklı senaryolar için optimize edilmiştir:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>RedisTemplate:</strong> Genel amaçlı bir şablondur. Herhangi bir Java nesnesini 
                                serileştirip Redis'e kaydedebilir. Varsayılan olarak JDK serileştirmesini kullanır.</li>
                                <li><strong>StringRedisTemplate:</strong> Özellikle string anahtarlar ve değerler için 
                                optimize edilmiştir. StringOperations, ListOperations, SetOperations, HashOperations ve 
                                ZSetOperations gibi operasyonları doğrudan sağlar.</li>
                            </ul>
                            <p class="mt-2 font-medium">Örnek kullanımlar:</p>
                            <pre class="code-block java mt-2">@Autowired
private RedisTemplate&lt;String, Object&gt; redisTemplate;

@Autowired
private StringRedisTemplate stringRedisTemplate;

public void saveUser(User user) {
    // RedisTemplate ile nesne kaydetme
    redisTemplate.opsForValue().set("user:" + user.getId(), user);
}

public void saveString(String key, String value) {
    // StringRedisTemplate ile string kaydetme
    stringRedisTemplate.opsForValue().set(key, value);
}</pre>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Spring Boot'ta Redis için özel serileştirme nasıl yapılandırılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Varsayılan JDK serileştirmesi yerine JSON serileştirme gibi daha 
                            verimli yöntemler kullanılabilir. Bu, hem bellek kullanımını optimize eder hem de farklı 
                            platformlar arasında uyumluluk sağlar.</p>
                            <p class="mt-2 font-medium">Örnek yapılandırma:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        
        // JSON serileştirici kullan
        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
        
        // Anahtarlar için String serileştirici
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        
        template.afterPropertiesSet();
        return template;
    }
}</pre>
                            <p class="mt-2">Bu yapılandırmada, Jackson kütüphanesi kullanılarak nesneler JSON formatına dönüştürülür. 
                            Bu, hem insan tarafından okunabilir hem de daha verimli bir serileştirme sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Spring Boot'ta @Cacheable, @CachePut ve @CacheEvict anotasyonları nasıl kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Spring'in caching anotasyonları, metod seviyesinde önbellek işlemlerini 
                            kolaylaştırır. Redis bu önbellek işlemleri için backend olarak kullanılabilir.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>@Cacheable:</strong> Metodu çalıştırmadan önce önbellekte sonuç varsa onu döndürür, 
                                yoksa metodu çalıştırır ve sonucu önbelleğe kaydeder.</li>
                                <li><strong>@CachePut:</strong> Metodu her zaman çalıştırır ve sonucu önbelleğe kaydeder.</li>
                                <li><strong>@CacheEvict:</strong> Önbellekten belirli bir veya tüm girdileri siler.</li>
                            </ul>
                            <p class="mt-2 font-medium">Örnek kullanımlar:</p>
                            <pre class="code-block java mt-2">@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    // Önbellekte varsa getir, yoksa veritabanından al ve önbelleğe kaydet
    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    // Metodu çalıştır ve sonucu önbelleğe kaydet
    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    // Önbellekten belirli bir kullanıcıyı sil
    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    // Önbellekteki tüm kullanıcıları sil
    @CacheEvict(value = "users", allEntries = true)
    public void clearUserCache() {
        // Önbelleği temizle
    }
}</pre>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Spring Boot'ta Redis ile mesajlaşma (pub/sub) nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Spring Data Redis, Redis pub/sub mekanizmasını kullanarak mesajlaşma 
                            işlemlerini destekler. Bu, uygulamalar arasında asenkron iletişim sağlar.</p>
                            <p class="mt-2 font-medium">Örnek yapılandırma ve kullanım:</p>
                            <pre class="code-block java mt-2">@Configuration
@EnableRedisMessageListener
public class RedisConfig {

    @Bean
    public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                                MessageListenerAdapter listenerAdapter) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter, new PatternTopic("notifications.*"));
        return container;
    }

    @Bean
    public MessageListenerAdapter listenerAdapter(Receiver receiver) {
        return new MessageListenerAdapter(receiver, "receiveMessage");
    }

    @Bean
    public Receiver receiver() {
        return new Receiver();
    }

    @Bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}

public class Receiver {
    public void receiveMessage(String message) {
        System.out.println("Mesaj alındı: " + message);
    }
}

@Service
public class PublisherService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void publishMessage(String channel, String message) {
        redisTemplate.convertAndSend(channel, message);
    }
}</pre>
                            <p class="mt-2">Bu örnekte, "notifications.*" kanalına gönderilen tüm mesajlar Receiver sınıfı 
                            tarafından dinlenir. PublisherService ise belirli kanallara mesaj göndermek için kullanılır.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Spring Boot'ta Redis ile oturum yönetimi nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Spring Session, HTTP oturum verilerini Redis'te saklamak için kullanılır. 
                            Bu, birden fazla uygulama örneği arasında oturum paylaşımını sağlar ve ölçeklenebilirliği artırır.</p>
                            <p class="mt-2 font-medium">Yapılandırma adımları:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>Gerekli bağımlılıkları ekle</li>
                                <li>Redis bağlantı bilgilerini yapılandır</li>
                                <li>Oturum yönetimini etkinleştir</li>
                            </ol>
                            <p class="mt-2 font-medium">pom.xml bağımlılıkları:</p>
                            <pre class="code-block xml mt-2">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
                            <p class="mt-2 font-medium">application.yml yapılandırması:</p>
                            <pre class="code-block yaml mt-2">spring:
  redis:
    host: localhost
    port: 6379
  session:
    store-type: redis
    timeout: 1800  # 30 dakika (saniye cinsinden)
    redis:
      namespace: myapp:sessions</pre>
                            <p class="mt-2">Bu yapılandırma ile HTTP oturumları Redis'te saklanır ve birden fazla uygulama 
                            örneği arasında paylaşılabilir. Kullanıcı bir örnekte oturum açtığında, diğer örnekler de bu 
                            oturumu tanır.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Spring Boot'ta Redis ile distributed locking nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Dağıtık sistemlerde kaynaklara aynı anda erişimi önlemek için 
                            distributed locking kullanılır. Spring Integration Redis veya RedisTemplate ile bu işlevsellik 
                            sağlanabilir.</p>
                            <p class="mt-2 font-medium">Örnek bir distributed lock sınıfı:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisLockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private static final String LOCK_PREFIX = "lock:";
    private static final long LOCK_EXPIRE = 30; // 30 saniye

    public boolean acquireLock(String lockKey) {
        String key = LOCK_PREFIX + lockKey;
        Boolean acquired = redisTemplate.opsForValue().setIfAbsent(key, "locked", LOCK_EXPIRE, TimeUnit.SECONDS);
        return acquired != null && acquired;
    }

    public void releaseLock(String lockKey) {
        String key = LOCK_PREFIX + lockKey;
        redisTemplate.delete(key);
    }

    public boolean isLocked(String lockKey) {
        String key = LOCK_PREFIX + lockKey;
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
}</pre>
                            <p class="mt-2 font-medium">Kullanım örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class OrderService {

    @Autowired
    private RedisLockService lockService;

    public void processOrder(Long orderId) {
        String lockKey = "order:" + orderId;
        
        try {
            // Lock al
            if (lockService.acquireLock(lockKey)) {
                // Sipariş işleme
                System.out.println("Sipariş işleniyor: " + orderId);
                
                // İşlem tamamlandığında lock'u serbest bırak
                lockService.releaseLock(lockKey);
            } else {
                System.out.println("Sipariş şu anda işleniyor: " + orderId);
            }
        } catch (Exception e) {
            // Hata durumunda lock'u serbest bırak
            lockService.releaseLock(lockKey);
            throw e;
        }
    }
}</pre>
                            <p class="mt-2">Bu örnekte, her sipariş işlemi için bir lock alınır. Bu, aynı siparişin aynı 
                            anda birden fazla kez işlenmesini önler.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Spring Boot'ta Redis ile rate limiting nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Rate limiting, belirli bir zaman diliminde bir kaynağın veya 
                            servisin kullanımını sınırlamak için kullanılır. Redis, bu işlev için hızlı ve verimli bir 
                            çözüm sunar.</p>
                            <p class="mt-2 font-medium">Örnek bir rate limiting sınıfı:</p>
                            <pre class="code-block java mt-2">@Service
public class RateLimiterService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public boolean isAllowed(String key, int limit, int period) {
        // Zaman damgası ile birlikte anahtar oluştur
        String currentKey = key + ":" + System.currentTimeMillis() / (period * 1000);
        
        // Mevcut sayıyı al veya 0 olarak ayarla
        Long current = redisTemplate.opsForValue().increment(currentKey);
        
        // İlk artırma ise TTL ayarla
        if (current != null && current == 1) {
            redisTemplate.expire(currentKey, period, TimeUnit.SECONDS);
        }
        
        // Limiti aştı mı kontrol et
        return current != null && current <= limit;
    }
}</pre>
                            <p class="mt-2 font-medium">Kullanım örneği:</p>
                            <pre class="code-block java mt-2">@RestController
@RequestMapping("/api")
public class ApiController {

    @Autowired
    private RateLimiterService rateLimiterService;

    @GetMapping("/data")
    public ResponseEntity&lt;String&gt; getData(HttpServletRequest request) {
        String clientIp = request.getRemoteAddr();
        
        // Dakikada 10 istek limiti
        if (!rateLimiterService.isAllowed(clientIp, 10, 60)) {
            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                                .body("İstek limiti aşıldı");
        }
        
        return ResponseEntity.ok("İstek başarılı");
    }
}</pre>
                            <p class="mt-2">Bu örnekte, her IP adresi için dakikada 10 istek limiti belirlenmiştir. 
                            Bu limit aşıldığında, 429 Too Many Requests yanıtı döndürülür.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Spring Boot'ta Redis için connection pooling nasıl yapılandırılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis ile etkili bir şekilde çalışmak için connection pooling 
                            kullanmak önemlidir. Spring Boot, varsayılan olarak Lettuce client'ını kullanır ve connection 
                            pooling için yapılandırma sağlar.</p>
                            <p class="mt-2 font-medium">Örnek yapılandırma:</p>
                            <pre class="code-block yaml mt-2">spring:
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 100   # Maksimum aktif bağlantı sayısı
        max-idle: 50      # Boştaki maksimum bağlantı sayısı
        min-idle: 10      # Boştaki minimum bağlantı sayısı
        max-wait: 5000ms  # Bağlantı havuzunda bağlantı yoksa bekleme süresi</pre>
                            <p class="mt-2 font-medium">Özel bir RedisClientConfiguration sınıfı ile daha detaylı yapılandırma:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisConfig {

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("localhost");
        redisConfig.setPort(6379);
        
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .clientOptions(ClientOptions.builder()
                        .autoReconnect(true)
                        .build())
                .build();
        
        return new LettuceConnectionFactory(redisConfig, clientConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2">Bu yapılandırmalar, Redis ile daha verimli ve güvenilir bir bağlantı yönetimi sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Spring Boot'ta Redis health check nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Spring Boot Actuator, Redis bağlantısının sağlık durumunu 
                            kontrol etmek için health endpoint'leri sağlar. Bu, Redis sunucusunun çalışıp çalışmadığını 
                            ve uygulamanın Redis'e bağlanıp bağlanamadığını kontrol etmemizi sağlar.</p>
                            <p class="mt-2 font-medium">Öncelikle gerekli bağımlılığı ekle:</p>
                            <pre class="code-block xml mt-2">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
                            <p class="mt-2 font-medium">application.yml'de health endpoint'ini yapılandır:</p>
                            <pre class="code-block yaml mt-2">management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: always</pre>
                            <p class="mt-2 font-medium">Özel bir Redis health indicator oluşturmak için:</p>
                            <pre class="code-block java mt-2">@Component
public class CustomRedisHealthIndicator implements HealthIndicator {

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Override
    public Health health() {
        try {
            RedisConnection connection = redisConnectionFactory.getConnection();
            connection.ping();
            connection.close();
            return Health.up()
                    .withDetail("message", "Redis connection successful")
                    .build();
        } catch (Exception e) {
            return Health.down()
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }
}</pre>
                            <p class="mt-2">Bu yapılandırmadan sonra, <code>/actuator/health</code> endpoint'ine yapılan istek, 
                            Redis bağlantısının sağlık durumunu içerecektir. Bu, monitoring sistemlerinde ve 
                            container health check'lerinde kullanılabilir.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Redis Caching Soruları -->
        <section id="redis-caching" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-bolt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Redis Caching</h2>
                </div>
                <p class="text-gray-600 mb-6">Redis ile caching stratejileri ve en iyi uygulamalar ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Cache-Aside (Look Aside) pattern nedir ve Redis ile nasıl uygulanır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache-Aside pattern, en yaygın caching stratejilerinden biridir. 
                            Uygulama öncelikle veriyi önbellekte arar, bulamazsa veritabanından çeker ve önbelleğe ekler.</p>
                            <p class="mt-2 font-medium">Redis ile Cache-Aside pattern uygulaması:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    private static final String PRODUCT_CACHE_PREFIX = "product:";

    public Product getProductById(Long id) {
        String cacheKey = PRODUCT_CACHE_PREFIX + id;
        
        // 1. Önbellekte ara
        Product product = (Product) redisTemplate.opsForValue().get(cacheKey);
        
        if (product == null) {
            // 2. Önbellekte yoksa veritabanından al
            product = productRepository.findById(id)
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
            
            // 3. Önbelleğe ekle
            redisTemplate.opsForValue().set(cacheKey, product);
            redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES); // 10 dakika TTL
        }
        
        return product;
    }

    public void updateProduct(Product product) {
        // Veritabanını güncelle
        productRepository.save(product);
        
        // Önbelleği güncelle
        String cacheKey = PRODUCT_CACHE_PREFIX + product.getId();
        redisTemplate.opsForValue().set(cacheKey, product);
        redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
    }

    public void deleteProduct(Long id) {
        // Veritabanından sil
        productRepository.deleteById(id);
        
        // Önbellekten sil
        String cacheKey = PRODUCT_CACHE_PREFIX + id;
        redisTemplate.delete(cacheKey);
    }
}</pre>
                            <p class="mt-2">Bu pattern, veritabanı yükünü azaltır ve uygulama performansını artırır. 
                            Ancak, önbellek ve veritabanı arasındaki tutarsızlıkları yönetmek için dikkatli olunmalıdır.</p>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Write-Through ve Write-Behind caching stratejileri arasındaki fark nedir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> İkisi de yazma işlemlerinde kullanılan caching stratejileridir, 
                            ancak farklı yaklaşımlar sunarlar:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Write-Through:</strong> Veri hem önbelleğe hem de veritabanına aynı anda yazılır. 
                                Bu, veri tutarlılığını sağlar ancak yazma işlemlerini yavaşlatabilir.</li>
                                <li><strong>Write-Behind:</strong> Veri önce önbelleğe yazılır ve daha sonra arka planda 
                                veritabanına zamanlanmış olarak yazılır. Bu, yazma işlemlerini hızlandırır ancak veri 
                                kaybı riski taşır.</li>
                            </ul>
                            <p class="mt-2 font-medium">Write-Through örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    private static final String PRODUCT_CACHE_PREFIX = "product:";

    public Product saveProduct(Product product) {
        // 1. Veritabanına kaydet
        Product savedProduct = productRepository.save(product);
        
        // 2. Önbelleğe kaydet
        String cacheKey = PRODUCT_CACHE_PREFIX + savedProduct.getId();
        redisTemplate.opsForValue().set(cacheKey, savedProduct);
        redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
        
        return savedProduct;
    }
}</pre>
                            <p class="mt-2 font-medium">Write-Behind örneği (basit uygulama):</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    @Autowired
    private TaskExecutor taskExecutor;

    private static final String PRODUCT_CACHE_PREFIX = "product:";

    public Product saveProductAsync(Product product) {
        // 1. Önce önbelleğe kaydet
        String cacheKey = PRODUCT_CACHE_PREFIX + product.getId();
        redisTemplate.opsForValue().set(cacheKey, product);
        redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
        
        // 2. Asenkron olarak veritabanına kaydet
        taskExecutor.execute(() -> {
            productRepository.save(product);
        });
        
        return product;
    }
}</pre>
                            <p class="mt-2">Write-Through, veri tutarlılığı kritik olan durumlarda tercih edilirken, 
                            Write-Behind performansın önemli olduğu ve veri kaybının tolere edilebildiği durumlarda kullanılır.</p>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Redis ile cache stampede (cache thundering herd) problemi nasıl çözülür?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache stampede, popüler bir önbellek anahtarının süresi dolduğunda, 
                            çok sayıda istemcinin aynı anda veritabanına gitmesi ve sistemi aşırı yüklemesi durumudur. 
                            Bu problemi çözmek için çeşitli stratejiler kullanılır:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Locking:</strong> İlk istek lock alır, diğerleri bekler.</li>
                                <li><strong>Probabilistic Early Expiration:</strong> Önbellek anahtarının süresi dolmadan 
                                önce rastgele bir süreyle yenilenmesi.</li>
                                <li><strong>Blank Value Caching:</strong> Veritabanında olmayan veriler için boş değer 
                                önbelleğe alınır.</li>
                            </ul>
                            <p class="mt-2 font-medium">Locking çözümü:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    private static final String PRODUCT_CACHE_PREFIX = "product:";
    private static final String PRODUCT_LOCK_PREFIX = "product_lock:";

    public Product getProductById(Long id) {
        String cacheKey = PRODUCT_CACHE_PREFIX + id;
        String lockKey = PRODUCT_LOCK_PREFIX + id;
        
        // 1. Önbellekte ara
        Product product = (Product) redisTemplate.opsForValue().get(cacheKey);
        
        if (product == null) {
            // 2. Lock almayı dene
            Boolean acquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "locked", 10, TimeUnit.SECONDS);
            
            if (Boolean.TRUE.equals(acquired)) {
                try {
                    // 3. Veritabanından al
                    product = productRepository.findById(id)
                            .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
                    
                    // 4. Önbelleğe ekle
                    redisTemplate.opsForValue().set(cacheKey, product);
                    redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
                } finally {
                    // 5. Lock'u serbest bırak
                    redisTemplate.delete(lockKey);
                }
            } else {
                // 6. Başka biri işlem yapıyor, biraz bekle ve tekrar dene
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return getProductById(id); // Recursive call
            }
        }
        
        return product;
    }
}</pre>
                            <p class="mt-2">Bu çözüm, aynı anda gelen çoklu isteklerin veritabanına gitmesini engeller ve 
                            sadece bir istek veriyi getirip önbelleğe koyar. Diğer istekler önbellekten okur.</p>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Redis ile cache warming (ön ısıtma) nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache warming, uygulama başladığında veya kullanılmadan önce 
                            önbelleği popüler verilerle doldurma işlemidir. Bu, ilk isteklerde önbellek miss'lerini 
                            azaltır ve performansı artırır.</p>
                            <p class="mt-2 font-medium">Örnek bir cache warming implementasyonu:</p>
                            <pre class="code-block java mt-2">@Service
public class CacheWarmupService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    @Autowired
    private ProductService productService;
    
    private static final String PRODUCT_CACHE_PREFIX = "product:";
    private static final String POPULAR_PRODUCTS_KEY = "popular:products";

    @PostConstruct
    public void warmupCache() {
        // Popüler ürünleri önbelleğe yükle
        List&lt;Product&gt; popularProducts = productRepository.findTop10ByOrderBySalesDesc();
        
        for (Product product : popularProducts) {
            String cacheKey = PRODUCT_CACHE_PREFIX + product.getId();
            redisTemplate.opsForValue().set(cacheKey, product);
            redisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
        }
        
        // Popüler ürün ID'lerini set olarak sakla
        Set&lt;String&gt; popularProductIds = popularProducts.stream()
                .map(product -> product.getId().toString())
                .collect(Collectors.toSet());
                
        redisTemplate.opsForSet().add(POPULAR_PRODUCTS_KEY, popularProductIds.toArray());
        redisTemplate.expire(POPULAR_PRODUCTS_KEY, 1, TimeUnit.HOURS);
    }
    
    public void warmupProduct(Long productId) {
        try {
            Product product = productService.getProductById(productId);
            String cacheKey = PRODUCT_CACHE_PREFIX + productId;
            redisTemplate.opsForValue().set(cacheKey, product);
            redisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
        } catch (Exception e) {
            // Hata durumunda logla
            System.err.println("Cache warming failed for product " + productId + ": " + e.getMessage());
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Zamanlanmış cache warming için:</p>
                            <pre class="code-block java mt-2">@Service
public class ScheduledCacheWarmupService {

    @Autowired
    private CacheWarmupService cacheWarmupService;
    
    // Her saat başı çalışır
    @Scheduled(cron = "0 0 * * * *")
    public void scheduledCacheWarmup() {
        cacheWarmupService.warmupCache();
    }
    
    // Her 5 dakikada bir çalışır
    @Scheduled(fixedRate = 5 * 60 * 1000)
    public void frequentCacheWarmup() {
        // Sık erişilen verileri önbelleğe al
        cacheWarmupService.warmupFrequentlyAccessedData();
    }
}</pre>
                            <p class="mt-2">Cache warming, özellikle trafik artışları öncesi veya planlı bakım sonrası 
                            kullanışlıdır. Bu, kullanıcıların ilk isteklerinde gecikme yaşamamasını sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Redis ile cache eviction (önbellek temizleme) stratejileri nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache eviction, önbellekteki verilerin temizlenmesi için kullanılan 
                            stratejilerdir. Redis çeşitli eviction stratejileri sunar:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>noeviction:</strong> Bellek dolduğunda yeni veri eklenmez, hata döner.</li>
                                <li><strong>allkeys-lru:</strong> En az kullanılan (Least Recently Used) anahtarları siler.</li>
                                <li><strong>allkeys-lfu:</strong> En az kullanılan sıklığa sahip (Least Frequently Used) anahtarları siler.</li>
                                <li><strong>volatile-lru:</strong> TTL ayarlanmış anahtarlardan en az kullanılanları siler.</li>
                                <li><strong>volatile-lfu:</strong> TTL ayarlanmış anahtarlardan en az kullanılan sıklığa sahip olanları siler.</li>
                                <li><strong>allkeys-random:</strong> Rastgele anahtarları siler.</li>
                                <li><strong>volatile-random:</strong> TTL ayarlanmış anahtarlardan rastgele olanları siler.</li>
                                <li><strong>volatile-ttl:</strong> En kısa TTL'ye sahip anahtarları siler.</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis yapılandırmasında eviction ayarlama:</p>
                            <pre class="code-block bash mt-2"># redis.conf
maxmemory 1gb
maxmemory-policy allkeys-lru</pre>
                            <p class="mt-2 font-medium">Spring Boot uygulamasında eviction yapılandırması:</p>
                            <pre class="code-block yaml mt-2">spring:
  redis:
    host: localhost
    port: 6379
    jedis:
      pool:
        max-active: 10
    lettuce:
      pool:
        max-active: 10
  cache:
    type: redis
    redis:
      time-to-live: 60000  # 1 dakika
      cache-null-values: false
      key-prefix: myapp_
      use-key-prefix: true</pre>
                            <p class="mt-2">Doğru eviction stratejisi seçimi, uygulamanın veri erişim pattern'lerine bağlıdır. 
                            Örneğin, sosyal medya uygulamalarında LFU daha uygun olabilirken, e-ticaret uygulamalarında 
                            LRU daha iyi performans sağlayabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Redis ile multi-level caching nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Multi-level caching, birden fazla önbellek katmanını birleştirerek 
                            performansı optimize etme stratejisidir. Genellikle yerel (in-memory) önbellek ve dağıtık 
                            önbellek (Redis) birlikte kullanılır.</p>
                            <p class="mt-2 font-medium">Örnek bir multi-level caching implementasyonu:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    // Yerel önbellek (Caffeine)
    private final Cache&lt;Long, Product&gt; localCache = Caffeine.newBuilder()
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .maximumSize(1000)
            .build();

    private static final String PRODUCT_CACHE_PREFIX = "product:";

    public Product getProductById(Long id) {
        // 1. Yerel önbellekte ara
        Product product = localCache.getIfPresent(id);
        
        if (product == null) {
            // 2. Redis'te ara
            String cacheKey = PRODUCT_CACHE_PREFIX + id;
            product = (Product) redisTemplate.opsForValue().get(cacheKey);
            
            if (product == null) {
                // 3. Veritabanından al
                product = productRepository.findById(id)
                        .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
                
                // 4. Redis'e ekle
                redisTemplate.opsForValue().set(cacheKey, product);
                redisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
            }
            
            // 5. Yerel önbelleğe ekle
            localCache.put(id, product);
        }
        
        return product;
    }

    public void updateProduct(Product product) {
        // Veritabanını güncelle
        productRepository.save(product);
        
        // Redis'i güncelle
        String cacheKey = PRODUCT_CACHE_PREFIX + product.getId();
        redisTemplate.opsForValue().set(cacheKey, product);
        redisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
        
        // Yerel önbelleği güncelle
        localCache.put(product.getId(), product);
    }

    public void deleteProduct(Long id) {
        // Veritabanından sil
        productRepository.deleteById(id);
        
        // Redis'ten sil
        String cacheKey = PRODUCT_CACHE_PREFIX + id;
        redisTemplate.delete(cacheKey);
        
        // Yerel önbellekten sil
        localCache.invalidate(id);
    }
}</pre>
                            <p class="mt-2">Bu strateji, en sık kullanılan veriler için çok düşük gecikme süresi (yerel önbellek) 
                            ve daha az kullanılan veriler için yüksek erişilebilirlik (Redis) sağlar. Özellikle yüksek 
                            trafikli uygulamalarda performansı önemli ölçüde artırır.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Redis ile cache invalidation (önbellek geçersiz kılma) nasıl yönetilir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache invalidation, önbellekteki verilerin güncelliğini sağlamak için 
                            kullanılır. Veritabanındaki veriler değiştiğinde, ilgili önbellek girdilerinin güncellenmesi 
                            veya silinmesi gerekir.</p>
                            <p class="mt-2 font-medium">Örnek bir cache invalidation implementasyonu:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    private static final String PRODUCT_CACHE_PREFIX = "product:";
    private static final String PRODUCT_LIST_CACHE_KEY = "products:list";

    @Cacheable(value = "products", key = "#id")
    public Product getProductById(Long id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
    }

    @CachePut(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        Product updatedProduct = productRepository.save(product);
        
        // Ürün güncellendiğinde ürün listesi önbelleğini geçersiz kıl
        redisTemplate.delete(PRODUCT_LIST_CACHE_KEY);
        
        // Ürün güncelleme olayını yayınla
        eventPublisher.publishEvent(new ProductUpdatedEvent(updatedProduct));
        
        return updatedProduct;
    }

    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
        
        // Ürün silindiğinde ürün listesi önbelleğini geçersiz kıl
        redisTemplate.delete(PRODUCT_LIST_CACHE_KEY);
        
        // Ürün silme olayını yayınla
        eventPublisher.publishEvent(new ProductDeletedEvent(id));
    }

    @Cacheable(value = "productLists", key = "'all'")
    public List&lt;Product&gt; getAllProducts() {
        return productRepository.findAll();
    }
}</pre>
                            <p class="mt-2 font-medium">Olay tabanlı cache invalidation:</p>
                            <pre class="code-block java mt-2">@Component
public class CacheInvalidationListener {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @EventListener
    public void handleProductUpdatedEvent(ProductUpdatedEvent event) {
        // İlgili önbellek anahtarlarını geçersiz kıl
        Long productId = event.getProduct().getId();
        
        // Ürün detay önbelleği zaten @CachePut ile güncellendi
        
        // Diğer ilgili önbellekleri geçersiz kıl
        redisTemplate.delete("products:category:" + event.getProduct().getCategory());
        redisTemplate.delete("products:related:" + productId);
    }

    @EventListener
    public void handleProductDeletedEvent(ProductDeletedEvent event) {
        Long productId = event.getProductId();
        
        // İlgili tüm önbellekleri geçersiz kıl
        redisTemplate.delete("products:category:*");
        redisTemplate.delete("products:related:" + productId);
        redisTemplate.delete("products:search:*");
    }
}</pre>
                            <p class="mt-2">Bu yaklaşım, veri tutarlılığını sağlar ve eski verilerin önbellekte kalmasını önler. 
                            Özellikle dağıtık sistemlerde, olay tabanlı invalidasyon farklı servisler arasında 
                            tutarlılığı sağlamak için önemlidir.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Redis ile cache coherency (tutarlılık) nasıl sağlanır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache coherency, önbellekteki verilerin veritabanındaki verilerle 
                            tutarlı olmasını sağlama işlemidir. Dağıtık sistemlerde bu özellikle zordur ve çeşitli 
                            stratejilerle yönetilir.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Write-through cache:</strong> Veri hem önbelleğe hem de veritabanına yazılır.</li>
                                <li><strong>Cache invalidation:</strong> Veri değiştiğinde önbellek geçersiz kılınır.</li>
                                <li><strong>TTL (Time To Live):</strong> Önbellek verilerinin süresi belirli bir süre sonra dolar.</li>
                                <li><strong>Read-repair:</strong> Eski veri okunduğunda veritabanından güncel veri çekilir.</li>
                                <li><strong>Versioning:</strong> Verilere versiyon numarası eklenir ve güncellik kontrol edilir.</li>
                            </ul>
                            <p class="mt-2 font-medium">Versioning ile cache coherency örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    private static final String PRODUCT_CACHE_PREFIX = "product:";

    public Product getProductById(Long id) {
        String cacheKey = PRODUCT_CACHE_PREFIX + id;
        
        // Önbellekten ürün ve versiyon bilgisini al
        Map&lt;String, Object&gt; cachedData = (Map&lt;String, Object&gt;) redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedData != null) {
            Long cachedVersion = (Long) cachedData.get("version");
            Product cachedProduct = (Product) cachedData.get("product");
            
            // Veritabanından güncel versiyonu kontrol et
            Product dbProduct = productRepository.findById(id).orElse(null);
            
            if (dbProduct != null && dbProduct.getVersion() > cachedVersion) {
                // Veritabanı daha güncel, önbelleği güncelle
                Map&lt;String, Object&gt; updatedData = new HashMap&lt;&gt;();
                updatedData.put("product", dbProduct);
                updatedData.put("version", dbProduct.getVersion());
                
                redisTemplate.opsForValue().set(cacheKey, updatedData);
                redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
                
                return dbProduct;
            } else {
                // Önbellek güncel, önbellekten döndür
                return cachedProduct;
            }
        } else {
            // Önbellekte yok, veritabanından al
            Product product = productRepository.findById(id)
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
            
            // Önbelleğe ekle
            Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();
            data.put("product", product);
            data.put("version", product.getVersion());
            
            redisTemplate.opsForValue().set(cacheKey, data);
            redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
            
            return product;
        }
    }

    public Product updateProduct(Product product) {
        // Versiyonu artır
        product.setVersion(product.getVersion() + 1);
        
        // Veritabanını güncelle
        Product updatedProduct = productRepository.save(product);
        
        // Önbelleği güncelle
        String cacheKey = PRODUCT_CACHE_PREFIX + updatedProduct.getId();
        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();
        data.put("product", updatedProduct);
        data.put("version", updatedProduct.getVersion());
        
        redisTemplate.opsForValue().set(cacheKey, data);
        redisTemplate.expire(cacheKey, 10, TimeUnit.MINUTES);
        
        return updatedProduct;
    }
}</pre>
                            <p class="mt-2">Bu yaklaşım, önbellekteki verilerin güncelliğini kontrol eder ve eski verilerin 
                            kullanılmasını önler. Özellikle birden fazla uygulama örneğinin aynı veriyi güncellediği 
                            durumlarda önemlidir.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Redis ile cache partitioning (bölümlendirme) nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache partitioning, büyük önbellekleri daha küçük parçalara bölerek 
                            yönetme işlemidir. Bu, önbellek performansını artırır ve ölçeklenebilirliği sağlar.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Veriye dayalı bölümlendirme:</strong> Verilerin özelliklerine göre farklı 
                                önbellek bölümlerine kaydedilmesi.</li>
                                <li><strong>Hash tabanlı bölümlendirme:</strong> Anahtarların hash değerlerine göre farklı 
                                önbellek sunucularına yönlendirilmesi.</li>
                                <li><strong>Redis Cluster:</strong> Redis'in yerleşik cluster özelliğinin kullanılması.</li>
                            </ul>
                            <p class="mt-2 font-medium">Veriye dayalı bölümlendirme örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class PartitionedCacheService {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; userRedisTemplate;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; productRedisTemplate;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; orderRedisTemplate;

    public void cacheUser(User user) {
        String cacheKey = "user:" + user.getId();
        userRedisTemplate.opsForValue().set(cacheKey, user);
        userRedisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
    }

    public User getUser(Long userId) {
        String cacheKey = "user:" + userId;
        return (User) userRedisTemplate.opsForValue().get(cacheKey);
    }

    public void cacheProduct(Product product) {
        String cacheKey = "product:" + product.getId();
        productRedisTemplate.opsForValue().set(cacheKey, product);
        productRedisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
    }

    public Product getProduct(Long productId) {
        String cacheKey = "product:" + productId;
        return (Product) productRedisTemplate.opsForValue().get(cacheKey);
    }

    public void cacheOrder(Order order) {
        String cacheKey = "order:" + order.getId();
        orderRedisTemplate.opsForValue().set(cacheKey, order);
        orderRedisTemplate.expire(cacheKey, 1, TimeUnit.HOURS);
    }

    public Order getOrder(Long orderId) {
        String cacheKey = "order:" + orderId;
        return (Order) orderRedisTemplate.opsForValue().get(cacheKey);
    }
}</pre>
                            <p class="mt-2 font-medium">Hash tabanlı bölümlendirme örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class HashPartitionedCacheService {

    private final List&lt;RedisTemplate&lt;String, Object&gt;&gt; redisTemplates;
    private final int numberOfShards;

    public HashPartitionedCacheService(List&lt;RedisTemplate&lt;String, Object&gt;&gt; redisTemplates) {
        this.redisTemplates = redisTemplates;
        this.numberOfShards = redisTemplates.size();
    }

    private RedisTemplate&lt;String, Object&gt; getShard(String key) {
        int shardIndex = Math.abs(key.hashCode()) % numberOfShards;
        return redisTemplates.get(shardIndex);
    }

    public void cacheData(String key, Object value) {
        RedisTemplate&lt;String, Object&gt; template = getShard(key);
        template.opsForValue().set(key, value);
        template.expire(key, 1, TimeUnit.HOURS);
    }

    public Object getData(String key) {
        RedisTemplate&lt;String, Object&gt; template = getShard(key);
        return template.opsForValue().get(key);
    }
}</pre>
                            <p class="mt-2">Cache partitioning, büyük ölçekli uygulamalarda önbellek performansını artırır ve 
                            tek bir önbellek sunucusuna olan bağımlılığı azaltır. Redis Cluster, bu işlemi otomatik olarak 
                            yapar ve veri dağıtımını yönetir.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Redis ile cache monitoring (izleme) nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Cache monitoring, önbelleğin performansını, kullanımını ve 
                            sağlık durumunu izleme işlemidir. Redis çeşitli metrikler ve komutlar aracılığıyla monitoring 
                            imkanları sunar.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Redis INFO komutu:</strong> Sunucu istatistiklerini ve metriklerini gösterir.</li>
                                <li><strong>Redis MONITOR komutu:</strong> Tüm Redis komutlarını gerçek zamanlı olarak gösterir.</li>
                                <li><strong>Redis SLOWLOG komutu:</strong> Yavaş sorguları gösterir.</li>
                                <li><strong>Spring Boot Actuator:</strong> Redis metriklerini ve sağlık durumunu izler.</li>
                                <li><strong>Prometheus + Grafana:</strong> Redis metriklerini görselleştirir.</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis INFO komutu çıktısı:</p>
                            <pre class="code-block bash mt-2">$ redis-cli INFO

# Server
redis_version:6.2.6
os:Linux 5.4.0-80-generic
...

# Memory
used_memory:1048576
used_memory_human:1.00M
used_memory_peak:2097152
used_memory_peak_human:2.00M
...

# Stats
total_connections_received:10
total_commands_processed:100
instantaneous_ops_per_sec:0
total_net_input_bytes:5000
total_net_output_bytes:10000
...

# KeySpace
db0:keys=5,expires=0,avg_ttl=0</pre>
                            <p class="mt-2 font-medium">Spring Boot ile Redis monitoring:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisMetricsConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .disableCachingNullValues()
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .transactionAware()
                .build();
    }

    @Bean
    public MeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCommonTags() {
        return registry -> registry.config().commonTags("application", "myapp");
    }

    @Bean
    public RedisMetrics redisMetrics(RedisConnectionFactory connectionFactory) {
        return new RedisMetrics(connectionFactory, "redis", Collections.emptyList());
    }
}</pre>
                            <p class="mt-2 font-medium">Prometheus ile Redis metriklerini toplama:</p>
                            <pre class="code-block yaml mt-2"># prometheus.yml
scrape_configs:
  - job_name: 'redis'
    static_configs:
      - targets: ['localhost:6379']</pre>
                            <p class="mt-2">Redis monitoring, önbellek performansını izlemek, sorunları teşhis etmek ve 
                            kapasite planlaması yapmak için önemlidir. Özellikle üretim ortamlarında düzenli monitoring 
                            yapılması, önbellek ile ilgili sorunların önceden tespit edilmesine yardımcı olur.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Redis Performans Soruları -->
        <section id="redis-performans" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-tachometer-alt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Redis Performans</h2>
                </div>
                <p class="text-gray-600 mb-6">Redis performans optimizasyonu ve tünelleme ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Redis performansını etkileyen faktörler nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis performansı çeşitli faktörlerden etkilenir. Bu faktörleri 
                            anlamak, Redis'in en iyi şekilde çalışmasını sağlamak için önemlidir:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Ağ gecikmesi:</strong> Redis istemcisi ile sunucu arasındaki ağ gecikmesi, 
                                özellikle yüksek hacimli işlemlerde performansı etkiler.</li>
                                <li><strong>Bellek kullanımı:</strong> Yetersiz bellek, sık sık disk yazmalarına neden 
                                olur ve performansı düşürür.</li>
                                <li><strong>Veri yapısı seçimi:</strong> Doğru veri yapısını seçmek, bellek verimliliği 
                                ve işlem hızı açısından önemlidir.</li>
                                <li><strong>Pipelining kullanımı:</strong> Komutları toplu halde göndermek, ağ gecikmesini 
                                azaltır ve performansı artırır.</li>
                                <li><strong>Bağlantı havuzu:</strong> Bağlantı havuzu, bağlantı kurma maliyetini azaltır.</li>
                                <li><strong>Persistans stratejisi:</strong> RDB veya AOF kullanımı, performansı etkileyebilir.</li>
                                <li><strong>İstemci yapılandırması:</strong> Timeout, serileştirme ve diğer istemci 
                                ayarları performansı etkiler.</li>
                                <li><strong>Donanım:</strong> CPU, RAM ve disk hızı performansı doğrudan etkiler.</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis performansını ölçmek için kullanılan komutlar:</p>
                            <pre class="code-block bash mt-2"># Redis gecikmesini ölçme
redis-cli --latency

# Yavaş sorguları görme
SLOWLOG GET

# Bellek kullanımını görme
INFO memory

# İşlem sayısını görme
INFO stats</pre>
                            <p class="mt-2">Bu faktörleri optimize ederek Redis performansını önemli ölçüde artırabilirsiniz.</p>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Redis'te pipelining nasıl performansı artırır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Pipelining, birden fazla komutu tek bir istekte göndermek ve tüm 
                            yanıtları tek bir seferde almak için kullanılan bir tekniktir. Bu, ağ gecikmesini azaltır ve 
                            performansı önemli ölçüde artırır.</p>
                            <p class="mt-2 font-medium">Pipelining olmadan:</p>
                            <pre class="code-block bash mt-2"># Her komut için ayrı bir ağ turu gerekir
redis-cli SET key1 value1
redis-cli SET key2 value2
redis-cli SET key3 value3
redis-cli GET key1
redis-cli GET key2
redis-cli GET key3</pre>
                            <p class="mt-2 font-medium">Pipelining ile:</p>
                            <pre class="code-block bash mt-2"># Tüm komutlar tek bir ağ turunda gönderilir
redis-cli --pipe
SET key1 value1
SET key2 value2
SET key3 value3
GET key1
GET key2
GET key3
EOF</pre>
                            <p class="mt-2 font-medium">Java ile Redis pipelining örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class ProductService {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public void batchUpdateProducts(List&lt;Product&gt; products) {
        // Pipeline oluştur
        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                for (Product product : products) {
                    String key = "product:" + product.getId();
                    stringRedisConn.set(key, product.toString());
                }
                
                return null;
            }
        });
    }

    public List&lt;Product&gt; batchGetProducts(List&lt;Long&gt; productIds) {
        // Pipeline ile çoklu okuma
        List&lt;Object&gt; results = redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                for (Long id : productIds) {
                    String key = "product:" + id;
                    stringRedisConn.get(key);
                }
                
                return null;
            }
        });
        
        // Sonuçları işle
        List&lt;Product&gt; products = new ArrayList&lt;&gt;();
        for (Object result : results) {
            if (result != null) {
                products.add(Product.fromString(result.toString()));
            }
        }
        
        return products;
    }
}</pre>
                            <p class="mt-2">Pipelining, özellikle çok sayıda komutun bir arada gönderilmesi gereken durumlarda 
                            (örneğin, toplu veri işleme) performansı önemli ölçüde artırır. Ağ gecikmesi yüksek olduğunda 
                            bu fark daha belirgin hale gelir.</p>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Redis bellek optimizasyonu nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis bellek optimizasyonu, verileri daha verimli bir şekilde 
                            saklayarak bellek kullanımını azaltma işlemidir. Bu, daha fazla veriyi aynı bellekte 
                            saklamayı mümkün kılar ve performansı artırır.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Veri yapılarını doğru seçme:</strong> Her kullanım durumu için en uygun veri 
                                yapısını seçmek bellek kullanımını optimize eder.</li>
                                <li><strong>Kısa anahtarlar kullanma:</strong> Anahtarları mümkün olduğunca kısa ve anlamlı tutmak.</li>
                                <li><small>Hash'lar kullanma:</small> İlgili alanları tek bir anahtar altında gruplamak.</li>
                                <li><strong>ZipList kullanımı:</strong> Küçük listeler ve sorted set'ler için ZipList kullanmak.</li>
                                <li><strong>IntSet kullanımı:</strong> Sadece tamsayı içeren set'ler için IntSet kullanmak.</li>
                                <li><strong>Veri sıkıştırma:</strong> Büyük verileri sıkıştırmak.</li>
                                <li><strong>Veri parçalama:</strong> Büyük verileri daha küçük parçalara bölmek.</li>
                            </ul>
                            <p class="mt-2 font-medium">Hash kullanımı örneği:</p>
                            <pre class="code-block bash mt-2"># Verimsiz kullanım (çoklu anahtar)
SET user:1:name "Ahmet"
SET user:1:surname "Yılmaz"
SET user:1:email "ahmet@example.com"
SET user:1:age "30"

# Verimli kullanım (tek hash)
HSET user:1 name "Ahmet" surname "Yılmaz" email "ahmet@example.com" age "30"</pre>
                            <p class="mt-2 font-medium">ZipList yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Küçük listeler için ZipList kullanımı
list-max-ziplist-size -2  # 8KB
list-compress-depth 0

# Küçük set'ler için ZipList kullanımı
set-max-intset-entries 512</pre>
                            <p class="mt-2 font-medium">Java ile bellek optimizasyonu:</p>
                            <pre class="code-block java mt-2">@Service
public class OptimizedUserService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void saveUserOptimized(User user) {
        String key = "user:" + user.getId();
        
        // Hash olarak kaydet (daha verimli)
        Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;();
        userMap.put("name", user.getName());
        userMap.put("surname", user.getSurname());
        userMap.put("email", user.getEmail());
        userMap.put("age", String.valueOf(user.getAge()));
        
        redisTemplate.opsForHash().putAll(key, userMap);
        redisTemplate.expire(key, 1, TimeUnit.HOURS);
    }

    public User getUserOptimized(Long userId) {
        String key = "user:" + userId;
        
        // Hash olarak oku
        Map&lt;Object, Object&gt; userMap = redisTemplate.opsForHash().entries(key);
        
        if (userMap.isEmpty()) {
            return null;
        }
        
        User user = new User();
        user.setId(userId);
        user.setName((String) userMap.get("name"));
        user.setSurname((String) userMap.get("surname"));
        user.setEmail((String) userMap.get("email"));
        user.setAge(Integer.parseInt((String) userMap.get("age")));
        
        return user;
    }
}</pre>
                            <p class="mt-2">Bu optimizasyonlar, Redis bellek kullanımını önemli ölçüde azaltabilir ve aynı 
                            fiziksel bellekte daha fazla veri saklanmasını sağlayabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Redis'te yavaş sorgular nasıl tespit edilir ve optimize edilir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te yavaş sorgular, performansı etkileyen önemli faktörlerdir. 
                            Bu sorguları tespit edip optimize etmek, Redis performansını artırır.</p>
                            <p class="mt-2 font-medium">Yavaş sorguları tespit etme:</p>
                            <pre class="code-block bash mt-2"># Yavaş sorgu eşiğini ayarla (mikrosaniye cinsinden)
CONFIG SET slowlog-log-slower-than 10000

# Yavaş sorgu log uzunluğunu ayarla
CONFIG SET slowlog-max-len 128

# Yavaş sorguları görüntüle
SLOWLOG GET

# Son 10 yavaş sorguyu görüntüle
SLOWLOG GET 10</pre>
                            <p class="mt-2 font-medium">Yaygın yavaş sorgular ve optimizasyonları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>KEYS komutu:</strong> Büyük veri setlerinde tüm anahtarları listelemek yavaştır. 
                                Bunun yerine SCAN komutu kullanılmalı.</li>
                                <li><strong>Büyük LIST/SET işlemleri:</strong> Büyük listeler veya set'ler üzerinde 
                                işlemler yavaş olabilir. Bunun yerine veri parçalama veya farklı veri yapıları 
                                kullanılmalı.</li>
                                <li><strong>FLUSHDB/FLUSHALL:</strong> Tüm veritabanını silmek yavaştır. 
                                Üretim ortamında dikkatli kullanılmalı.</li>
                                <li><strong>Büyük HASH işlemleri:</strong> Büyük hash'ler üzerinde HGETALL gibi işlemler 
                                yavaş olabilir. Bunun yerine HSCAN veya alan bazında okuma yapılmalı.</li>
                            </ul>
                            <p class="mt-2 font-medium">KEYS yerine SCAN kullanımı:</p>
                            <pre class="code-block bash mt-2"># Yavaş olan KEYS komutu
KEYS user:*

# Optimize edilmiş SCAN komutu
SCAN 0 MATCH user:* COUNT 100</pre>
                            <p class="mt-2 font-medium">Java ile SCAN kullanımı:</p>
                            <pre class="code-block java mt-2">@Service
public class OptimizedUserService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public List&lt;String&gt; getAllUserKeys() {
        List&lt;String&gt; keys = new ArrayList&lt;&gt;();
        ScanOptions options = ScanOptions.scanOptions().match("user:*").count(100).build();
        
        // Cursor ile verimli tarama
        try (Cursor&lt;String&gt; cursor = redisTemplate.scan(options)) {
            while (cursor.hasNext()) {
                keys.add(cursor.next());
            }
        } catch (Exception e) {
            // Hata yönetimi
        }
        
        return keys;
    }
}</pre>
                            <p class="mt-2 font-medium">Büyük veri setlerini parçalama:</p>
                            <pre class="code-block java mt-2">@Service
public class OptimizedAnalyticsService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void recordPageView(String userId, String pageId) {
        // Tüm sayfa görüntülemelerini tek bir anahtarda saklamak yerine
        // Kullanıcı ve sayfa bazında parçala
        String key = "pageviews:" + userId + ":" + pageId;
        redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, 7, TimeUnit.DAYS);
    }

    public Long getPageViews(String userId, String pageId) {
        String key = "pageviews:" + userId + ":" + pageId;
        String value = redisTemplate.opsForValue().get(key);
        return value != null ? Long.parseLong(value) : 0L;
    }
}</pre>
                            <p class="mt-2">Yavaş sorguları düzenli olarak izlemek ve optimize etmek, Redis performansını 
                            yüksek tutmak için önemlidir.</p>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Redis connection pooling nasıl performansı artırır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis connection pooling, istemciler ile Redis sunucusu arasındaki 
                            bağlantıları yeniden kullanarak performansı artırır. Her istek için yeni bir bağlantı 
                            oluşturmak yerine, havuzdaki mevcut bağlantıları kullanır.</p>
                            <p class="mt-2 font-medium">Connection pooling avantajları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Bağlantı kurma maliyetini azaltır</li>
                                <li>Ağ kaynaklarını verimli kullanır</li>
                                <li>Yüksek eşzamanlı istekleri daha iyi yönetir</li>
                                <li>Bağlantı sayısını sınırlayarak Redis sunucusunu korur</li>
                            </ul>
                            <p class="mt-2 font-medium">Lettuce connection pool yapılandırması:</p>
                            <pre class="code-block yaml mt-2">spring:
  redis:
    host: localhost
    port: 6379
    lettuce:
      pool:
        max-active: 100   # Maksimum aktif bağlantı sayısı
        max-idle: 50      # Boştaki maksimum bağlantı sayısı
        min-idle: 10      # Boştaki minimum bağlantı sayısı
        max-wait: 5000ms  # Bağlantı havuzunda bağlantı yoksa bekleme süresi</pre>
                            <p class="mt-2 font-medium">Özel connection pool yapılandırması:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisConfig {

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("localhost");
        redisConfig.setPort(6379);
        
        // Connection pool yapılandırması
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .clientOptions(ClientOptions.builder()
                        .autoReconnect(true)
                        .build())
                .poolConfig(GenericObjectPoolConfig&lt;LettuceConnection&gt;().builder()
                        .maxTotal(100)
                        .maxIdle(50)
                        .minIdle(10)
                        .maxWaitMillis(5000)
                        .build())
                .build();
        
        return new LettuceConnectionFactory(redisConfig, clientConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2 font-medium">Jedis connection pool yapılandırması:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisConfig {

    @Bean
    public JedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("localhost");
        redisConfig.setPort(6379);
        
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisConfig);
        
        // Jedis connection pool yapılandırması
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(100);
        poolConfig.setMaxIdle(50);
        poolConfig.setMinIdle(10);
        poolConfig.setMaxWaitMillis(5000);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestWhileIdle(true);
        
        jedisConnectionFactory.setUsePool(true);
        jedisConnectionFactory.setPoolConfig(poolConfig);
        
        return jedisConnectionFactory;
    }
}</pre>
                            <p class="mt-2">Doğru yapılandırılmış bir connection pool, Redis performansını önemli ölçüde 
                            artırabilir. Özellikle yüksek trafikli uygulamalarda, bağlantı havuzu optimizasyonu 
                            kritik öneme sahiptir.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Redis'te komut optimizasyonu nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te komut optimizasyonu, verimli komutlar kullanarak 
                            performansı artırma işlemidir. Doğru komutları seçmek ve kullanmak, Redis'in daha hızlı 
                            çalışmasını sağlar.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Atomik komutlar kullanma:</strong> INCR, DECR, HINCRBY gibi atomik komutlar, 
                                birden fazla komutun işlevini tek bir komutta yapar.</li>
                                <li><strong>Toplu işlemler kullanma:</strong> MSET, MGET gibi komutlar, çoklu işlemleri 
                                tek bir komutta yapar.</li>
                                <li><strong>Doğru veri yapılarını seçme:</strong> Her kullanım durumu için en uygun veri 
                                yapısını seçmek.</li>
                                <li><strong>Bit işlemleri kullanma:</strong> Bit işlemleri, bellek verimliliği sağlar.</li>
                                <li><strong>LUA scripting kullanma:</strong> Karmaşık işlemleri sunucu tarafında çalıştırarak 
                                ağ gecikmesini azaltır.</li>
                            </ul>
                            <p class="mt-2 font-medium">Atomik komutlar örneği:</p>
                            <pre class="code-block bash mt-2"># Verimsiz kullanım
GET counter
SET counter [hesaplanmış değer]

# Optimize edilmiş kullanım
INCR counter</pre>
                            <p class="mt-2 font-medium">Toplu işlemler örneği:</p>
                            <pre class="code-block bash mt-2"># Verimsiz kullanım
SET key1 value1
SET key2 value2
SET key3 value3

# Optimize edilmiş kullanım
MSET key1 value1 key2 value2 key3 value3</pre>
                            <p class="mt-2 font-medium">Java ile toplu işlemler:</p>
                            <pre class="code-block java mt-2">@Service
public class OptimizedProductService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void batchUpdateProducts(Map&lt;Long, String&gt; productUpdates) {
        // Toplu güncelleme için pipeline kullan
        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                for (Map.Entry&lt;Long, String&gt; entry : productUpdates.entrySet()) {
                    String key = "product:" + entry.getKey();
                    stringRedisConn.set(key, entry.getValue());
                }
                
                return null;
            }
        });
    }

    public Map&lt;Long, String&gt; batchGetProducts(List&lt;Long&gt; productIds) {
        // Çoklu okuma için pipeline kullan
        List&lt;Object&gt; results = redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                for (Long id : productIds) {
                    String key = "product:" + id;
                    stringRedisConn.get(key);
                }
                
                return null;
            }
        });
        
        // Sonuçları işle
        Map&lt;Long, String&gt; products = new HashMap&lt;&gt;();
        for (int i = 0; i < productIds.size(); i++) {
            Long id = productIds.get(i);
            Object result = results.get(i);
            if (result != null) {
                products.put(id, result.toString());
            }
        }
        
        return products;
    }
}</pre>
                            <p class="mt-2 font-medium">LUA scripting ile komut optimizasyonu:</p>
                            <pre class="code-block lua mt-2"-- Sayaç artırma ve limit kontrolü
local current = redis.call('GET', KEYS[1])
if current then
    current = tonumber(current) + tonumber(ARGV[1])
else
    current = tonumber(ARGV[1])
end

if current > tonumber(ARGV[2]) then
    return 0  -- Limit aşıldı
else
    redis.call('SET', KEYS[1], current)
    return 1  -- Başarılı
end</pre>
                            <p class="mt-2">Komut optimizasyonu, Redis performansını önemli ölçüde artırabilir. Özellikle 
                            yüksek trafikli uygulamalarda, doğru komutları kullanmak kritik öneme sahiptir.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Redis'te veri sıkıştırma nasıl yapılır ve performansa etkisi nedir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te veri sıkıştırma, büyük verileri daha az bellekte saklamak 
                            için kullanılan bir tekniktir. Bu, bellek kullanımını azaltır ancak CPU kullanımını artırır.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Daha az bellek kullanımı</li>
                                        <li>Daha fazla verinin aynı bellekte saklanması</li>
                                        <li>Daha az disk alanı kullanımı (persistans durumunda)</li>
                                    </ul>
                                </li>
                                <li><strong>Dezavantajları:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Daha yüksek CPU kullanımı</li>
                                        <li>Sıkıştırma/açma gecikmesi</li>
                                        <li>Karmaşık implementasyon</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="mt-2 font-medium">Java ile veri sıkıştırma örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class CompressedDataService {

    @Autowired
    private RedisTemplate&lt;String, byte[]&gt; redisTemplate;

    private static final String COMPRESSION_PREFIX = "compressed:";

    public void saveCompressedData(String key, String data) {
        try {
            // Veriyi sıkıştır
            byte[] compressed = compress(data);
            
            // Redis'e kaydet
            redisTemplate.opsForValue().set(COMPRESSION_PREFIX + key, compressed);
            redisTemplate.expire(COMPRESSION_PREFIX + key, 1, TimeUnit.HOURS);
        } catch (IOException e) {
            throw new RuntimeException("Sıkıştırma hatası", e);
        }
    }

    public String getCompressedData(String key) {
        try {
            // Redis'ten oku
            byte[] compressed = redisTemplate.opsForValue().get(COMPRESSION_PREFIX + key);
            
            if (compressed == null) {
                return null;
            }
            
            // Sıkıştırmayı aç
            return decompress(compressed);
        } catch (IOException e) {
            throw new RuntimeException("Sıkıştırma açma hatası", e);
        }
    }

    private byte[] compress(String data) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream(data.length());
        Deflater compressor = new Deflater();
        compressor.setLevel(Deflater.BEST_COMPRESSION);
        compressor.setInput(data.getBytes());
        compressor.finish();
        
        byte[] buf = new byte[1024];
        while (!compressor.finished()) {
            int count = compressor.deflate(buf);
            bos.write(buf, 0, count);
        }
        
        compressor.end();
        bos.close();
        return bos.toByteArray();
    }

    private String decompress(byte[] compressed) throws IOException {
        ByteArrayInputStream bis = new ByteArrayInputStream(compressed);
        Inflater decompressor = new Inflater();
        decompressor.setInput(compressed);
        
        ByteArrayOutputStream bos = new ByteArrayOutputStream(compressed.length);
        byte[] buf = new byte[1024];
        
        while (!decompressor.finished()) {
            int count = decompressor.inflate(buf);
            bos.write(buf, 0, count);
        }
        
        decompressor.end();
        bos.close();
        bis.close();
        
        return bos.toString();
    }
}</pre>
                            <p class="mt-2 font-medium">Redis'in yerleşik sıkıştırma özellikleri:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# List/set/zset/hash için sıkıştırma etkinleştirme
list-compress-depth 0
list-max-ziplist-size -2
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hash-max-ziplist-entries 512
hash-max-ziplist-value 64</pre>
                            <p class="mt-2">Veri sıkıştırma, özellikle büyük metinler, JSON verileri veya serileştirilmiş 
                            nesneler için kullanışlıdır. Ancak, sıkıştırma/açma işlemi CPU kullanımını artıracağından, 
                            sık sık erişilen veriler için dikkatli kullanılmalıdır.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Redis'te sharding (parçalama) nasıl performansı artırır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis sharding, verileri birden fazla Redis sunucusuna dağıtarak 
                            performansı ve ölçeklenebilirliği artırma tekniğidir. Bu, tek bir Redis sunucusunun 
                            sınırlamalarını aşar.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Daha yüksek okuma/yazma kapasitesi</li>
                                        <li>Daha fazla bellek kapasitesi</li>
                                        <li>Daha iyi ölçeklenebilirlik</li>
                                        <li>Hata toleransı</li>
                                    </ul>
                                </li>
                                <li><strong>Sharding yöntemleri:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Client-side sharding (İstemci tarafı parçalama)</li>
                                        <li>Proxy-based sharding (Proxy tabanlı parçalama)</li>
                                        <li>Redis Cluster</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="mt-2 font-medium">Client-side sharding örneği:</p>
                            <pre class="code-block java mt-2">@Service
public class ShardedRedisService {

    private final List&lt;JedisPool&gt; jedisPools;
    private final Hashing hashing = Hashing.MURMUR_HASH;

    public ShardedRedisService(List&lt;String&gt; redisHosts) {
        this.jedisPools = new ArrayList&lt;&gt;();
        for (String host : redisHosts) {
            String[] parts = host.split(":");
            String hostname = parts[0];
            int port = Integer.parseInt(parts[1]);
            this.jedisPools.add(new JedisPool(hostname, port));
        }
    }

    private Jedis getShard(String key) {
        int shardIndex = Math.abs(hashing.hash(key)) % jedisPools.size();
        return jedisPools.get(shardIndex).getResource();
    }

    public void set(String key, String value) {
        try (Jedis jedis = getShard(key)) {
            jedis.set(key, value);
        }
    }

    public String get(String key) {
        try (Jedis jedis = getShard(key)) {
            return jedis.get(key);
        }
    }

    public void close() {
        for (JedisPool pool : jedisPools) {
            pool.close();
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Spring Data Redis ile sharding:</p>
                            <pre class="code-block java mt-2">@Configuration
public class ShardedRedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        List&lt;RedisNode&gt; shards = new ArrayList&lt;&gt;();
        shards.add(new RedisNode("redis1.example.com", 6379));
        shards.add(new RedisNode("redis2.example.com", 6379));
        shards.add(new RedisNode("redis3.example.com", 6379));
        
        return new LettuceConnectionFactory(shards);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2 font-medium">Redis Cluster yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes</pre>
                            <p class="mt-2">Redis sharding, büyük ölçekli uygulamalarda performansı önemli ölçüde artırır. 
                            Redis Cluster, sharding işlemini otomatik olarak yönetir ve veri dağıtımını, yük 
                            dengelemesini ve hata toleransını sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Redis'te persistans stratejileri performansı nasıl etkiler?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis persistans stratejileri, verilerin bellekten diske nasıl 
                            yazılacağını belirler. Bu stratejiler, performansı ve veri güvenliğini doğrudan etkiler.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>RDB (Redis Database File):</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Belirli zaman aralıklarında veri setlerinin anlık görüntüsünü alır</li>
                                        <li>Daha hızlı başlangıç süresi ve daha küçük dosya boyutu</li>
                                        <li>Son anlık görüntüden sonraki veri kayıpları olabilir</li>
                                        <li>Daha yüksek performans (daha az disk I/O)</li>
                                    </ul>
                                </li>
                                <li><strong>AOF (Append Only File):</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Her yazma işlemini log dosyasına ekler</li>
                                        <li>Daha iyi veri güvenliği (daha az veri kaybı)</li>
                                        <li>Daha büyük dosya boyutu ve daha yavaş başlangıç süresi</li>
                                        <li>Daha düşük performans (daha fazla disk I/O)</li>
                                    </ul>
                                </li>
                                <li><strong>Hibrit persistans:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Hem RDB hem de AOF kullanımı</li>
                                        <li>Hem performans hem de veri güvenliği</li>
                                        <li>Daha fazla disk alanı kullanımı</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="mt-2 font-medium">RDB yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# 15 dakikada en az 1 değişiklik olursa kaydet
save 900 1
# 5 dakikada en az 10 değişiklik olursa kaydet
save 300 10
# 1 dakikada en az 10000 değişiklik olursa kaydet
save 60 10000

# RDB dosyasının adı
dbfilename dump.rdb

# RDB dosyasının dizini
dir /var/lib/redis</pre>
                            <p class="mt-2 font-medium">AOF yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# AOF'yi etkinleştir
appendonly yes

# AOF dosyasının adı
appendfilename "appendonly.aof"

# AOF senkronizasyon stratejisi
# always: Her komuttan sonra diske yaz (en güvenli, en yavaş)
# everysec: Her saniyede diske yaz (dengeli)
# no: İşletim sistemine bırak (en hızlı, en riskli)
appendfsync everysec

# AOF yeniden yazma etkinleştir
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb</pre>
                            <p class="mt-2 font-medium">Hibrit persistans yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Hem RDB hem de AOF etkinleştir
appendonly yes

# AOF yeniden yazma sırasında RDB kullan
aof-use-rdb-preamble yes</pre>
                            <p class="mt-2">Persistans stratejisi seçimi, uygulamanın performans ve veri güvenliği 
                            gereksinimlerine göre yapılmalıdır. Yüksek performanslı okuma/yazma işlemleri için RDB, 
                            veri güvenliğinin kritik olduğu durumlarda AOF tercih edilebilir. Hibrit yaklaşım ise her 
                            ikisini de dengelemek için kullanılır.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Redis'te yüksek erişilebilirlik (high availability) nasıl sağlanır ve performansa etkisi nedir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te yüksek erişilebilirlik, bir Redis sunucusu çöktüğünde 
                            sistemin çalışmaya devam etmesini sağlar. Bu, genellikle replikasyon ve sentinel/cluster 
                            mekanizmaları ile sağlanır.</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Master-Slave Replikasyon:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Bir master sunucu ve birden fazla slave sunucu</li>
                                        <li>Master'daki veriler slave'lere kopyalanır</li>
                                        <li>Okuma işlemleri slave'ler üzerinden dağıtılabilir</li>
                                        <li>Yazma işlemleri sadece master üzerinden yapılır</li>
                                    </ul>
                                </li>
                                <li><strong>Redis Sentinel:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Master sunucuyu izler</li>
                                        <li>Master çöktüğünde otomatik olarak yeni master seçer</li>
                                        <li>İstemcilere doğru master adresini bildirir</li>
                                    </ul>
                                </li>
                                <li><strong>Redis Cluster:</strong>
                                    <ul class="list-circle pl-5 mt-1">
                                        <li>Verileri birden fazla master sunucusuna dağıtır</li>
                                        <li>Otomatik parçalama ve yük dengeleme</li>
                                        <li>Bir sunucu çöktüğünde veri kaybı olmadan çalışmaya devam eder</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="mt-2 font-medium">Master-Slave yapılandırması:</p>
                            <pre class="code-block bash mt-2"># Master redis.conf
bind 192.168.1.100
port 6379

# Slave redis.conf
bind 192.168.1.101
port 6379
slaveof 192.168.1.100 6379</pre>
                            <p class="mt-2 font-medium">Redis Sentinel yapılandırması:</p>
                            <pre class="code-block bash mt-2"># sentinel.conf
port 26379
sentinel monitor mymaster 192.168.1.100 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1</pre>
                            <p class="mt-2 font-medium">Redis Cluster yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf (tüm sunucularda)
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes

# Cluster oluşturma
redis-cli --cluster create 192.168.1.100:6379 192.168.1.101:6379 192.168.1.102:6379 \
192.168.1.103:6379 192.168.1.104:6379 192.168.1.105:6379 \
--cluster-replicas 1</pre>
                            <p class="mt-2 font-medium">Spring Boot ile Redis Sentinel yapılandırması:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisSentinelConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
                .master("mymaster")
                .sentinel("192.168.1.200", 26379)
                .sentinel("192.168.1.201", 26379)
                .sentinel("192.168.1.202", 26379);
        
        sentinelConfig.setPassword("yourpassword");
        
        return new LettuceConnectionFactory(sentinelConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2">Yüksek erişilebilirlik, performansı çeşitli şekillerde etkiler. Master-Slave 
                            replikasyon, okuma performansını artırır ancak yazma performansını değiştirmez. Redis 
                            Cluster ise hem okuma hem de yazma performansını artırır. Ancak, bu yapılandırmalar daha 
                            karmaşık olabilir ve ağ gecikmesini artırabilir.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Redis Cluster Soruları -->
        <section id="redis-cluster" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-network-wired text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Redis Cluster</h2>
                </div>
                <p class="text-gray-600 mb-6">Redis cluster ve yüksek erişilebilirlik ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Redis Cluster nedir ve ne zaman kullanılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster, Redis'in dağıtık ve yüksek erişilebilirlikli bir 
                            sürümüdür. Verileri birden fazla Redis sunucusuna otomatik olarak dağıtır ve bu sunucular 
                            arasında yük dengelemesi sağlar.</p>
                            <p class="mt-2 font-medium">Redis Cluster'ın özellikleri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Verileri 16384 hash slot'a böler</li>
                                <li>Her hash slot bir master sunucuya atanır</li>
                                <li>Master sunucular slave'ler sahip olabilir</li>
                                <li>Otomatik failover (yük devretme) sağlar</li>
                                <li>Otomatik yeniden dengeleme yapar</li>
                                <li>Birden fazla anahtar için atomik işlemler destekler</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis Cluster'ın kullanıldığı durumlar:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Büyük veri setleri (tek bir sunucunun RAM kapasitesini aşan)</li>
                                <li>Yüksek okuma/yazma hacmi (tek bir sunucunun işlem kapasitesini aşan)</li>
                                <li>Yüksek erişilebilirlik gereksinimi (sürekli kullanılabilirlik)</li>
                                <li>Ölçeklenebilirlik gereksinimi (gelecekteki büyüme ihtiyacı)</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis Cluster oluşturma:</p>
                            <pre class="code-block bash mt-2"># 6 sunucu (3 master, 3 slave) ile cluster oluşturma
redis-cli --cluster create 192.168.1.100:6379 192.168.1.101:6379 192.168.1.102:6379 \
192.168.1.103:6379 192.168.1.104:6379 192.168.1.105:6379 \
--cluster-replicas 1</pre>
                            <p class="mt-2">Redis Cluster, büyük ölçekli uygulamalarda performansı ve erişilebilirliği 
                            artırır. Ancak, küçük ölçekli uygulamalarda karmaşıklık ve yönetim maliyeti nedeniyle 
                            uygun olmayabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Redis Cluster'ta veri nasıl dağıtılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster, verileri hash slot'lar aracılığıyla dağıtır. Her 
                            anahtar bir hash slot'a atanır ve bu slot bir master sunucuda bulunur.</p>
                            <p class="mt-2 font-medium">Hash slot mekanizması:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Redis Cluster, 16384 hash slot kullanır (0-16383)</li>
                                <li>Her anahtar için hash slot şu şekilde hesaplanır: <code>slot = CRC16(key) % 16384</code></li>
                                <li>Her master sunucu, belirli bir aralıktaki slot'lardan sorumludur</li>
                                <li>İstemciler, hangi anahtarın hangi sunucuda olduğunu bilir</li>
                            </ul>
                            <p class="mt-2 font-medium">Hash slot dağılımı:</p>
                            <pre class="code-block bash mt-2"># 3 master sunuculu cluster'da slot dağılımı
# Master 1: 0-5460
# Master 2: 5461-10922
# Master 3: 10923-16383</pre>
                            <p class="mt-2 font-medium">Java ile hash slot hesaplama:</p>
                            <pre class="code-block java mt-2">public class RedisClusterUtils {
    
    private static final int SLOT_COUNT = 16384;
    
    public static int calculateSlot(String key) {
        // Hash tag kontrolü ({} içindeki kısım)
        int start = key.indexOf('{');
        if (start != -1) {
            int end = key.indexOf('}', start + 1);
            if (end != -1 && end > start + 1) {
                key = key.substring(start + 1, end);
            }
        }
        
        // CRC16 hesapla
        int crc = CRC16.crc16(key.getBytes());
        return crc % SLOT_COUNT;
    }
}</pre>
                            <p class="mt-2 font-medium">Redis Cluster'ta slot görüntüleme:</p>
                            <pre class="code-block bash mt-2"># Cluster slot bilgilerini görme
redis-cli -c cluster slots

# Belirli bir anahtarın hangi slot'ta olduğunu görme
redis-cli -c cluster keyslot mykey</pre>
                            <p class="mt-2">Bu dağıtım mekanizması, verilerin Redis sunucular arasında dengeli bir şekilde 
                            dağıtılmasını sağlar. Ayrıca, aynı slot'taki anahtarlar için atomik işlemler mümkündür.</p>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Redis Cluster'ta failover (yük devretme) nasıl çalışır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta failover, bir master sunucu çöktüğünde 
                            otomatik olarak slave sunuculardan birinin master rolünü üstlenmesi işlemidir. Bu, 
                            sistemin kesintisiz çalışmaya devam etmesini sağlar.</p>
                            <p class="mt-2 font-medium">Failover mekanizması:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Her master sunucu, slave'ler tarafından düzenli olarak ping'lenir</li>
                                <li>Master sunucuya belirli bir süre içinde ping cevabı gelmezse, master çökmüş sayılır</li>
                                <li>Slave'ler arasında seçim yapılır ve bir slave yeni master olarak atanır</li>
                                <li>Diğer sunucular bu değişikliği kabul eder ve cluster güncellenir</li>
                                <li>İstemciler, yeni master adresini öğrenir ve işlemlerine devam eder</li>
                            </ul>
                            <p class="mt-2 font-medium">Failover yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Master çökmeden önce beklenecek süre (milisaniye)
cluster-node-timeout 5000

# Slave'in master olabilmesi için gereken en az slave sayısı
min-slaves-to-write 1
min-slaves-max-lag 10</pre>
                            <p class="mt-2 font-medium">Failover test etme:</p>
                            <pre class="code-block bash mt-2"># Master sunucuyu durdur
redis-cli -h 192.168.1.100 -p 6379 DEBUG SLEEP 30

# Cluster durumunu kontrol et
redis-cli -c cluster nodes

# Logları kontrol et
tail -f /var/log/redis/redis-server.log</pre>
                            <p class="mt-2 font-medium">Spring Boot ile Redis Cluster failover:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisClusterConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration()
                .clusterNode("192.168.1.100", 6379)
                .clusterNode("192.168.1.101", 6379)
                .clusterNode("192.168.1.102", 6379)
                .clusterNode("192.168.1.103", 6379)
                .clusterNode("192.168.1.104", 6379)
                .clusterNode("192.168.1.105", 6379);
        
        clusterConfig.setPassword("yourpassword");
        clusterConfig.setMaxRedirects(3);
        
        return new LettuceConnectionFactory(clusterConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2">Failover mekanizması, Redis Cluster'ın yüksek erişilebilirlik sağlamasının temel 
                            bir parçasıdır. Doğru yapılandırıldığında, bir sunucu çöktüğünde sistem otomatik olarak 
                            çalışmaya devam eder.</p>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Redis Cluster'ta resharding (yeniden dağıtma) nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta resharding, hash slot'ları sunucular arasında 
                            yeniden dağıtarak cluster'ı dengeleme işlemidir. Bu, yeni sunucu ekleme veya mevcut 
                            sunucuları kaldırma sırasında yapılır.</p>
                            <p class="mt-2 font-medium">Resharding adımları:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>Yeni Redis sunucusunu cluster'a ekle</li>
                                <li>Redis-cli resharding komutunu çalıştır</li>
                                <li>Hangi slot'ların taşınacağını ve nereye taşınacağını belirt</li>
                                <li>Redis, verileri otomatik olarak taşır</li>
                                <li>Taşıma tamamlandığında cluster güncellenir</li>
                            </ol>
                            <p class="mt-2 font-medium">Resharding komutu:</p>
                            <pre class="code-block bash mt-2"># Yeni sunucu ekleme
redis-cli --cluster add-node 192.168.1.106:6379 192.168.1.100:6379

# Resharding yapma
redis-cli --cluster reshard 192.168.1.100:6379

# Komut çıktısı:
# How many slots do you want to move (from 1 to 16384)? 1000
# What is the receiving node ID? [node-id-of-new-server]
# Please enter all the source node IDs.
# Type 'all' to use all the nodes as source nodes, type 'done' once you entered all the source nodes IDs.
# Source node #1: [node-id-of-source-server-1]
# Source node #2: [node-id-of-source-server-2]
# Source node #3: done</pre>
                            <p class="mt-2 font-medium">Otomatik yeniden dengeleme:</p>
                            <pre class="code-block bash mt-2"># Cluster'ı otomatik olarak dengeleme
redis-cli --cluster rebalance 192.168.1.100:6379

# Sadece belirli bir ağırlık eşiğini aşan sunucuları dengeleme
redis-cli --cluster rebalance 192.168.1.100:6379 --threshold 1.0</pre>
                            <p class="mt-2 font-medium">Java ile resharding durumu kontrol etme:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisClusterService {

    @Autowired
    private RedisConnectionFactory connectionFactory;

    public void checkClusterBalance() {
        LettuceConnectionFactory lettuceConnectionFactory = (LettuceConnectionFactory) connectionFactory;
        RedisClusterClient clusterClient = (RedisClusterClient) lettuceConnectionFactory.getNativeClient();
        
        Partitions partitions = clusterClient.getPartitions();
        
        Map&lt;String, Integer&gt; nodeSlotCounts = new HashMap&lt;&gt;();
        
        for (RedisClusterNode node : partitions) {
            int slotCount = node.getSlots().size();
            String nodeId = node.getNodeId();
            nodeSlotCounts.put(nodeId, slotCount);
            
            System.out.println("Node: " + node.getUri() + ", Slots: " + slotCount);
        }
        
        // Dengeyi kontrol et
        Optional&lt;Integer&gt; minSlots = nodeSlotCounts.values().stream().min(Integer::compare);
        Optional&lt;Integer&gt; maxSlots = nodeSlotCounts.values().stream().max(Integer::compare);
        
        if (minSlots.isPresent() && maxSlots.isPresent()) {
            int difference = maxSlots.get() - minSlots.get();
            System.out.println("Slot dağılımı farkı: " + difference);
            
            if (difference > 100) {
                System.out.println("Cluster dengesiz, yeniden dağıtma önerilir.");
            }
        }
    }
}</pre>
                            <p class="mt-2">Resharding, Redis Cluster'ın ölçeklenebilirliğini sağlayan önemli bir özelliktir. 
                            Bu sayede, sistem büyüdükçe yeni sunucular eklenebilir ve yük dengeli bir şekilde dağıtılabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Redis Cluster'ta multi-key işlemlerinin sınırlamaları nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta multi-key işlemleri, anahtarların aynı hash 
                            slot'ta olması durumunda çalışır. Farklı slot'lardaki anahtarlar için multi-key işlemleri 
                            desteklenmez.</p>
                            <p class="mt-2 font-medium">Multi-key işlem sınırlamaları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>MSET, MGET gibi komutlar sadece aynı slot'taki anahtarlar için çalışır</li>
                                <li>Transaction'lar (MULTI/EXEC) sadece aynı slot'taki anahtarlar için çalışır</li>
                                <li>LUA script'leri sadece aynı slot'taki anahtarlar için çalışır</li>
                                <li>Keys komutu tüm cluster'da çalışır ancak önerilmez</li>
                            </ul>
                            <p class="mt-2 font-medium">Hash tag kullanımı:</p>
                            <pre class="code-block bash mt-2"># Aynı slot'ta olması gereken anahtarlar için hash tag kullanımı
# {user:1000}:profile ve {user:1000}:settings aynı slot'ta olacak
SET {user:1000}:profile "profile data"
SET {user:1000}:settings "settings data"

# Multi-key işlemi
MGET {user:1000}:profile {user:1000}:settings</pre>
                            <p class="mt-2 font-medium">Java ile hash tag kullanımı:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisClusterMultiKeyService {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public void saveUserData(String userId, Map&lt;String, String&gt; data) {
        // Hash tag kullanarak aynı slot'ta olacak anahtarlar oluştur
        String profileKey = "{" + userId + "}:profile";
        String settingsKey = "{" + userId + "}:settings";
        
        // Pipeline ile çoklu işlemler
        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                stringRedisConn.set(profileKey, data.get("profile"));
                stringRedisConn.set(settingsKey, data.get("settings"));
                
                return null;
            }
        });
    }

    public Map&lt;String, String&gt; getUserData(String userId) {
        // Hash tag kullanarak aynı slot'taki anahtarları oku
        String profileKey = "{" + userId + "}:profile";
        String settingsKey = "{" + userId + "}:settings";
        
        // Pipeline ile çoklu okuma
        List&lt;Object&gt; results = redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;
                
                stringRedisConn.get(profileKey);
                stringRedisConn.get(settingsKey);
                
                return null;
            }
        });
        
        Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
        if (results.size() >= 2) {
            data.put("profile", results.get(0) != null ? results.get(0).toString() : null);
            data.put("settings", results.get(1) != null ? results.get(1).toString() : null);
        }
        
        return data;
    }
}</pre>
                            <p class="mt-2 font-medium">Cluster'da desteklenen komutlar:</p>
                            <pre class="code-block bash mt-2"># Desteklenen komutlar (aynı slot'taki anahtarlar için)
DEL key1 key2
MGET key1 key2
MSET key1 value1 key2 value2
SUNION key1 key2
SINTER key1 key2
SDIFF key1 key2</pre>
                            <p class="mt-2">Bu sınırlamalar, Redis Cluster'ın dağıtık doğasından kaynaklanır. İlgili 
                            verileri aynı slot'ta tutmak için hash tag kullanımı, bu sınırlamaları aşmak için bir 
                            çözüm sunar.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Redis Cluster ile Redis Sentinel arasındaki farklar nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster ve Redis Sentinel, yüksek erişilebilirlik sağlamak 
                            için kullanılan iki farklı çözümdür. Ancak, mimari ve özellik olarak farklılıklar gösterirler.</p>
                            <p class="mt-2 font-medium">Temel farklar:</p>
                            <table class="min-w-full bg-white border border-gray-200 mt-2">
                                <thead>
                                    <tr>
                                        <th class="py-2 px-4 border-b">Özellik</th>
                                        <th class="py-2 px-4 border-b">Redis Sentinel</th>
                                        <th class="py-2 px-4 border-b">Redis Cluster</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Mimari</td>
                                        <td class="py-2 px-4 border-b">Master-Slave replikasyon</td>
                                        <td class="py-2 px-4 border-b">Sharding (parçalama)</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Veri dağıtımı</td>
                                        <td class="py-2 px-4 border-b">Tüm veri master'da, slave'ler kopya</td>
                                        <td class="py-2 px-4 border-b">Veri sunucular arasında dağıtık</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Ölçeklenebilirlik</td>
                                        <td class="py-2 px-4 border-b">Okuma ölçeklenebilir, yazma tek master</td>
                                        <td class="py-2 px-4 border-b">Hem okuma hem yazma ölçeklenebilir</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Maksimum bellek</td>
                                        <td class="py-2 px-4 border-b">Tek sunucunun RAM kapasitesi</td>
                                        <td class="py-2 px-4 border-b">Tüm sunucuların toplam RAM kapasitesi</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Multi-key işlemler</td>
                                        <td class="py-2 px-4 border-b">Tüm anahtarlar için desteklenir</td>
                                        <td class="py-2 px-4 border-b">Sadece aynı slot'taki anahtarlar için</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">Yönetim karmaşıklığı</td>
                                        <td class="py-2 px-4 border-b">Daha az karmaşık</td>
                                        <td class="py-2 px-4 border-b">Daha karmaşık</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="mt-2 font-medium">Redis Sentinel yapılandırması:</p>
                            <pre class="code-block bash mt-2"># sentinel.conf
port 26379
sentinel monitor mymaster 192.168.1.100 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1</pre>
                            <p class="mt-2 font-medium">Redis Cluster yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes</pre>
                            <p class="mt-2 font-medium">Spring Boot ile Redis Sentinel:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisSentinelConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
                .master("mymaster")
                .sentinel("192.168.1.200", 26379)
                .sentinel("192.168.1.201", 26379)
                .sentinel("192.168.1.202", 26379);
        
        return new LettuceConnectionFactory(sentinelConfig);
    }
}</pre>
                            <p class="mt-2 font-medium">Spring Boot ile Redis Cluster:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisClusterConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration()
                .clusterNode("192.168.1.100", 6379)
                .clusterNode("192.168.1.101", 6379)
                .clusterNode("192.168.1.102", 6379);
        
        return new LettuceConnectionFactory(clusterConfig);
    }
}</pre>
                            <p class="mt-2">Redis Sentinel, daha basit bir yüksek erişilebilirlik çözümü sunarken, Redis 
                            Cluster daha karmaşık ancak daha yüksek ölçeklenebilirlik ve performans sağlar. Uygulamanın 
                            gereksinimlerine göre doğru çözüm seçilmelidir.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Redis Cluster'ta istemci (client) nasıl çalışır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster istemcileri, cluster topolojisini anlayan ve 
                            komutları doğru sunucuya yönlendiren özel istemcilerdir. İstemciler, hangi anahtarın 
                            hangi sunucuda olduğunu bilmeli ve yönlendirmeleri doğru şekilde yapmalıdır.</p>
                            <p class="mt-2 font-medium">Redis Cluster istemcisinin özellikleri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Cluster topolojisini öğrenir ve günceller</li>
                                <li>Hash slot dağılımını bilir</li>
                                <li>Komutları doğru sunucuya yönlendirir</li>
                                <li>Yönlendirmeleri (redirects) otomatik olarak işler</li>
                                <li>Bağlantı havuzunu yönetir</li>
                                <li>Hata durumunda yeniden dener</li>
                            </ul>
                            <p class="mt-2 font-medium">İstemci çalışma mantığı:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>İstemci, cluster topolojisini öğrenir (hangi sunucunun hangi slot'lardan sorumlu olduğu)</li>
                                <li>Komut geldiğinde, anahtarın hash slot'unu hesaplar</li>
                                <li>Komutu doğru sunucuya gönderir</li>
                                <li>Eğer sunucuMOVED hatası dönerse, istemci topolojiyi günceller ve komutu yeniden gönderir</li>
                                <li>Eğer sunucuASK hatası dönerse, istemci komutu belirtilen sunucuya gönderir</li>
                            </ol>
                            <p class="mt-2 font-medium">Java ile Redis Cluster istemcisi:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisClusterConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration()
                .clusterNode("192.168.1.100", 6379)
                .clusterNode("192.168.1.101", 6379)
                .clusterNode("192.168.1.102", 6379);
        
        clusterConfig.setPassword("yourpassword");
        clusterConfig.setMaxRedirects(3);
        
        return new LettuceConnectionFactory(clusterConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2 font-medium">Özel Redis Cluster istemcisi:</p>
                            <pre class="code-block java mt-2">@Service
public class CustomRedisClusterClient {

    private final Map&lt;RedisURI, RedisConnection&gt; connections = new ConcurrentHashMap&lt;&gt;();
    private final Map&lt;Integer, RedisURI&gt; slotMap = new ConcurrentHashMap&lt;&gt;();
    
    @PostConstruct
    public void init() {
        // Cluster sunucularını ekle
        addClusterNode(RedisURI.create("redis://192.168.1.100:6379"));
        addClusterNode(RedisURI.create("redis://192.168.1.101:6379"));
        addClusterNode(RedisURI.create("redis://192.168.1.102:6379"));
        
        // Cluster topolojisini öğren
        updateClusterTopology();
    }
    
    private void addClusterNode(RedisURI uri) {
        RedisConnection connection = RedisConnection.connect(uri);
        connections.put(uri, connection);
    }
    
    private void updateClusterTopology() {
        for (Map.Entry&lt;RedisURI, RedisConnection&gt; entry : connections.entrySet()) {
            RedisConnection connection = entry.getValue();
            
            // CLUSTER SLOTS komutunu çalıştır
            RedisClusterSlots clusterSlots = connection.clusterSlots();
            
            for (RedisClusterSlots.NodeSlotRange range : clusterSlots) {
                for (RedisClusterSlots.Node node : range.getNodes()) {
                    if (node.is(RedisClusterSlots.Node.Flag.MASTER)) {
                        // Slot aralığını ve master sunucuyu eşleştir
                        for (int slot = range.getStart(); slot <= range.getEnd(); slot++) {
                            slotMap.put(slot, node.getUri());
                        }
                    }
                }
            }
        }
    }
    
    public String get(String key) {
        int slot = calculateSlot(key);
        RedisURI uri = slotMap.get(slot);
        
        RedisConnection connection = connections.get(uri);
        return connection.sync().get(key);
    }
    
    public void set(String key, String value) {
        int slot = calculateSlot(key);
        RedisURI uri = slotMap.get(slot);
        
        RedisConnection connection = connections.get(uri);
        connection.sync().set(key, value);
    }
    
    private int calculateSlot(String key) {
        // Hash tag kontrolü
        int start = key.indexOf('{');
        if (start != -1) {
            int end = key.indexOf('}', start + 1);
            if (end != -1 && end > start + 1) {
                key = key.substring(start + 1, end);
            }
        }
        
        // CRC16 hesapla
        int crc = CRC16.crc16(key.getBytes());
        return crc % 16384;
    }
}</pre>
                            <p class="mt-2">Redis Cluster istemcileri, cluster'ın dağıtık doğasını yönetmek için önemlidir. 
                            Doğru istemci seçimi ve yapılandırması, uygulamanın performansını ve güvenilirliğini 
                            önemli ölçüde etkiler.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Redis Cluster'ta veri kaybı nasıl önlenir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta veri kaybını önlemek için çeşitli stratejiler ve 
                            yapılandırmalar kullanılır. Bu stratejiler, veri güvenliğini artırır ve sunucu arızalarında 
                            veri kaybını en aza indirir.</p>
                            <p class="mt-2 font-medium">Veri kaybını önleme stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Replication (Replikasyon):</strong> Her master sunucu için en az bir slave 
                                sunucu kullanmak</li>
                                <li><strong>AOF persistansı:</strong> Her yazma işlemini log dosyasına kaydetmek</li>
                                <li><strong>Wait komutu:</strong> Yazma işlemlerinin slave'lere kopyalandığını doğrulamak</li>
                                <li><strong>Cluster node timeout ayarı:</strong> Sunucu çöküşünü doğru tespit etmek</li>
                                <li><strong>Min-slaves-to-write:</strong> Yazma için minimum slave sayısı belirlemek</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# AOF'yi etkinleştir
appendonly yes

# AOF senkronizasyon stratejisi
appendfsync everysec

# Yazma için minimum slave sayısı
min-slaves-to-write 1
min-slaves-max-lag 10

# Cluster node timeout
cluster-node-timeout 5000

# Cluster slave geçikme faktörü
cluster-slave-validity-factor 10</pre>
                            <p class="mt-2 font-medium">WAIT komutu kullanımı:</p>
                            <pre class="code-block bash mt-2"># Yazma işlemini slave'lere kopyala ve bekle
SET mykey myvalue
WAIT 1 5000  # 1 slave'e kopyalanana kadar bekle, maksimum 5 saniye</pre>
                            <p class="mt-2 font-medium">Java ile WAIT komutu:</p>
                            <pre class="code-block java mt-2">@Service
public class SafeRedisClusterService {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public void safeSet(String key, String value) {
        // Veriyi kaydet
        redisTemplate.opsForValue().set(key, value);
        
        // Slave'lere kopyalandığını doğrula
        RedisClusterConnection clusterConnection = (RedisClusterConnection) redisTemplate.getConnectionFactory().getConnection();
        Long result = clusterConnection.wait(ReplicationRequirement.of(1), Duration.ofSeconds(5));
        
        if (result == null || result < 1) {
            // Slave'lere kopyalanamadı, logla veya uyar
            System.err.println("Uyarı: Veri slave'lere kopyalanamadı: " + key);
        }
    }
}</pre>
                            <p class="mt-2 font-medium">AOF yeniden yazma ve optimizasyon:</p>
                            <pre class="code-block bash mt-2"># AOF dosyasını manuel olarak yeniden yaz
BGREWRITEAOF

# AOF dosyasını kontrol et
redis-cli --latency -s /var/lib/redis/appendonly.aof</pre>
                            <p class="mt-2">Redis Cluster'ta veri kaybını önlemek, özellikle finansal veya kritik veriler 
                            için önemlidir. Bu stratejiler, veri bütünlüğünü ve güvenliğini sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Redis Cluster'ta monitoring ve bakım nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta monitoring ve bakım, cluster'ın sağlık durumunu 
                            izlemek, performansı optimize etmek ve sorunları çözmek için önemlidir. Bu işlem için 
                            çeşitli komutlar ve araçlar kullanılır.</p>
                            <p class="mt-2 font-medium">Monitoring komutları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>CLUSTER INFO:</strong> Cluster genel bilgilerini gösterir</li>
                                <li><strong>CLUSTER NODES:</strong> Cluster'daki tüm sunucuları ve durumlarını gösterir</li>
                                <li><strong>CLUSTER SLOTS:</strong> Slot dağılımını gösterir</li>
                                <li><strong>INFO:</strong> Sunucu istatistiklerini gösterir</li>
                                <li><strong>INFO REPLICATION:</strong> Replikasyon bilgilerini gösterir</li>
                            </ul>
                            <p class="mt-2 font-medium">Monitoring komut örnekleri:</p>
                            <pre class="code-block bash mt-2"># Cluster genel bilgilerini görme
redis-cli -c cluster info

# Cluster sunucularını görme
redis-cli -c cluster nodes

# Slot dağılımını görme
redis-cli -c cluster slots

# Sunucu istatistiklerini görme
redis-cli -c info

# Replikasyon bilgilerini görme
redis-cli -c info replication</pre>
                            <p class="mt-2 font-medium">Java ile monitoring:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisClusterMonitoringService {

    @Autowired
    private RedisConnectionFactory connectionFactory;

    public Map&lt;String, Object&gt; getClusterInfo() {
        RedisClusterConnection clusterConnection = (RedisClusterConnection) connectionFactory.getConnection();
        
        Map&lt;String, Object&gt; clusterInfo = new HashMap&lt;&gt;();
        
        // Cluster genel bilgileri
        Properties clusterProperties = clusterConnection.clusterGetClusterInfo();
        clusterInfo.put("clusterInfo", clusterProperties);
        
        // Cluster sunucuları
        Iterable&lt;RedisClusterNode&gt; clusterNodes = clusterConnection.clusterGetNodes();
        List&lt;Map&lt;String, Object&gt;&gt; nodes = new ArrayList&lt;&gt;();
        
        for (RedisClusterNode node : clusterNodes) {
            Map&lt;String, Object&gt; nodeInfo = new HashMap&lt;&gt;();
            nodeInfo.put("id", node.getNodeId());
            nodeInfo.put("host", node.getHost());
            nodeInfo.put("port", node.getPort());
            nodeInfo.put("master", node.is(RedisClusterNode.Node.Flag.MASTER));
            nodeInfo.put("slave", node.is(RedisClusterNode.Node.Flag.SLAVE));
            nodeInfo.put("slots", node.getSlots());
            
            nodes.add(nodeInfo);
        }
        
        clusterInfo.put("nodes", nodes);
        
        return clusterInfo;
    }

    public Map&lt;String, Object&gt; getServerStats() {
        RedisClusterConnection clusterConnection = (RedisClusterConnection) connectionFactory.getConnection();
        
        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();
        
        // Her sunucu için istatistikleri topla
        Iterable&lt;RedisClusterNode&gt; clusterNodes = clusterConnection.clusterGetNodes();
        
        for (RedisClusterNode node : clusterNodes) {
            Properties serverProperties = clusterConnection.serverCommands().info(node);
            stats.put(node.getHost() + ":" + node.getPort(), serverProperties);
        }
        
        return stats;
    }
}</pre>
                            <p class="mt-2 font-medium">Prometheus ile monitoring:</p>
                            <pre class="code-block yaml mt-2"># prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'redis-cluster'
    static_configs:
      - targets: 
        - 'redis1:9121'
        - 'redis2:9121'
        - 'redis3:9121'</pre>
                            <p class="mt-2 font-medium">Redis Cluster bakım görevleri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Düzenli olarak cluster durumunu kontrol etme</li>
                                <li>Slot dağılımını dengeleme</li>
                                <li>AOF dosyalarını optimize etme</li>
                                <li>Logları izleme ve analiz etme</li>
                                <li>Yedekleme ve kurtarma stratejileri oluşturma</li>
                                <li>Güvenlik güncellemelerini uygulama</li>
                            </ul>
                            <p class="mt-2">Redis Cluster monitoring ve bakımı, cluster'ın sağlıklı ve performanslı 
                            çalışmasını sağlar. Düzenli monitoring, sorunları önceden tespit etmeye yardımcı olur.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Redis Cluster'ta ölçeklendirme stratejileri nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis Cluster'ta ölçeklendirme, sistemin büyüyen ihtiyaçlara 
                            uyum sağlaması için önemlidir. Doğru ölçeklendirme stratejileri, performansı ve 
                            erişilebilirliği artırır.</p>
                            <p class="mt-2 font-medium">Ölçeklendirme stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Horizontal scaling (Yatay ölçeklendirme):</strong> Yeni sunucular ekleyerek 
                                kapasiteyi artırma</li>
                                <li><strong>Vertical scaling (Dikey ölçeklendirme):</strong> Mevcut sunucuların kaynaklarını 
                                (CPU, RAM, Disk) artırma</li>
                                <li><strong>Read scaling (Okuma ölçeklendirme):</strong> Slave sunucular ekleyerek okuma 
                                kapasitesini artırma</li>
                                <li><strong>Shard optimization (Parça optimizasyonu):</strong> Veri dağılımını optimize etme</li>
                            </ul>
                            <p class="mt-2 font-medium">Yatay ölçeklendirme adımları:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>Yeni Redis sunucularını ekle</li>
                                <li>Cluster'a yeni sunucuları ekle</li>
                                <li>Slot'ları yeniden dağıt (resharding)</li>
                                <li>Yeni sunucular için slave'ler ekle</li>
                                <li>Uygulama istemcilerini güncelle</li>
                            </ol>
                            <p class="mt-2 font-medium">Yeni sunucu ekleme komutları:</p>
                            <pre class="code-block bash mt-2"># Yeni sunucuyu cluster'a ekle
redis-cli --cluster add-node 192.168.1.106:6379 192.168.1.100:6379

# Slot'ları yeniden dağıt
redis-cli --cluster reshard 192.168.1.100:6379

# Cluster'ı dengele
redis-cli --cluster rebalance 192.168.1.100:6379</pre>
                            <p class="mt-2 font-medium">Java ile otomatik ölçeklendirme:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisClusterScalingService {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    @Scheduled(fixedRate = 60000)  // Her dakika çalıştır
    public void checkAndScaleCluster() {
        RedisClusterConnection clusterConnection = (RedisClusterConnection) connectionFactory.getConnection();
        
        // Cluster durumunu kontrol et
        Properties clusterProperties = clusterConnection.clusterGetClusterInfo();
        String clusterState = clusterProperties.getProperty("cluster_state");
        
        if (!"ok".equals(clusterState)) {
            // Cluster'da sorun var, ölçeklendirme yapma
            return;
        }
        
        // Bellek kullanımını kontrol et
        Iterable&lt;RedisClusterNode&gt; clusterNodes = clusterConnection.clusterGetNodes();
        
        for (RedisClusterNode node : clusterNodes) {
            if (node.is(RedisClusterNode.Node.Flag.MASTER)) {
                Properties serverProperties = clusterConnection.serverCommands().info(node, "memory");
                String usedMemory = serverProperties.getProperty("used_memory");
                String maxMemory = serverProperties.getProperty("maxmemory");
                
                if (usedMemory != null && maxMemory != null) {
                    double used = Double.parseDouble(usedMemory);
                    double max = Double.parseDouble(maxMemory);
                    double usagePercentage = (used / max) * 100;
                    
                    if (usagePercentage > 80) {
                        // Bellek kullanımı %80'den fazla, ölçeklendirme öner
                        System.out.println("Ölçeklendirme önerisi: " + node.getHost() + ":" + node.getPort() + 
                                          " bellek kullanımı %" + usagePercentage);
                        
                        // Yeni sunucu ekleme işlemi başlat
                        scaleUpCluster();
                    }
                }
            }
        }
    }
    
    private void scaleUpCluster() {
        // Yeni sunucu ekleme işlemleri
        // Bu kısım, otomasyon betikleri veya manuel müdahale ile yapılabilir
        System.out.println("Cluster ölçeklendirme başlatılıyor...");
    }
}</pre>
                            <p class="mt-2 font-medium">Bulut ortamlarında otomatik ölçeklendirme:</p>
                            <pre class="code-block yaml mt-2"># Kubernetes HorizontalPodAutoscaler örneği
apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: redis-cluster-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: StatefulSet
    name: redis-cluster
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80</pre>
                            <p class="mt-2">Redis Cluster ölçeklendirme, sistemin büyüyen ihtiyaçlara uyum sağlamasını 
                            sağlar. Doğru stratejiler ve otomasyon ile, cluster performansı ve erişilebilirliği 
                            yüksek tutulabilir.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Redis Güvenlik Soruları -->
        <section id="redis-guvenlik" class="mb-16">
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex items-center mb-6">
                    <div class="bg-red-100 p-3 rounded-full mr-4">
                        <i class="fas fa-shield-alt text-red-600 text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">Redis Güvenlik</h2>
                </div>
                <p class="text-gray-600 mb-6">Redis güvenlik ve en iyi uygulamalar ile ilgili mülakat soruları.</p>

                <div class="space-y-6">
                    <!-- Soru 1 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 1: Redis'te temel güvenlik önlemleri nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis, varsayılan olarak güvenlik önlemleri olmayan bir 
                            veritabanıdır, bu nedenle güvenlik için ek yapılandırmalar yapmak gerekir. Temel güvenlik 
                            önlemleri şunlardır:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Parola koruması:</strong> Redis sunucusuna erişim için parola belirlemek</li>
                                <li><strong>Ağ güvenliği:</strong> Güvenlik duvarı ve ağ erişim kontrolleri</li>
                                <li><strong>Komut yeniden adlandırma:</strong> Tehlikeli komutları yeniden adlandırmak veya devre dışı bırakmak</li>
                                <li><strong>SSL/TLS şifreleme:</strong> İstemci-sunucu arasındaki iletişimi şifrelemek</li>
                                <li><strong>Veri şifreleme:</strong> Hassas verileri şifreleyerek saklamak</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis güvenlik yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Parola koruması
requirepass your-strong-password

# Tehlikeli komutları yeniden adlandırma veya devre dışı bırakma
rename-command CONFIG ""
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command SHUTDOWN ""

# Yalnızca belirli IP adreslerinden bağlantıya izin verme
bind 127.0.0.1 192.168.1.100

# Korumalı mod (yalnızca yerel bağlantılar)
protected-mode yes</pre>
                            <p class="mt-2 font-medium">Redis sunucusuna bağlanırken parola kullanımı:</p>
                            <pre class="code-block bash mt-2"># Parola ile bağlanma
redis-cli -h your-redis-host -p 6379 -a your-password

# veya
redis-cli -h your-redis-host -p 6379
AUTH your-password</pre>
                            <p class="mt-2 font-medium">Spring Boot ile güvenli Redis bağlantısı:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisSecurityConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("your-redis-host");
        redisConfig.setPort(6379);
        redisConfig.setPassword("your-password");
        
        return new LettuceConnectionFactory(redisConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2">Bu temel güvenlik önlemleri, Redis sunucusunu yetkisiz erişimlere karşı korur ve 
                            veri güvenliğini artırır.</p>
                        </div>
                    </div>

                    <!-- Soru 2 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 2: Redis'te SSL/TLS şifreleme nasıl yapılandırılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te SSL/TLS şifreleme, istemci ve sunucu arasındaki 
                            iletişimin şifrelenmesini sağlar. Bu, özellikle internet üzerinden veya güvenli olmayan 
                            ağlarda veri güvenliği için önemlidir.</p>
                            <p class="mt-2 font-medium">SSL/TLS yapılandırma adımları:</p>
                            <ol class="list-decimal pl-5 mt-2">
                                <li>Sertifika yetkilisi (CA) veya otomatik olarak imzalanan sertifikalar oluştur</li>
                                <li>Redis sunucusunu SSL/TLS için yapılandır</li>
                                <li>İstemcileri SSL/TLS kullanacak şekilde yapılandır</li>
                            </ol>
                            <p class="mt-2 font-medium">Sertifika oluşturma:</p>
                            <pre class="code-block bash mt-2"># CA ve sunucu sertifikası oluşturma
openssl genrsa -out ca.key 2048
openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -subj "/CN=RedisCA"

# Sunucu anahtarı ve CSR oluşturma
openssl genrsa -out redis-server.key 2048
openssl req -new -key redis-server.key -out redis-server.csr -subj "/CN=redis-server"

# Sunucu sertifikasını imzalama
openssl x509 -req -days 3650 -in redis-server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out redis-server.crt

# İstemci sertifikası oluşturma
openssl genrsa -out redis-client.key 2048
openssl req -new -key redis-client.key -out redis-client.csr -subj "/CN=redis-client"
openssl x509 -req -days 3650 -in redis-client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out redis-client.crt</pre>
                            <p class="mt-2 font-medium">Redis sunucusu SSL yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# TLS/SSL etkinleştirme
tls-cert-file /etc/redis/redis-server.crt
tls-key-file /etc/redis/redis-server.key
tls-ca-cert-file /etc/redis/ca.crt

# İstemci sertifikası doğrulama
tls-auth-clients yes
tls-replication yes
tls-cluster yes

# TLS portu kullanma
port 0
tls-port 6379</pre>
                            <p class="mt-2 font-medium">Spring Boot ile SSL/TLS yapılandırması:</p>
                            <pre class="code-block java mt-2">@Configuration
public class RedisSSLConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() throws Exception {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("your-redis-host");
        redisConfig.setPort(6379);
        redisConfig.setPassword("your-password");
        
        // SSL yapılandırması
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .useSsl()
                .and()
                .clientOptions(ClientOptions.builder()
                        .sslOptions(SslOptions.builder()
                                .jdkSslProvider()
                                .truststore(new ClassPathResource("ca.jks"), "password")
                                .keystore(new ClassPathResource("redis-client.jks"), "password")
                                .build())
                        .build())
                .build();
        
        return new LettuceConnectionFactory(redisConfig, clientConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}</pre>
                            <p class="mt-2">SSL/TLS şifreleme, verilerin ağda taşınırken güvenliğini sağlar. Özellikle 
                            bulut ortamlarında veya internet üzerinden Redis erişimi gerektiğinde önemlidir.</p>
                        </div>
                    </div>

                    <!-- Soru 3 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 3: Redis'te erişim kontrolü nasıl sağlanır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te erişim kontrolü, belirli kullanıcıların veya 
                            uygulamaların belirli komutları veya verileri çalıştırmasını kısıtlamak için kullanılır. 
                            Redis, rol tabanlı erişim kontrolü (RBAC) ve komut seviyesinde erişim kontrolü 
                            imkanları sunar.</p>
                            <p class="mt-2 font-medium">Redis ACL (Access Control List) özellikleri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li>Kullanıcı adı ve parola ile kimlik doğrulama</li>
                                <li>Rol tabanlı yetkilendirme</li>
                                <li>Komut seviyesinde erişim kontrolü</li>
                                <li>Anahtar (key) seviyesinde erişim kontrolü</li>
                                <li>Kanal (channel) seviyesinde erişim kontrolü</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis ACL komutları:</p>
                            <pre class="code-block bash mt-2"># Kullanıcı oluşturma
ACL SETUSER user1 on >password ~* &* -@dangerous +@read

# Kullanıcı listeleme
ACL LIST

# Kullanıcı bilgilerini görme
ACL GETUSER user1

# Rol oluşturma
ACL SETROLE readonly +@read -@write

# Kullanıcıya rol atama
ACL SETUSER user1 >password +@readonly

# Komut izinlerini düzenleme
ACL SETUSER user1 +@string -@list</pre>
                            <p class="mt-2 font-medium">Java ile Redis ACL kullanımı:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisACLService {

    @Autowired
    private RedisConnectionFactory connectionFactory;

    public void createUserWithACL(String username, String password, List&lt;String&gt; allowedCommands) {
        RedisConnection connection = connectionFactory.getConnection();
        
        // ACL komutunu oluştur
        StringBuilder aclCommand = new StringBuilder("ACL SETUSER ")
                .append(username)
                .append(" on >")
                .append(password);
        
        // İzin verilen komutları ekle
        for (String command : allowedCommands) {
            aclCommand.append(" +").append(command);
        }
        
        // Tehlikeli komutları engelle
        aclCommand.append(" -@dangerous");
        
        // Komutu çalıştır
        connection.execute(aclCommand.toString());
    }

    public Map&lt;String, Object&gt; getUserACL(String username) {
        RedisConnection connection = connectionFactory.getConnection();
        
        // Kullanıcı ACL bilgilerini al
        byte[] aclInfo = connection.execute("ACL GETUSER " + username);
        
        // Sonucu işle
        Map&lt;String, Object&gt; aclMap = new HashMap&lt;&gt;();
        if (aclInfo != null) {
            String aclString = new String(aclInfo);
            // ACL bilgilerini ayrıştır
            // ...
        }
        
        return aclMap;
    }
}</pre>
                            <p class="mt-2 font-medium">Spring Security ile Redis entegrasyonu:</p>
                            <pre class="code-block java mt-2">@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
            .and()
            .logout()
                .permitAll();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        return new RedisUserDetailsService(redisTemplate);
    }
}

public class RedisUserDetailsService implements UserDetailsService {

    private final RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUserDetailsService(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Redis'ten kullanıcı bilgilerini al
        String userKey = "user:" + username;
        Map&lt;Object, Object&gt; userData = redisTemplate.opsForHash().entries(userKey);
        
        if (userData.isEmpty()) {
            throw new UsernameNotFoundException("Kullanıcı bulunamadı: " + username);
        }
        
        String password = (String) userData.get("password");
        Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
        
        return new User(username, password, authorities);
    }
}</pre>
                            <p class="mt-2">Redis ACL, özellikle çok kullanıcılı ortamlarda ve farklı uygulamaların aynı 
                            Redis örneğini paylaştığı durumlarda önemlidir. Bu, yetkisiz erişimleri önler ve 
                            veri güvenliğini artırır.</p>
                        </div>
                    </div>

                    <!-- Soru 4 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 4: Redis'te veri şifreleme nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te veri şifreleme, hassas verilerin güvenli bir şekilde 
                            saklanması için kullanılır. Bu, özellikle kişisel bilgiler, finansal veriler veya diğer 
                            hassas bilgiler için önemlidir.</p>
                            <p class="mt-2 font-medium">Veri şifreleme stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Uygulama katmanında şifreleme:</strong> Veriler Redis'e kaydedilmeden önce şifrelenir</li>
                                <li><strong>Redis modülleri ile şifreleme:</strong> Redis'e şifreleme modülleri eklemek</li>
                                <li><strong>Şifrelenmiş Redis (Redis-Ecrypt):</strong> Şifreleme özellikli Redis sürümleri kullanmak</li>
                            </ul>
                            <p class="mt-2 font-medium">Java ile veri şifreleme:</p>
                            <pre class="code-block java mt-2">@Service
public class EncryptedRedisService {

    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    
    private final SecretKey secretKey;
    private final Cipher cipher;
    
    public EncryptedRedisService() throws Exception {
        // Anahtar oluştur (gerçek uygulamada güvenli bir şekilde saklanmalı)
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(256);
        secretKey = keyGenerator.generateKey();
        
        cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    }
    
    public void saveEncryptedData(String key, String value) {
        try {
            // Veriyi şifrele
            byte[] encryptedValue = encrypt(value);
            
            // Base64 ile kodla ve Redis'e kaydet
            String encodedValue = Base64.getEncoder().encodeToString(encryptedValue);
            redisTemplate.opsForValue().set(key, encodedValue);
        } catch (Exception e) {
            throw new RuntimeException("Şifreleme hatası", e);
        }
    }
    
    public String getEncryptedData(String key) {
        try {
            // Redis'ten şifrelenmiş veriyi al
            String encodedValue = redisTemplate.opsForValue().get(key);
            
            if (encodedValue == null) {
                return null;
            }
            
            // Base64'den çöz ve şifreyi çöz
            byte[] encryptedValue = Base64.getDecoder().decode(encodedValue);
            return decrypt(encryptedValue);
        } catch (Exception e) {
            throw new RuntimeException("Şifre çözme hatası", e);
        }
    }
    
    private byte[] encrypt(String value) throws Exception {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));
        
        byte[] encrypted = cipher.doFinal(value.getBytes());
        
        // IV ve şifrelenmiş veriyi birleştir
        byte[] combined = new byte[iv.length + encrypted.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
        
        return combined;
    }
    
    private String decrypt(byte[] encryptedValue) throws Exception {
        // IV ve şifrelenmiş veriyi ayır
        byte[] iv = new byte[16];
        System.arraycopy(encryptedValue, 0, iv, 0, iv.length);
        
        byte[] encrypted = new byte[encryptedValue.length - 16];
        System.arraycopy(encryptedValue, 16, encrypted, 0, encrypted.length);
        
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        
        byte[] decrypted = cipher.doFinal(encrypted);
        return new String(decrypted);
    }
}</pre>
                            <p class="mt-2 font-medium">Spring Security ile veri şifreleme:</p>
                            <pre class="code-block java mt-2">@Service
public class SecureUserService {

    @Autowired
    private EncryptedRedisService encryptedRedisService;
    
    public void saveUser(User user) {
        // Hassas verileri şifrele
        String encryptedSSN = encryptSSN(user.getSsn());
        String encryptedCreditCard = encryptCreditCard(user.getCreditCard());
        
        // Şifrelenmiş verileri Redis'e kaydet
        encryptedRedisService.saveEncryptedData("user:" + user.getId() + ":ssn", encryptedSSN);
        encryptedRedisService.saveEncryptedData("user:" + user.getId() + ":creditCard", encryptedCreditCard);
        
        // Diğer kullanıcı bilgilerini kaydet
        // ...
    }
    
    public User getUser(Long userId) {
        // Kullanıcı bilgilerini Redis'ten al
        String encryptedSSN = encryptedRedisService.getEncryptedData("user:" + userId + ":ssn");
        String encryptedCreditCard = encryptedRedisService.getEncryptedData("user:" + userId + ":creditCard");
        
        // Şifrelenmiş verileri çöz
        String ssn = decryptSSN(encryptedSSN);
        String creditCard = decryptCreditCard(encryptedCreditCard);
        
        // Kullanıcı nesnesini oluştur ve döndür
        User user = new User();
        user.setId(userId);
        user.setSsn(ssn);
        user.setCreditCard(creditCard);
        
        return user;
    }
    
    private String encryptSSN(String ssn) {
        // SSN şifreleme mantığı
        return ssn; // Basitleştirilmiş
    }
    
    private String decryptSSN(String encryptedSSN) {
        // SSN şifre çözme mantığı
        return encryptedSSN; // Basitleştirilmiş
    }
    
    private String encryptCreditCard(String creditCard) {
        // Kredi kartı şifreleme mantığı
        return creditCard; // Basitleştirilmiş
    }
    
    private String decryptCreditCard(String encryptedCreditCard) {
        // Kredi kartı şifre çözme mantığı
        return encryptedCreditCard; // Basitleştirilmiş
    }
}</pre>
                            <p class="mt-2">Veri şifreleme, özellikle düzenlemelere uyum sağlamak (GDPR, PCI DSS vb.) ve 
                            hassas verileri korumak için önemlidir. Doğru şifreleme stratejileri ve anahtar yönetimi 
                            ile veri güvenliği artırılabilir.</p>
                        </div>
                    </div>

                    <!-- Soru 5 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 5: Redis'te güvenlik denetimi ve loglama nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te güvenlik denetimi ve loglama, güvenlik olaylarını izlemek, 
                            yetkisiz erişimleri tespit etmek ve güvenlik ihlallerini analiz etmek için önemlidir. Bu, 
                            Redis güvenliğini proaktif olarak yönetmeye yardımcı olur.</p>
                            <p class="mt-2 font-medium">Güvenlik denetimi ve loglama stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Komut loglama:</strong> Tüm Redis komutlarını loglama</li>
                                <li><strong>Erişim loglama:</strong> Bağlantı ve kimlik doğrulama logları</li>
                                <li><strong>Güvenlik olayları:</strong> Başarısız giriş denemeleri, yetkisiz erişimler</li>
                                <li><strong>Audit trail:</strong> Veri değişikliklerinin kaydedilmesi</li>
                                <li><strong>SIEM entegrasyonu:</strong> Güvenlik bilgilerini SIEM sistemlerine gönderme</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis güvenlik log yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Log seviyesi
loglevel verbose

# Log dosyası
logfile /var/log/redis/redis-server.log

# Yavaş sorgu logu
slowlog-log-slower-than 10000
slowlog-max-len 128

# İstemci logları
# Redis 6.0 ve sonrası için
acllog-max-len 128</pre>
                            <p class="mt-2 font-medium">Java ile Redis güvenlik loglama:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisSecurityAuditService {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    private static final Logger securityLogger = LoggerFactory.getLogger("REDIS_SECURITY_AUDIT");
    
    @PostConstruct
    public void initSecurityAudit() {
        // Güvenlik loglarını yapılandır
        configureRedisLogging();
    }
    
    private void configureRedisLogging() {
        // RedisTemplate için özel loglama
        ((LettuceConnectionFactory) redisTemplate.getConnectionFactory())
                .setShareNativeConnection(false);
        
        // Güvenlik olaylarını dinle
        securityLogger.info("Redis güvenlik denetimi başlatıldı");
    }
    
    public void logSecurityEvent(String eventType, String username, String details) {
        // Güvenlik olayını logla
        String logMessage = String.format("Güvenlik olayı: %s, Kullanıcı: %s, Detaylar: %s", 
                eventType, username, details);
        
        securityLogger.warn(logMessage);
        
        // Güvenlik olayını Redis'e kaydet
        String eventKey = "security:events:" + System.currentTimeMillis();
        Map&lt;String, Object&gt; eventData = new HashMap&lt;&gt;();
        eventData.put("eventType", eventType);
        eventData.put("username", username);
        eventData.put("details", details);
        eventData.put("timestamp", System.currentTimeMillis());
        
        redisTemplate.opsForHash().putAll(eventKey, eventData);
        redisTemplate.expire(eventKey, 30, TimeUnit.DAYS);
    }
    
    public List&lt;Map&lt;String, Object&gt;&gt; getSecurityEvents() {
        // Tüm güvenlik olaylarını getir
        Set&lt;String&gt; eventKeys = redisTemplate.keys("security:events:*");
        List&lt;Map&lt;String, Object&gt;&gt; events = new ArrayList&lt;&gt;();
        
        for (String eventKey : eventKeys) {
            Map&lt;Object, Object&gt; eventData = redisTemplate.opsForHash().entries(eventKey);
            
            @SuppressWarnings("unchecked")
            Map&lt;String, Object&gt; event = (Map&lt;String, Object&gt;) (Object) eventData;
            events.add(event);
        }
        
        // Tarihe göre sırala
        events.sort((e1, e2) -> {
            long timestamp1 = (long) e1.get("timestamp");
            long timestamp2 = (long) e2.get("timestamp");
            return Long.compare(timestamp2, timestamp1);
        });
        
        return events;
    }
}</pre>
                            <p class="mt-2 font-medium">Redis komutlarını loglama:</p>
                            <pre class="code-block java mt-2">@Aspect
@Component
public class RedisCommandLoggingAspect {

    private static final Logger commandLogger = LoggerFactory.getLogger("REDIS_COMMANDS");
    
    @Around("execution(* org.springframework.data.redis.core.RedisTemplate.*(..))")
    public Object logRedisCommand(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        // Komut bilgilerini logla
        commandLogger.debug("Redis komutu: {}, Argümanlar: {}", methodName, Arrays.toString(args));
        
        try {
            // Komutu çalıştır
            Object result = joinPoint.proceed();
            
            // Sonucu logla
            commandLogger.debug("Redis komutu sonucu: {}", result);
            
            return result;
        } catch (Exception e) {
            // Hatayı logla
            commandLogger.error("Redis komutu hatası: {}, Hata: {}", methodName, e.getMessage(), e);
            throw e;
        }
    }
}</pre>
                            <p class="mt-2 font-medium">SIEM entegrasyonu:</p>
                            <pre class="code-block java mt-2">@Service
public class SiemIntegrationService {

    @Autowired
    private RedisSecurityAuditService securityAuditService;
    
    @Scheduled(fixedRate = 60000)  // Her dakika çalıştır
    public void sendSecurityEventsToSIEM() {
        // Güvenlik olaylarını getir
        List&lt;Map&lt;String, Object&gt;&gt; events = securityAuditService.getSecurityEvents();
        
        // SIEM sistemine gönder
        for (Map&lt;String, Object&gt; event : events) {
            sendToSIEM(event);
        }
    }
    
    private void sendToSIEM(Map&lt;String, Object&gt; event) {
        // SIEM sistemine gönderme mantığı
        // Örneğin, Syslog, REST API veya Kafka kullanarak
        
        String siemMessage = String.format(
                "&lt;134&gt;1 %s %s redis-security - - - Redis güvenlik olayı: %s, Kullanıcı: %s, Detaylar: %s",
                new Date((Long) event.get("timestamp")),
                InetAddress.getHostName(),
                event.get("eventType"),
                event.get("username"),
                event.get("details")
        );
        
        // Syslog sunucusuna gönder
        // ...
    }
}</pre>
                            <p class="mt-2">Redis güvenlik denetimi ve loglama, güvenlik olaylarını izlemek ve analiz etmek 
                            için önemlidir. Bu, özellikle düzenlemelere uyum sağlamak ve güvenlik ihlallerini 
                            tespit etmek için kritik öneme sahiptir.</p>
                        </div>
                    </div>

                    <!-- Soru 6 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 6: Redis'te güvenlik açıkları nasıl tespit edilir ve önlenir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te güvenlik açıkları, yetkisiz erişim, veri sızıntıları veya 
                            hizmet reddi saldırıları gibi güvenlik sorunlarıdır. Bu açıkları tespit etmek ve önlemek 
                            için çeşitli yöntemler kullanılır.</p>
                            <p class="mt-2 font-medium">Yaygın Redis güvenlik açıkları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Varsayılan parola veya parolasız erişim:</strong> Redis sunucusunun varsayılan 
                                yapılandırmada çalıştırılması</li>
                                <li><strong>Açık portlar:</strong> Redis sunucusunun internete açık portları</li>
                                <li><strong>Zayıf şifreleme:</strong> SSL/TLS kullanılmaması veya zayıf şifreleme algoritmaları</li>
                                <li><strong>Komut enjeksiyonu:</strong> Kullanıcı girdilerinin doğrulanmaması</li>
                                <li><strong>DoS saldırıları:</strong> Redis sunucusunu aşırı yükleme</li>
                                <li><strong>Veri sızıntısı:</strong> Hassas verilerin korunmaması</li>
                            </ul>
                            <p class="mt-2 font-medium">Güvenlik açıklarını tespit etme yöntemleri:</p>
                            <pre class="code-block bash mt-2"># Redis sunucusu güvenlik denetimi
nmap -p 6379 --script redis-info target-ip

# Zayıf parola taraması
nmap -p 6379 --script redis-brute target-ip

# SSL/TLS kontrolü
openssl s_client -connect target-ip:6379

# Redis sürüm ve güvenlik açığı kontrolü
redis-cli -h target-ip -p 6379 INFO server</pre>
                            <p class="mt-2 font-medium">Java ile güvenlik açığı taraması:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisVulnerabilityScanner {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    private static final Logger vulnerabilityLogger = LoggerFactory.getLogger("REDIS_VULNERABILITY_SCANNER");
    
    public void scanForVulnerabilities() {
        vulnerabilityLogger.info("Redis güvenlik taraması başlatıldı");
        
        // Varsayılan parola kontrolü
        checkDefaultPassword();
        
        // Açık port kontrolü
        checkOpenPorts();
        
        // SSL/TLS kontrolü
        checkSSLTLS();
        
        // Sürüm ve güvenlik açığı kontrolü
        checkVersionVulnerabilities();
        
        // Komut enjeksiyon kontrolü
        checkCommandInjection();
        
        vulnerabilityLogger.info("Redis güvenlik taraması tamamlandı");
    }
    
    private void checkDefaultPassword() {
        try {
            // Varsayılan parola ile bağlanmayı dene
            RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
            redisConfig.setHostName("localhost");
            redisConfig.setPort(6379);
            
            LettuceConnectionFactory connectionFactory = new LettuceConnectionFactory(redisConfig);
            connectionFactory.afterPropertiesSet();
            
            RedisConnection connection = connectionFactory.getConnection();
            
            try {
                // Bilinen varsayılan parolaları dene
                String[] defaultPasswords = {"", "redis", "pass", "123456"};
                
                for (String password : defaultPasswords) {
                    try {
                        connection.auth(password.getBytes());
                        vulnerabilityLogger.warn("Varsayılan parola tespit edildi: {}", password);
                        break;
                    } catch (Exception e) {
                        // Parola yanlış, devam et
                    }
                }
            } finally {
                connection.close();
            }
        } catch (Exception e) {
            vulnerabilityLogger.error("Varsayılan parola kontrolü sırasında hata: {}", e.getMessage());
        }
    }
    
    private void checkOpenPorts() {
        try {
            // Redis portunun açık olup olmadığını kontrol et
            Socket socket = new Socket();
            socket.connect(new InetSocketAddress("localhost", 6379), 1000);
            socket.close();
            
            vulnerabilityLogger.info("Redis portu (6379) açık");
            
            // Diğer olası Redis portlarını kontrol et
            int[] possiblePorts = {6380, 6379, 16379};
            
            for (int port : possiblePorts) {
                try {
                    socket = new Socket();
                    socket.connect(new InetSocketAddress("localhost", port), 1000);
                    socket.close();
                    
                    if (port != 6379) {
                        vulnerabilityLogger.warn("Diğer Redis portu açık: {}", port);
                    }
                } catch (IOException e) {
                    // Port kapalı, devam et
                }
            }
        } catch (Exception e) {
            vulnerabilityLogger.error("Açık port kontrolü sırasında hata: {}", e.getMessage());
        }
    }
    
    private void checkSSLTLS() {
        try {
            // SSL/TLS kullanılıp kullanılmadığını kontrol et
            RedisConnection connection = connectionFactory.getConnection();
            
            // SSL/TLS bilgilerini al
            Properties info = connection.serverCommands().info("tls");
            
            if (info.isEmpty()) {
                vulnerabilityLogger.warn("SSL/TLS kullanılmıyor");
            } else {
                vulnerabilityLogger.info("SSL/TLS kullanılıyor: {}", info);
            }
            
            connection.close();
        } catch (Exception e) {
            vulnerabilityLogger.error("SSL/TLS kontrolü sırasında hata: {}", e.getMessage());
        }
    }
    
    private void checkVersionVulnerabilities() {
        try {
            // Redis sürümünü al
            RedisConnection connection = connectionFactory.getConnection();
            Properties info = connection.serverCommands().info("server");
            
            String version = info.getProperty("redis_version");
            
            // Bilinen güvenlik açıklarını kontrol et
            if (version != null) {
                vulnerabilityLogger.info("Redis sürümü: {}", version);
                
                // Örnek: CVE-2022-0543 (Redis 7.0.0'dan önceki sürümlerde)
                if (version.compareTo("7.0.0") < 0) {
                    vulnerabilityLogger.warn("CVE-2022-0543 güvenlik açığı: Lua sandbox escape");
                }
                
                // Diğer bilinen güvenlik açıklarını burada kontrol et
                // ...
            }
            
            connection.close();
        } catch (Exception e) {
            vulnerabilityLogger.error("Sürüm kontrolü sırasında hata: {}", e.getMessage());
        }
    }
    
    private void checkCommandInjection() {
        // Komut enjeksiyon açıklarını kontrol et
        vulnerabilityLogger.info("Komut enjeksiyon kontrolü: Uygulama katmanında doğrulama yapılmalı");
    }
}</pre>
                            <p class="mt-2 font-medium">Güvenlik açıklarını önleme yöntemleri:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisSecurityHardeningService {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    public void hardenRedisSecurity() {
        // Güçlü parola ayarla
        setStrongPassword();
        
        // Tehlikeli komutları devre dışı bırak
        disableDangerousCommands();
        
        // SSL/TLS etkinleştir
        enableSSLTLS();
        
        // Ağ erişimini kısıtla
        restrictNetworkAccess();
        
        // Güvenlik loglarını etkinleştir
        enableSecurityLogging();
    }
    
    private void setStrongPassword() {
        // Güçlü bir parola oluştur ve ayarla
        String strongPassword = generateStrongPassword();
        
        // Redis sunucusuna parolayı ayarla
        RedisConnection connection = connectionFactory.getConnection();
        try {
            connection.execute("CONFIG SET requirepass " + strongPassword);
            connection.execute("CONFIG REWRITE");
        } finally {
            connection.close();
        }
    }
    
    private String generateStrongPassword() {
        // Güçlü bir parola oluştur
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
        StringBuilder password = new StringBuilder();
        Random random = new Random();
        
        for (int i = 0; i < 16; i++) {
            password.append(chars.charAt(random.nextInt(chars.length())));
        }
        
        return password.toString();
    }
    
    private void disableDangerousCommands() {
        // Tehlikeli komutları yeniden adlandır veya devre dışı bırak
        RedisConnection connection = connectionFactory.getConnection();
        try {
            // FLUSHDB, FLUSHALL, CONFIG, SHUTDOWN komutlarını devre dışı bırak
            connection.execute("RENAME-COMMAND FLUSHDB \"\"");
            connection.execute("RENAME-COMMAND FLUSHALL \"\"");
            connection.execute("RENAME-COMMAND CONFIG \"\"");
            connection.execute("RENAME-COMMAND SHUTDOWN \"\"");
            
            // Değişiklikleri kaydet
            connection.execute("CONFIG REWRITE");
        } finally {
            connection.close();
        }
    }
    
    private void enableSSLTLS() {
        // SSL/TLS etkinleştir
        // Bu, Redis sunucusu yapılandırmasında yapılmalı
        // ...
    }
    
    private void restrictNetworkAccess() {
        // Ağ erişimini kısıtla
        // Bu, güvenlik duvarı veya Redis yapılandırmasında yapılmalı
        // ...
    }
    
    private void enableSecurityLogging() {
        // Güvenlik loglarını etkinleştir
        // ...
    }
}</pre>
                            <p class="mt-2">Redis güvenlik açıklarını tespit etmek ve önlemek, Redis sunucusunun güvenliğini 
                            sağlamak için önemlidir. Düzenli güvenlik taramaları ve sertleştirme adımları, güvenlik 
                            ihlallerini önlemeye yardımcı olur.</p>
                        </div>
                    </div>

                    <!-- Soru 7 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 7: Redis'te güvenlik duvarı ve ağ erişim kontrolleri nasıl yapılandırılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te güvenlik duvarı ve ağ erişim kontrolleri, yetkisiz 
                            erişimi önlemek ve Redis sunucusunu korumak için kullanılır. Bu, özellikle internet üzerinden 
                            erişilen Redis sunucuları için önemlidir.</p>
                            <p class="mt-2 font-medium">Güvenlik duvarı ve ağ erişim kontrol stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>İşletim sistemi güvenlik duvarı:</strong> Sunucu düzeyinde port erişimini kısıtlama</li>
                                <li><strong>Redis bind ayarı:</strong> Redis'in sadece belirli IP adreslerinden bağlantı kabul etmesi</li>
                                <li><strong>Ağ segmentasyon:</strong> Redis sunucusunu ayrı bir ağ segmentinde çalıştırma</li>
                                <li><strong>VPN veya SSH tüneli:</strong> Redis erişimi için güvenli bağlantılar kullanma</li>
                                <li><strong>Bulut güvenlik grupları:</strong> Bulut ortamlarında ağ erişimini kısıtlama</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis bind yapılandırması:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Yerel bağlantılara izin ver
bind 127.0.0.1

# Özel IP adreslerine izin ver
bind 192.168.1.100

# Birden fazla IP adresi
bind 127.0.0.1 192.168.1.100

# Tüm arayüzlerde dinle (güvenli değil)
# bind 0.0.0.0</pre>
                            <p class="mt-2 font-medium">Linux güvenlik duvarı (iptables) yapılandırması:</p>
                            <pre class="code-block bash mt-2"># Redis portuna erişimi kısıtla
iptables -A INPUT -p tcp --dport 6379 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j DROP

# Kuralları kaydet
service iptables save

# veya
iptables-save > /etc/iptables/rules.v4</pre>
                            <p class="mt-2 font-medium">AWS güvenlik grubu yapılandırması:</p>
                            <pre class="code-block json mt-2">{
  "IpPermissions": [
    {
      "FromPort": 6379,
      "ToPort": 6379,
      "IpProtocol": "tcp",
      "IpRanges": [
        {
          "CidrIp": "192.168.1.0/24",
          "Description": "Redis erişimi"
        }
      ]
    }
  ]
}</pre>
                            <p class="mt-2 font-medium">Kubernetes NetworkPolicy yapılandırması:</p>
                            <pre class="code-block yaml mt-2">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: redis-network-policy
spec:
  podSelector:
    matchLabels:
      app: redis
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend
    - namespaceSelector:
        matchLabels:
          name: production
  - ports:
    - protocol: TCP
      port: 6379</pre>
                            <p class="mt-2 font-medium">Docker ağ yapılandırması:</p>
                            <pre class="code-block yaml mt-2">version: '3.8'
services:
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    networks:
      - backend
    environment:
      - REDIS_PASSWORD=yourpassword
  
  backend:
    image: your-backend-app
    depends_on:
      - redis
    networks:
      - backend

networks:
  backend:
    driver: bridge</pre>
                            <p class="mt-2 font-medium">VPN ile Redis erişimi:</p>
                            <pre class="code-block bash mt-2"># SSH tüneli oluşturma
ssh -L 6379:localhost:6379 user@redis-server

# veya
ssh -N -L 6379:localhost:6379 user@redis-server</pre>
                            <p class="mt-2">Güvenlik duvarı ve ağ erişim kontrolleri, Redis sunucusunu yetkisiz erişimlere 
                            karşı korumak için önemlidir. Bu kontroller, özellikle internet üzerinden erişilen Redis 
                            sunucuları için kritik öneme sahiptir.</p>
                        </div>
                    </div>

                    <!-- Soru 8 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 8: Redis'te güvenlik testi nasıl yapılır?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te güvenlik testi, Redis sunucusunun güvenlik önlemlerini 
                            değerlendirmek ve güvenlik açıklarını tespit etmek için kullanılır. Bu testler, manuel veya 
                            otomatik araçlarla yapılabilir.</p>
                            <p class="mt-2 font-medium">Güvenlik testi yöntemleri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Penetrasyon testi:</strong> Redis sunucusuna gerçek saldırıları simüle etme</li>
                                <li><strong>Vulnerability scanning:</strong> Otomatik araçlarla güvenlik açıklarını tarama</li>
                                <li><strong>Configuration audit:</strong> Redis yapılandırmasının güvenlik açıklarını kontrol etme</li>
                                <li><strong>Access control test:</strong> Erişim kontrollerinin etkinliğini test etme</li>
                                <li><strong>Encryption test:</strong> Şifrelemenin doğru çalıştığını doğrulama</li>
                            </ul>
                            <p class="mt-2 font-medium">Redis güvenlik test araçları:</p>
                            <pre class="code-block bash mt-2"># Nmap ile Redis tarama
nmap -p 6379 --script redis-info target-ip

# Nmap ile Redis zayıf parola taraması
nmap -p 6379 --script redis-brute target-ip

# Redis-trib.rb ile cluster güvenlik testi
redis-trib.rb check target-ip:6379

# Redis-cli ile güvenlik testi
redis-cli -h target-ip -p 6379 -a testpassword ping</pre>
                            <p class="mt-2 font-medium">Java ile güvenlik testi:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisSecurityTestService {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    private static final Logger securityTestLogger = LoggerFactory.getLogger("REDIS_SECURITY_TEST");
    
    public void performSecurityTests() {
        securityTestLogger.info("Redis güvenlik testleri başlatıldı");
        
        // Bağlantı güvenlik testi
        testConnectionSecurity();
        
        // Kimlik doğrulama testi
        testAuthentication();
        
        // Yetkilendirme testi
        testAuthorization();
        
        // Şifreleme testi
        testEncryption();
        
        // Komut enjeksiyon testi
        testCommandInjection();
        
        securityTestLogger.info("Redis güvenlik testleri tamamlandı");
    }
    
    private void testConnectionSecurity() {
        securityTestLogger.info("Bağlantı güvenlik testi başlatıldı");
        
        try {
            // Güvenli olmayan bağlantıyı dene
            RedisStandaloneConfiguration insecureConfig = new RedisStandaloneConfiguration();
            insecureConfig.setHostName("localhost");
            insecureConfig.setPort(6379);
            
            LettuceConnectionFactory insecureFactory = new LettuceConnectionFactory(insecureConfig);
            insecureFactory.afterPropertiesSet();
            
            RedisConnection insecureConnection = insecureFactory.getConnection();
            
            // Bağlantı başarılı oldu mu?
            securityTestLogger.warn("Güvenli olmayan bağlantı başarılı: {}", insecureConnection.ping());
            
            insecureConnection.close();
        } catch (Exception e) {
            securityTestLogger.info("Güvenli olmayan bağlantı başarısız: {}", e.getMessage());
        }
        
        try {
            // Güvenli bağlantıyı dene
            RedisStandaloneConfiguration secureConfig = new RedisStandaloneConfiguration();
            secureConfig.setHostName("localhost");
            secureConfig.setPort(6379);
            secureConfig.setPassword("yourpassword");
            
            LettuceConnectionFactory secureFactory = new LettuceConnectionFactory(secureConfig);
            secureFactory.afterPropertiesSet();
            
            RedisConnection secureConnection = secureFactory.getConnection();
            
            // Bağlantı başarılı oldu mu?
            securityTestLogger.info("Güvenli bağlantı başarılı: {}", secureConnection.ping());
            
            secureConnection.close();
        } catch (Exception e) {
            securityTestLogger.error("Güvenli bağlantı başarısız: {}", e.getMessage());
        }
    }
    
    private void testAuthentication() {
        securityTestLogger.info("Kimlik doğrulama testi başlatıldı");
        
        try {
            // Yanlış parola ile bağlanmayı dene
            RedisStandaloneConfiguration wrongConfig = new RedisStandaloneConfiguration();
            wrongConfig.setHostName("localhost");
            wrongConfig.setPort(6379);
            wrongConfig.setPassword("wrongpassword");
            
            LettuceConnectionFactory wrongFactory = new LettuceConnectionFactory(wrongConfig);
            wrongFactory.afterPropertiesSet();
            
            RedisConnection wrongConnection = wrongFactory.getConnection();
            
            // Kimlik doğrulama başarısız olmalı
            securityTestLogger.warn("Yanlış parola ile kimlik doğrulama başarılı: {}", wrongConnection.ping());
            
            wrongConnection.close();
        } catch (Exception e) {
            securityTestLogger.info("Yanlış parola ile kimlik doğrulama başarısız: {}", e.getMessage());
        }
    }
    
    private void testAuthorization() {
        securityTestLogger.info("Yetkilendirme testi başlatıldı");
        
        try {
            // Sınırlı kullanıcı ile bağlan
            RedisStandaloneConfiguration limitedConfig = new RedisStandaloneConfiguration();
            limitedConfig.setHostName("localhost");
            limitedConfig.setPort(6379);
            limitedConfig.setPassword("limiteduser");
            
            LettuceConnectionFactory limitedFactory = new LettuceConnectionFactory(limitedConfig);
            limitedFactory.afterPropertiesSet();
            
            RedisConnection limitedConnection = limitedFactory.getConnection();
            
            // İzin verilen komutu dene
            try {
                limitedConnection.ping();
                securityTestLogger.info("İzin verilen komut başarılı: ping");
            } catch (Exception e) {
                securityTestLogger.error("İzin verilen komut başarısız: {}", e.getMessage());
            }
            
            // İzin verilmeyen komutu dene
            try {
                limitedConnection.execute("FLUSHDB");
                securityTestLogger.warn("İzin verilmeyen komut başarılı: FLUSHDB");
            } catch (Exception e) {
                securityTestLogger.info("İzin verilmeyen komut başarısız: {}", e.getMessage());
            }
            
            limitedConnection.close();
        } catch (Exception e) {
            securityTestLogger.error("Yetkilendirme testi sırasında hata: {}", e.getMessage());
        }
    }
    
    private void testEncryption() {
        securityTestLogger.info("Şifreleme testi başlatıldı");
        
        try {
            // Şifrelenmemiş veri gönder
            RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
            config.setHostName("localhost");
            config.setPort(6379);
            config.setPassword("yourpassword");
            
            LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
            factory.afterPropertiesSet();
            
            RedisConnection connection = factory.getConnection();
            
            // Test verisi gönder
            String testData = "Güvenlik testi verisi";
            connection.set("test:key".getBytes(), testData.getBytes());
            
            // Test verisini al
            byte[] receivedData = connection.get("test:key".getBytes());
            
            if (receivedData != null) {
                String receivedString = new String(receivedData);
                securityTestLogger.info("Şifrelenmemiş veri alındı: {}", receivedString);
            } else {
                securityTestLogger.warn("Şifrelenmemiş veri alınamadı");
            }
            
            connection.close();
        } catch (Exception e) {
            securityTestLogger.error("Şifreleme testi sırasında hata: {}", e.getMessage());
        }
    }
    
    private void testCommandInjection() {
        securityTestLogger.info("Komut enjeksiyon testi başlatıldı");
        
        try {
            // Zararlı komut enjeksiyonunu dene
            RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
            config.setHostName("localhost");
            config.setPort(6379);
            config.setPassword("yourpassword");
            
            LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
            factory.afterPropertiesSet();
            
            RedisConnection connection = factory.getConnection();
            
            // Normal komut
            try {
                connection.set("safe:key".getBytes(), "safe value".getBytes());
                securityTestLogger.info("Normal komut başarılı");
            } catch (Exception e) {
                securityTestLogger.error("Normal komut başarısız: {}", e.getMessage());
            }
            
            // Potansiyel zararlı komut
            try {
                // Anahtarda özel karakterler içeren komut
                connection.set("safe:key;FLUSHDB".getBytes(), "injected value".getBytes());
                securityTestLogger.warn("Potansiyel zararlı komut başarılı");
            } catch (Exception e) {
                securityTestLogger.info("Potansiyel zararlı komut başarısız: {}", e.getMessage());
            }
            
            connection.close();
        } catch (Exception e) {
            securityTestLogger.error("Komut enjeksiyon testi sırasında hata: {}", e.getMessage());
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Güvenlik testi raporlama:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisSecurityReportService {

    @Autowired
    private RedisSecurityTestService securityTestService;
    
    public void generateSecurityReport() {
        // Güvenlik testlerini çalıştır
        securityTestService.performSecurityTests();
        
        // Test sonuçlarını topla
        Map&lt;String, Object&gt; testResults = collectTestResults();
        
        // Güvenlik raporu oluştur
        String report = generateReport(testResults);
        
        // Raporu logla veya kaydet
        System.out.println(report);
    }
    
    private Map&lt;String, Object&gt; collectTestResults() {
        Map&lt;String, Object&gt; results = new HashMap&lt;&gt;();
        
        // Bağlantı güvenlik testi sonuçları
        results.put("connectionSecurity", Map.of(
            "insecureConnection", false,
            "secureConnection", true
        ));
        
        // Kimlik doğrulama testi sonuçları
        results.put("authentication", Map.of(
            "wrongPasswordRejected", true
        ));
        
        // Yetkilendirme testi sonuçları
        results.put("authorization", Map.of(
            "allowedCommandsSuccessful", true,
            "disallowedCommandsRejected", true
        ));
        
        // Şifreleme testi sonuçları
        results.put("encryption", Map.of(
            "dataTransferredSuccessfully", true
        ));
        
        // Komut enjeksiyon testi sonuçları
        results.put("commandInjection", Map.of(
            "normalCommandsSuccessful", true,
            "injectionAttemptsRejected", true
        ));
        
        return results;
    }
    
    private String generateReport(Map&lt;String, Object&gt; testResults) {
        StringBuilder report = new StringBuilder();
        report.append("Redis Güvenlik Test Raporu\n");
        report.append("=========================\n\n");
        
        // Bağlantı güvenliği
        Map&lt;String, Object&gt; connectionResults = (Map&lt;String, Object&gt;) testResults.get("connectionSecurity");
        report.append("Bağlantı Güvenliği:\n");
        report.append(String.format("- Güvenli olmayan bağlantı: %s\n", 
                connectionResults.get("insecureConnection") ? "BAŞARISIZ" : "BAŞARILI"));
        report.append(String.format("- Güvenli bağlantı: %s\n\n", 
                connectionResults.get("secureConnection") ? "BAŞARILI" : "BAŞARISIZ"));
        
        // Kimlik doğrulama
        Map&lt;String, Object&gt; authResults = (Map&lt;String, Object&gt;) testResults.get("authentication");
        report.append("Kimlik Doğrulama:\n");
        report.append(String.format("- Yanlış parola reddedildi: %s\n\n", 
                authResults.get("wrongPasswordRejected") ? "BAŞARILI" : "BAŞARISIZ"));
        
        // Yetkilendirme
        Map&lt;String, Object&gt; authzResults = (Map&lt;String, Object&gt;) testResults.get("authorization");
        report.append("Yetkilendirme:\n");
        report.append(String.format("- İzin verilen komutlar: %s\n", 
                authzResults.get("allowedCommandsSuccessful") ? "BAŞARILI" : "BAŞARISIZ"));
        report.append(String.format("- İzin verilmeyen komutlar: %s\n\n", 
                authzResults.get("disallowedCommandsRejected") ? "BAŞARILI" : "BAŞARISIZ"));
        
        // Şifreleme
        Map&lt;String, Object&gt; encResults = (Map&lt;String, Object&gt;) testResults.get("encryption");
        report.append("Şifreleme:\n");
        report.append(String.format("- Veri transferi: %s\n\n", 
                encResults.get("dataTransferredSuccessfully") ? "BAŞARILI" : "BAŞARISIZ"));
        
        // Komut enjeksiyonu
        Map&lt;String, Object&gt; injResults = (Map&lt;String, Object&gt;) testResults.get("commandInjection");
        report.append("Komut Enjeksiyonu:\n");
        report.append(String.format("- Normal komutlar: %s\n", 
                injResults.get("normalCommandsSuccessful") ? "BAŞARILI" : "BAŞARISIZ"));
        report.append(String.format("- Enjeksiyon denemeleri: %s\n\n", 
                injResults.get("injectionAttemptsRejected") ? "BAŞARILI" : "BAŞARISIZ"));
        
        // Genel değerlendirme
        boolean allTestsPassed = true;
        for (Map.Entry&lt;String, Object&gt; entry : testResults.entrySet()) {
            Map&lt;String, Object&gt; categoryResults = (Map&lt;String, Object&gt;) entry.getValue();
            for (Map.Entry&lt;String, Object&gt; testEntry : categoryResults.entrySet()) {
                if (!Boolean.TRUE.equals(testEntry.getValue())) {
                    allTestsPassed = false;
                    break;
                }
            }
            if (!allTestsPassed) {
                break;
            }
        }
        
        report.append("Genel Değerlendirme: ");
        report.append(allTestsPassed ? "TÜM TESTLER BAŞARILI" : "Bazı testler başarısız");
        
        return report.toString();
    }
}</pre>
                            <p class="mt-2">Redis güvenlik testi, Redis sunucusunun güvenlik önlemlerini değerlendirmek ve 
                            güvenlik açıklarını tespit etmek için önemlidir. Düzenli güvenlik testleri, Redis sunucusunun 
                            güvenliğini sağlamak için kritik öneme sahiptir.</p>
                        </div>
                    </div>

                    <!-- Soru 9 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 9: Redis'te yedekleme ve kurtarma stratejileri nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te yedekleme ve kurtarma stratejileri, veri kaybını önlemek 
                            ve felaket durumlarında veri kurtarmak için önemlidir. Bu stratejiler, veri güvenliğini ve 
                            iş sürekliliğini sağlar.</p>
                            <p class="mt-2 font-medium">Yedekleme stratejileri:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>RDB yedeklemesi:</strong> Anlık görüntü dosyalarını yedekleme</li>
                                <li><strong>AOF yedeklemesi:</strong> Append-only dosyalarını yedekleme</li>
                                <li><strong>Veri aktarımı:</strong> Redis verilerini başka bir sunucuya kopyalama</li>
                                <li><strong>Cluster yedeklemesi:</strong> Redis Cluster verilerini yedekleme</li>
                                <li><strong>Bulut yedeklemesi:</strong> Verileri bulut depolama hizmetlerine yedekleme</li>
                            </ul>
                            <p class="mt-2 font-medium">RDB yedeklemesi:</p>
                            <pre class="code-block bash mt-2"># Manuel RDB yedeklemesi
redis-cli --rdb /path/to/backup/dump.rdb

# veya BGSAVE komutu ile arka planda yedekleme
redis-cli BGSAVE

# Yedekleme dosyasını kontrol et
ls -la /path/to/backup/dump.rdb</pre>
                            <p class="mt-2 font-medium">AOF yedeklemesi:</p>
                            <pre class="code-block bash mt-2"># AOF dosyasını yedekleme
cp /var/lib/redis/appendonly.aof /path/to/backup/appendonly-$(date +%Y%m%d).aof

# AOF dosyasını sıkıştır
gzip /path/to/backup/appendonly-$(date +%Y%m%d).aof</pre>
                            <p class="mt-2 font-medium">Veri aktarımı:</p>
                            <pre class="code-block bash mt-2"># Kaynak Redis sunucusundan verileri aktar
redis-cli --host source-redis --pipe < data.txt

# veya
redis-cli --host source-redis --rdb /path/to/dump.rdb
redis-cli --host target-redis --pipe < /path/to/dump.rdb</pre>
                            <p class="mt-2 font-medium">Java ile yedekleme:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisBackupService {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    private static final Logger backupLogger = LoggerFactory.getLogger("REDIS_BACKUP");
    
    public void createRDBBackup() {
        backupLogger.info("RDB yedeklemesi başlatıldı");
        
        try {
            RedisConnection connection = connectionFactory.getConnection();
            
            // BGSAVE komutunu çalıştır
            String result = connection.execute("BGSAVE").toString();
            backupLogger.info("BGSAVE komutu sonucu: {}", result);
            
            // Yedeklemenin tamamlanmasını bekle
            waitForBackupCompletion(connection);
            
            // Yedekleme dosyasını kopyala
            copyRDBFile();
            
            connection.close();
        } catch (Exception e) {
            backupLogger.error("RDB yedeklemesi sırasında hata: {}", e.getMessage());
        }
    }
    
    private void waitForBackupCompletion(RedisConnection connection) {
        backupLogger.info("Yedekleme tamamlanana kadar bekleniyor...");
        
        while (true) {
            try {
                // Yedekleme durumunu kontrol et
                String info = connection.execute("INFO").toString();
                
                if (info.contains("rdb_bgsave_in_progress:0")) {
                    backupLogger.info("Yedekleme tamamlandı");
                    break;
                }
                
                // 1 saniye bekle
                Thread.sleep(1000);
            } catch (Exception e) {
                backupLogger.error("Yedekleme durumu kontrol edilirken hata: {}", e.getMessage());
                break;
            }
        }
    }
    
    private void copyRDBFile() {
        try {
            // RDB dosyasını kopyala
            Path sourcePath = Paths.get("/var/lib/redis/dump.rdb");
            Path backupDir = Paths.get("/path/to/backup");
            
            if (!Files.exists(backupDir)) {
                Files.createDirectories(backupDir);
            }
            
            String timestamp = new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date());
            Path backupPath = backupDir.resolve("dump-" + timestamp + ".rdb");
            
            Files.copy(sourcePath, backupPath, StandardCopyOption.REPLACE_EXISTING);
            
            backupLogger.info("RDB dosyası yedeklendi: {}", backupPath);
        } catch (Exception e) {
            backupLogger.error("RDB dosyası kopyalanırken hata: {}", e.getMessage());
        }
    }
    
    public void createAOFBackup() {
        backupLogger.info("AOF yedeklemesi başlatıldı");
        
        try {
            // AOF dosyasını kopyala
            Path sourcePath = Paths.get("/var/lib/redis/appendonly.aof");
            Path backupDir = Paths.get("/path/to/backup");
            
            if (!Files.exists(backupDir)) {
                Files.createDirectories(backupDir);
            }
            
            String timestamp = new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date());
            Path backupPath = backupDir.resolve("appendonly-" + timestamp + ".aof");
            
            Files.copy(sourcePath, backupPath, StandardCopyOption.REPLACE_EXISTING);
            
            backupLogger.info("AOF dosyası yedeklendi: {}", backupPath);
        } catch (Exception e) {
            backupLogger.error("AOF yedeklemesi sırasında hata: {}", e.getMessage());
        }
    }
    
    public void createDataBackup() {
        backupLogger.info("Veri yedeklemesi başlatıldı");
        
        try {
            RedisConnection connection = connectionFactory.getConnection();
            
            // Tüm anahtarları al
            Set&lt;byte[]&gt; keys = connection.keys("*".getBytes());
            
            // Yedekleme dizini oluştur
            Path backupDir = Paths.get("/path/to/backup/data");
            if (!Files.exists(backupDir)) {
                Files.createDirectories(backupDir);
            }
            
            String timestamp = new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date());
            Path backupFile = backupDir.resolve("redis-data-" + timestamp + ".txt");
            
            try (BufferedWriter writer = Files.newBufferedWriter(backupFile)) {
                for (byte[] key : keys) {
                    // Anahtar ve değeri al
                    byte[] value = connection.get(key);
                    
                    // Dosyaya yaz
                    writer.write(new String(key) + ":" + new String(value) + "\n");
                }
            }
            
            backupLogger.info("Veri yedeklendi: {}", backupFile);
            
            connection.close();
        } catch (Exception e) {
            backupLogger.error("Veri yedeklemesi sırasında hata: {}", e.getMessage());
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Kurtarma stratejileri:</p>
                            <pre class="code-block java mt-2">@Service
public class RedisRecoveryService {

    @Autowired
    private RedisConnectionFactory connectionFactory;
    
    private static final Logger recoveryLogger = LoggerFactory.getLogger("REDIS_RECOVERY");
    
    public void restoreFromRDB(String backupFilePath) {
        recoveryLogger.info("RDB'den kurtarma başlatıldı: {}", backupFilePath);
        
        try {
            // Redis sunucusunu durdur
            stopRedisServer();
            
            // RDB dosyasını kopyala
            Path sourcePath = Paths.get(backupFilePath);
            Path targetPath = Paths.get("/var/lib/redis/dump.rdb");
            
            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
            
            // Redis sunucusunu başlat
            startRedisServer();
            
            recoveryLogger.info("RDB'den kurtarma tamamlandı");
        } catch (Exception e) {
            recoveryLogger.error("RDB'den kurtarma sırasında hata: {}", e.getMessage());
        }
    }
    
    public void restoreFromAOF(String backupFilePath) {
        recoveryLogger.info("AOF'dan kurtarma başlatıldı: {}", backupFilePath);
        
        try {
            // Redis sunucusunu durdur
            stopRedisServer();
            
            // AOF dosyasını kopyala
            Path sourcePath = Paths.get(backupFilePath);
            Path targetPath = Paths.get("/var/lib/redis/appendonly.aof");
            
            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
            
            // Redis sunucusunu başlat
            startRedisServer();
            
            recoveryLogger.info("AOF'dan kurtarma tamamlandı");
        } catch (Exception e) {
            recoveryLogger.error("AOF'dan kurtarma sırasında hata: {}", e.getMessage());
        }
    }
    
    public void restoreFromDataBackup(String backupFilePath) {
        recoveryLogger.info("Veri yedeklemesinden kurtarma başlatıldı: {}", backupFilePath);
        
        try {
            RedisConnection connection = connectionFactory.getConnection();
            
            // Yedekleme dosyasını oku
            List&lt;String&gt; lines = Files.readAllLines(Paths.get(backupFilePath));
            
            // Verileri geri yükle
            for (String line : lines) {
                String[] parts = line.split(":", 2);
                if (parts.length == 2) {
                    String key = parts[0];
                    String value = parts[1];
                    
                    connection.set(key.getBytes(), value.getBytes());
                }
            }
            
            recoveryLogger.info("Veri yedeklemesinden kurtarma tamamlandı");
            
            connection.close();
        } catch (Exception e) {
            recoveryLogger.error("Veri yedeklemesinden kurtarma sırasında hata: {}", e.getMessage());
        }
    }
    
    private void stopRedisServer() {
        try {
            // Redis sunucusunu durdur
            ProcessBuilder processBuilder = new ProcessBuilder("sudo", "systemctl", "stop", "redis");
            Process process = processBuilder.start();
            process.waitFor();
            
            recoveryLogger.info("Redis sunucusu durduruldu");
        } catch (Exception e) {
            recoveryLogger.error("Redis sunucusu durdurulurken hata: {}", e.getMessage());
        }
    }
    
    private void startRedisServer() {
        try {
            // Redis sunucusunu başlat
            ProcessBuilder processBuilder = new ProcessBuilder("sudo", "systemctl", "start", "redis");
            Process process = processBuilder.start();
            process.waitFor();
            
            recoveryLogger.info("Redis sunucusu başlatıldı");
        } catch (Exception e) {
            recoveryLogger.error("Redis sunucusu başlatılırken hata: {}", e.getMessage());
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Otomatik yedekleme:</p>
                            <pre class="code-block java mt-2">@Service
public class ScheduledRedisBackupService {

    @Autowired
    private RedisBackupService backupService;
    
    // Her gün gece yarısı yedekle
    @Scheduled(cron = "0 0 0 * * *")
    public void scheduledBackup() {
        backupService.createRDBBackup();
        backupService.createAOFBackup();
        backupService.createDataBackup();
    }
    
    // Her hafta pazar günü yedekle
    @Scheduled(cron = "0 0 0 * * SUN")
    public void weeklyBackup() {
        backupService.createRDBBackup();
        backupService.createAOFBackup();
        backupService.createDataBackup();
    }
}</pre>
                            <p class="mt-2">Redis yedekleme ve kurtarma stratejileri, veri kaybını önlemek ve felaket 
                            durumlarında veri kurtarmak için önemlidir. Düzenli yedeklemeler ve test edilmiş kurtarma 
                            planları, veri güvenliğini ve iş sürekliliğini sağlar.</p>
                        </div>
                    </div>

                    <!-- Soru 10 -->
                    <div class="question-card border-l-4 border-red-500 pl-4 py-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800 mb-2">❓ Soru 10: Redis'te güvenlik en iyi uygulamaları nelerdir?</h4>
                        <div class="text-gray-700">
                            <p><strong>Cevap:</strong> Redis'te güvenlik en iyi uygulamaları, Redis sunucusunu güvenli 
                            bir şekilde yapılandırmak ve yönetmek için önerilen yöntemlerdir. Bu uygulamalar, güvenlik 
                            açıklarını önlemeye ve veri güvenliğini artırmaya yardımcı olur.</p>
                            <p class="mt-2 font-medium">Redis güvenlik en iyi uygulamaları:</p>
                            <ul class="list-disc pl-5 mt-2">
                                <li><strong>Güçlü parola kullanma:</strong> Karmaşık ve tahmin edilmesi zor parolalar kullanmak</li>
                                <li><strong>SSL/TLS şifreleme:</strong> İstemci-sunucu arasındaki iletişimi şifrelemek</li>
                                <li><strong>Ağ erişimini kısıtlama:</strong> Sadece güvenilen IP adreslerinden bağlantıya izin vermek</li>
                                <li><strong>Tehlikeli komutları devre dışı bırakma:</strong> FLUSHDB, FLUSHALL gibi tehlikeli komutları yeniden adlandırmak</li>
                                <li><strong>Veri şifreleme:</strong> Hassas verileri şifreleyerek saklamak</li>
                                <li><strong>Düzenli güvenlik denetimleri:</strong> Güvenlik açıklarını düzenli olarak taramak</li>
                                <li><strong>Güvenlik loglama:</strong> Güvenlik olaylarını loglamak ve izlemek</li>
                                <li><strong>Düzenli yedeklemeler:</strong> Verileri düzenli olarak yedeklemek</li>
                                <li><strong>Erişim kontrolleri:</strong> Kullanıcıları ve rolleri yönetmek</li>
                                <li><strong>Güncel sürümleri kullanma:</strong> Redis ve istemcileri güncel tutmak</li>
                            </ul>
                            <p class="mt-2 font-medium">Güvenlik yapılandırması örneği:</p>
                            <pre class="code-block bash mt-2"># redis.conf
# Güçlü parola
requirepass S3cur3P@ssw0rd!2023

# Sadece yerel ve özel ağdan bağlantıya izin ver
bind 127.0.0.1 10.0.0.100

# Tehlikeli komutları devre dışı bırak
rename-command CONFIG ""
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command SHUTDOWN ""

# SSL/TLS etkinleştir
tls-cert-file /etc/redis/redis-server.crt
tls-key-file /etc/redis/redis-server.key
tls-ca-cert-file /etc/redis/ca.crt

# AOF etkinleştir
appendonly yes
appendfsync everysec

# Güvenlik logları
loglevel verbose
acllog-max-len 128</pre>
                            <p class="mt-2 font-medium">Java ile güvenlik yapılandırması:</p>
                            <pre class="code-block java mt-2">@Configuration
@EnableRedisRepositories
public class RedisSecurityConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName("your-redis-host");
        redisConfig.setPort(6379);
        redisConfig.setPassword("S3cur3P@ssw0rd!2023");
        
        // SSL yapılandırması
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .useSsl()
                .and()
                .clientOptions(ClientOptions.builder()
                        .sslOptions(SslOptions.builder()
                                .jdkSslProvider()
                                .truststore(new ClassPathResource("ca.jks"), "password")
                                .keystore(new ClassPathResource("redis-client.jks"), "password")
                                .build())
                        .build())
                .build();
        
        return new LettuceConnectionFactory(redisConfig, clientConfig);
    }

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }

    @Bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(connectionFactory);
        return template;
    }
}</pre>
                            <p class="mt-2 font-medium">Güvenlik denetimi ve loglama:</p>
                            <pre class="code-block java mt-2">@Aspect
@Component
public class RedisSecurityAspect {

    private static final Logger securityLogger = LoggerFactory.getLogger("REDIS_SECURITY");
    
    @Around("execution(* org.springframework.data.redis.core.RedisTemplate.*(..))")
    public Object logRedisOperations(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        // Güvenlik logu
        securityLogger.debug("Redis işlemi: {}, Argümanlar: {}", methodName, Arrays.toString(args));
        
        try {
            // İşlemi çalıştır
            Object result = joinPoint.proceed();
            
            // Sonucu logla
            securityLogger.debug("Redis işlemi sonucu: {}", result);
            
            return result;
        } catch (Exception e) {
            // Hataları logla
            securityLogger.error("Redis işlemi hatası: {}, Hata: {}", methodName, e.getMessage(), e);
            throw e;
        }
    }
}</pre>
                            <p class="mt-2 font-medium">Veri şifreleme:</p>
                            <pre class="code-block java mt-2">@Service
public class SecureDataService {

    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private final SecretKey secretKey;
    private final Cipher cipher;
    
    public SecureDataService() throws Exception {
        // Anahtar oluştur (gerçek uygulamada güvenli bir şekilde saklanmalı)
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(256);
        secretKey = keyGenerator.generateKey();
        
        cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    }
    
    public void saveSecureData(String key, String value) {
        try {
            // Veriyi şifrele
            byte[] encryptedValue = encrypt(value);
            
            // Base64 ile kodla ve Redis'e kaydet
            String encodedValue = Base64.getEncoder().encodeToString(encryptedValue);
            redisTemplate.opsForValue().set("secure:" + key, encodedValue);
            
            // TTL ayarla
            redisTemplate.expire("secure:" + key, 1, TimeUnit.HOURS);
        } catch (Exception e) {
            throw new RuntimeException("Veri şifreleme hatası", e);
        }
    }
    
    public String getSecureData(String key) {
        try {
            // Redis'ten şifrelenmiş veriyi al
            String encodedValue = redisTemplate.opsForValue().get("secure:" + key);
            
            if (encodedValue == null) {
                return null;
            }
            
            // Base64'den çöz ve şifreyi çöz
            byte[] encryptedValue = Base64.getDecoder().decode(encodedValue);
            return decrypt(encryptedValue);
        } catch (Exception e) {
            throw new RuntimeException("Veri şifre çözme hatası", e);
        }
    }
    
    private byte[] encrypt(String value) throws Exception {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));
        
        byte[] encrypted = cipher.doFinal(value.getBytes());
        
        // IV ve şifrelenmiş veriyi birleştir
        byte[] combined = new byte[iv.length + encrypted.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
        
        return combined;
    }
    
    private String decrypt(byte[] encryptedValue) throws Exception {
        // IV ve şifrelenmiş veriyi ayır
        byte[] iv = new byte[16];
        System.arraycopy(encryptedValue, 0, iv, 0, iv.length);
        
        byte[] encrypted = new byte[encryptedValue.length - 16];
        System.arraycopy(encryptedValue, 16, encrypted, 0, encrypted.length);
        
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        
        byte[] decrypted = cipher.doFinal(encrypted);
        return new String(decrypted);
    }
}</pre>
                            <p class="mt-2">Redis güvenlik en iyi uygulamaları, Redis sunucusunu güvenli bir şekilde 
                            yapılandırmak ve yönetmek için önemlidir. Bu uygulamalar, güvenlik açıklarını önlemeye 
                            ve veri güvenliğini artırmaya yardımcı olur.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer class="text-center py-8 text-gray-600">
            <p>© 2025 Redis Mülakat Soruları. All rights reserved.</p>
        </footer>
    </div>

    <script>
        function scrollToCategory(categoryId) {
            const element = document.getElementById(categoryId);
            element.scrollIntoView({ behavior: 'smooth' });
        }
    </script>
</body>

</html>
