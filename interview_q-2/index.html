<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Senior Developer Teknik Soru Bankası</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .category-item {
            transition: all 0.3s ease;
        }

        .category-item:hover {
            transform: translateX(5px);
        }

        .category-item.active {
            background-color: #4f46e5;
            color: white;
        }

        .question-card {
            transition: all 0.3s ease;
        }

        .question-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .answer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .answer-content.active {
            max-height: 1000px;
        }

        .code-block {
            background-color: #1e293b;
            color: #e2e8f0;
            border-radius: 0.375rem;
            padding: 1rem;
            overflow-x: auto;
        }

        .sidebar {
            transition: all 0.3s ease;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                position: fixed;
                z-index: 10;
                height: 100%;
            }

            .sidebar.open {
                transform: translateX(0);
            }
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800">
    <div class="flex flex-col md:flex-row min-h-screen">
        <!-- Sidebar -->
        <div id="sidebar" class="sidebar w-full md:w-64 bg-indigo-800 text-white p-4">
            <div class="flex justify-between items-center mb-8">
                <h2 class="text-xl font-bold">Kategoriler</h2>
                <button id="closeSidebar" class="md:hidden text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <ul class="space-y-2">
                <li>
                    <button class="category-item w-full text-left p-2 rounded active" data-category="docker-kubernetes">
                        <i class="fas fa-docker mr-2"></i> Docker & Kubernetes
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="kafka">
                        <i class="fas fa-stream mr-2"></i> Kafka
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="redis">
                        <i class="fas fa-database mr-2"></i> Redis
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="elasticsearch">
                        <i class="fas fa-search mr-2"></i> ElasticSearch
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="spring-cloud">
                        <i class="fas fa-cloud mr-2"></i> Spring Cloud & Microservices
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="spring-boot">
                        <i class="fas fa-leaf mr-2"></i> Spring Boot & Core
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="spring-batch">
                        <i class="fas fa-tasks mr-2"></i> Spring Batch
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="spring-caching">
                        <i class="fas fa-memory mr-2"></i> Spring Caching & AOP
                    </button>
                </li>
                <li>
                    <button class="category-item w-full text-left p-2 rounded" data-category="spring-integration">
                        <i class="fas fa-plug mr-2"></i> Spring Integration & DevOps
                    </button>
                </li>
            </ul>
        </div>

        <!-- Main Content -->
        <div class="flex-1 p-4 md:p-8">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold text-indigo-800">Senior Developer Teknik Soru Bankası</h1>
                <button id="openSidebar" class="md:hidden text-indigo-800">
                    <i class="fas fa-bars text-xl"></i>
                </button>
            </div>

            <!-- Search Bar -->
            <div class="mb-8">
                <div class="relative">
                    <input type="text" id="searchInput" placeholder="Sorularda ara..."
                        class="w-full p-3 pl-10 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <div class="absolute left-3 top-3 text-gray-400">
                        <i class="fas fa-search"></i>
                    </div>
                </div>
            </div>

            <!-- Content Area -->
            <div id="contentArea" class="space-y-6">
                <!-- Docker & Kubernetes Soruları -->
                <div id="docker-kubernetes" class="category-content">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Docker & Kubernetes Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">1. Docker imajı ile container arasındaki fark nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">İmaj: Uygulamanın çalışması için gerekli dosya ve bağımlılıkların
                                şablonu. Container: İmajın runtime hali, izole ortamda çalışan uygulama.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-1">
                                <li><strong>İmaj:</strong> Uygulamanın çalışması için gereken tüm dosyaları,
                                    kütüphaneleri ve bağımlılıkları içeren, salt okunur bir şablondur. İmajlar,
                                    Dockerfile kullanılarak oluşturulur ve bir Docker registry'de (Docker Hub, AWS ECR,
                                    vb.) saklanabilir.</li>
                                <li><strong>Container:</strong> Bir imajın çalıştırılabilir örneğidir. Container, imajın
                                    üzerine bir yazılabilir katman ekler ve uygulamanın izole bir ortamda çalışmasını
                                    sağlar. Her container, kendi process space, network ve file system'ine sahiptir.
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Docker imajı oluşturma
docker build -t myapp:1.0 .

# İmajı çalıştırarak container oluşturma
docker run -d --name myapp-container myapp:1.0</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">2. Dockerfile optimize etmenin yolları nelerdir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Multi-stage build kullanmak, Gereksiz layer'ları azaltmak, Minimal
                                base image kullanmak (Alpine), Cache kullanımını optimize etmek</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Multi-stage build:</strong> Build ortamı ve runtime ortamını ayırarak nihai
                                    imaj boyutunu küçültür.</li>
                                <li><strong>Layer sıralaması:</strong> Sık değişen dosyaları Dockerfile'da sona koymak,
                                    cache kullanımını optimize eder.</li>
                                <li><strong>Minimal base image:</strong> Alpine gibi küçük boyutlu base image'lar
                                    kullanmak.</li>
                                <li><strong>.dockerignore:</strong> Gereksiz dosyaların imaja eklenmesini önlemek için.
                                </li>
                                <li><strong>Single responsibility:</strong> Her container için tek bir sorumluluk.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Multi-stage build örneği
# Build stage
FROM maven:3.8.5 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# Runtime stage
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">3. Kubernetes pod nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Pod: Kubernetes'te çalıştırılabilen en küçük deployable birim.
                                İçinde bir veya birden fazla container olabilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-1">
                                <li>Pod, Kubernetes'te yönetilen ve çalıştırılan en küçük birimdir.</li>
                                <li>Bir pod içinde bir veya daha fazla tightly coupled container bulunabilir.</li>
                                <li>Pod içindeki container'lar aynı network namespace'ini paylaşırlar ve localhost
                                    üzerinden birbirlerine erişebilirler.</li>
                                <li>Pod'lar ephemeral (geçici) yapılardır ve bir kez silindiklerinde geri
                                    getirilemezler.</li>
                                <li>Pod'lar genellikle Deployment, StatefulSet gibi daha üst seviye controller'lar
                                    tarafından yönetilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Pod örneği
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: myapp:1.0
    ports:
    - containerPort: 8080</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">4. Deployment ve StatefulSet farkı nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Deployment: Stateless servisler için, pod'lar eşit ve
                                değiştirilebilir. StatefulSet: Stateful servisler için, persistent storage ve ordered
                                deployment sağlar.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <table class="min-w-full divide-y divide-gray-200 mt-3">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Özellik</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Deployment</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            StatefulSet</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Kullanım Alanı</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Stateless uygulamalar</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Stateful uygulamalar (DB, mesaj kuyruğu)
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Pod İsimlendirme</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Rastgele isimler</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Sıralı, öngörülebilir isimler</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Deployment</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Paralel/rastrgele</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Sıralı (0-N)</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Storage</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Paylaşılan veya ephemeral</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Pod'a özel persistent storage</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">5. Kubernetes'de Service tipi ve farkları</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">ClusterIP: Sadece cluster içi erişim. NodePort: Dışarıdan belirli
                                port üzerinden erişim. LoadBalancer: Cloud provider üzerinden load balancing.
                                ExternalName: DNS tabanlı alias.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>ClusterIP:</strong> Varsayılan service tipi. Sadece cluster içinde
                                    erişilebilir. Dışarıdan erişim yoktur.</li>
                                <li><strong>NodePort:</strong> Her node üzerinde aynı port numarasıyla dışarıdan erişim
                                    sağlar. Port aralığı: 30000-32767.</li>
                                <li><strong>LoadBalancer:</strong> Bulut sağlayıcının (AWS, GCP, Azure) load
                                    balancer'ını kullanarak dışarıdan erişim sağlar.</li>
                                <li><strong>ExternalName:</strong> Service'e bir DNS alias atar. Internal DNS'e CNAME
                                    kaydı ekler.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># ClusterIP Service
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP

# NodePort Service
apiVersion: v1
kind: Service
metadata:
  name: myapp-nodeport-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30001
  type: NodePort</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Kafka Soruları -->
                <div id="kafka" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Kafka Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">11. Kafka topic, partition ve offset nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Topic → mesajların kategorisi. Partition → paralel işleme birimi.
                                Offset → partition'daki mesaj sırası.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Topic:</strong> Mesajların kategorize edildiği mantıksal birim. Bir topic,
                                    birden fazla partition içerebilir.</li>
                                <li><strong>Partition:</strong> Topic içindeki fiziksel bölümler. Her partition, broker
                                    üzerinde ayrı bir log dosyası olarak saklanır. Partition'lar, paralel işleme ve
                                    ölçeklenebilirlik sağlar.</li>
                                <li><strong>Offset:</strong> Partition içindeki her mesajın benzersiz kimliği.
                                    Offset'ler partition başına sıralıdır ve consumer tarafından takip edilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Topic oluşturma
bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 3 --topic my-topic

# Topic bilgilerini görme
bin/kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic my-topic</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">12. Kafka'da producer ack seviyeleri</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">acks=0 → fire-and-forget. acks=1 → leader commit. acks=all → leader
                                + replica commit (güvenli).</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>acks=0:</strong> Producer, mesajı gönderir ve beklemeden devam eder. En
                                    hızlı ancak en az güvenilir seçenektir. Mesaj kaybolabilir.</li>
                                <li><strong>acks=1:</strong> Producer, mesajın partition liderine yazıldığını
                                    onayladıktan sonra devam eder. Orta düzeyde güvenlik sağlar.</li>
                                <li><strong>acks=all:</strong> Producer, mesajın partition liderine VE tüm in-sync
                                    replikalarına yazıldığını onayladıktan sonra devam eder. En güvenilir seçenektir
                                    ancak en yavaş olanıdır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Producer ack ayarı
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("acks", "all"); // Güvenli mod
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

Producer<String, String> producer = new KafkaProducer<>(props);</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">13. Kafka consumer group nasıl çalışır?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Partition'lar consumer'lara dağıtılır. Consumer sayısı > partition
                                → fazla consumer idle olur.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Consumer Group:</strong> Aynı topic'i tüketen consumer'ların mantıksal
                                    grubudur. Her consumer group, topic'teki mesajları bağımsız olarak tüketir.</li>
                                <li><strong>Partition Dağılımı:</strong> Bir topic'teki partition'lar, consumer group
                                    içindeki consumer'lar arasında dağıtılır. Her partition, sadece bir consumer
                                    tarafından tüketilir.</li>
                                <li><strong>Dengeleme:</strong> Consumer sayısı partition sayısından azsa, bazı
                                    consumer'lar birden fazla partition tüketir. Consumer sayısı partition sayısından
                                    fazlaysa, fazla consumer'lar idle kalır.</li>
                                <li><strong>Rebalance:</strong> Gruba yeni bir consumer eklendiğinde veya bir consumer
                                    çıktığında, partition'ların yeniden dağıtılması işlemidir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Consumer group ayarı
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("group.id", "my-consumer-group");
props.put("enable.auto.commit", "false");
props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
consumer.subscribe(Collections.singletonList("my-topic"));</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">14. Kafka'da exactly-once delivery nasıl sağlanır?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Idempotent producer + transactional producer. Consumer
                                read_committed kullanmalı.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Idempotent Producer:</strong> Aynı mesajın birden fazla kez gönderilmesi
                                    durumunda, Kafka bunu tekrarlı mesaj olarak tanır ve sadece bir kez işler.
                                    enable.idempotence=true ile etkinleştirilir.</li>
                                <li><strong>Transactional Producer:</strong> Birden fazla partition'a atomik olarak
                                    mesaj göndermek için kullanılır.beginTransaction(), send(), commitTransaction()
                                    metodları ile kullanılır.</li>
                                <li><strong>Consumer Ayarları:</strong> Consumer'ın isolation.level=read_committed
                                    olarak ayarlanması gerekir. Bu, consumer'ın sadece transaction ile commit edilmiş
                                    mesajları okumasını sağlar.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Idempotent producer
props.put("enable.idempotence", "true");

# Transactional producer
props.put("transactional.id", "my-transactional-id");

Producer<String, String> producer = new KafkaProducer<>(props);
producer.initTransactions();

try {
    producer.beginTransaction();
    // Mesajları gönder
    producer.send(new ProducerRecord<>("topic1", "key1", "value1"));
    producer.send(new ProducerRecord<>("topic2", "key2", "value2"));
    producer.commitTransaction();
} catch (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) {
    producer.close();
} catch (KafkaException e) {
    producer.abortTransaction();
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">15. Kafka'da backpressure ve flow control nasıl sağlanır?
                        </h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Consumer lag monitoring. Reactive Kafka / Reactor kullanarak
                                reactive backpressure. Batch tüketim ve commit ile kontrol.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Consumer Lag Monitoring:</strong> Consumer'ın son okuduğu offset ile
                                    partition'daki en son offset arasındaki farkı ölçmek. Bu, consumer'ın ne kadar
                                    geride kaldığını gösterir.</li>
                                <li><strong>Reactive Backpressure:</strong> Reactive Kafka (Reactor Kafka) kullanarak,
                                    consumer'ın processing hızına göre veri akışını kontrol etmek.
                                    Flux.onBackpressureBuffer() veya onBackpressureDrop() ile.</li>
                                <li><strong>Batch Tüketim:</strong> Consumer'ın tek tek değil, gruplar halinde (batch)
                                    mesajları işlemesi. Bu, network ve processing overhead'ini azaltır.</li>
                                <li><strong>Commit Stratejisi:</strong> Manuel commit kullanarak, consumer'ın sadece
                                    işlediği mesajları commit etmesi sağlanır. Bu, veri kaybını önler.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Reactive Kafka ile backpressure
Flux<ConsumerRecord<String, String>> flux = KafkaReceiver.create(receiverOptions)
    .receive()
    .onBackpressureBuffer(1000) // Buffer boyutu
    .concatMap(record -> processRecord(record).then(Mono.fromRunnable(() -> 
        record.receiverOffset().commit()
    )));

private Mono<Void> processRecord(ConsumerRecord<String, String> record) {
    // Mesaj işleme mantığı
    return Mono.fromRunnable(() -> {
        System.out.println("Processed: " + record.value());
    });
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Redis Soruları -->
                <div id="redis" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Redis Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">21. Redis hangi veri tiplerini destekler?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">String, Hash, List, Set, Sorted Set, HyperLogLog, Bitmap, Stream.
                            </p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>String:</strong> En temel veri tipi. Text, JSON, binary veriler
                                    saklanabilir.</li>
                                <li><strong>Hash:</strong> Key-value çiftleri koleksiyonu. Nesneleri saklamak için
                                    idealdir.</li>
                                <li><strong>List:</strong> Sıralı string koleksiyonu. Queue ve stack implementasyonları
                                    için kullanılır.</li>
                                <li><strong>Set:</strong> Sırasız benzersiz elemanlar koleksiyonu. Üyelik kontrolü,
                                    etiketleme için kullanılır.</li>
                                <li><strong>Sorted Set:</strong> Skor ile sıralanmış benzersiz elemanlar koleksiyonu.
                                    Leaderboard, sıralama için kullanılır.</li>
                                <li><strong>HyperLogLog:</strong> Kardinalite tahmini için kullanılır. Benzersiz eleman
                                    sayısını az memory ile tahmin eder.</li>
                                <li><strong>Bitmap:</strong> Bit seviyesinde operasyonlar için kullanılır. Presence
                                    flag, istatistikler için idealdir.</li>
                                <li><strong>Stream:</strong> Kafka benzeri log veri yapısı. Mesajlaşma ve event sourcing
                                    için kullanılır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># String örneği
SET user:1:name "John Doe"
GET user:1:name

# Hash örneği
HSET user:1 name "John Doe" age 30 email "john@example.com"
HGETALL user:1

# List örneği
LPUSH queue:jobs "job1"
LPUSH queue:jobs "job2"
LRANGE queue:jobs 0 -1

# Set örneği
SADD tags:1 "java" "spring" "redis"
SMEMBERS tags:1

# Sorted Set örneği
ZADD leaderboard 100 "player1" 200 "player2" 150 "player3"
ZRANGE leaderboard 0 -1 WITHSCORES</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">22. Redis'i caching dışında nasıl kullanırsınız?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Session store, Rate limiting (token bucket), Pub/Sub messaging,
                                Distributed locks.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Session Store:</strong> Web uygulamalarında kullanıcı oturum bilgilerini
                                    saklamak için kullanılır. Birden fazla sunucu arasında oturum bilgilerini paylaşmak
                                    için idealdir.</li>
                                <li><strong>Rate Limiting:</strong> API isteklerini sınırlamak için kullanılır. Token
                                    bucket veya sliding window algoritmaları ile implemente edilebilir.</li>
                                <li><strong>Pub/Sub Messaging:</strong> Mesajlaşma sistemi olarak kullanılır. Bir
                                    publisher, kanala mesaj yayınlar ve tüm subscriber'lar bu mesajı alır.</li>
                                <li><strong>Distributed Locks:</strong> Dağıtık sistemlerde kaynaklara erişimi kontrol
                                    etmek için kullanılır. Redlock algoritması ile güvenli kilit mekanizması
                                    oluşturulabilir.</li>
                                <li><strong>Counter ve Analytics:</strong> Gerçek zamanlı sayaçlar ve istatistikler için
                                    kullanılır. INCR, INCRBY komutları ile atomik artırma işlemleri yapılabilir.</li>
                                <li><strong>Geospatial Veriler:</strong> Konum tabanlı verileri saklamak ve sorgulamak
                                    için kullanılır. GEOADD, GEORADIUS komutları ile yakın lokasyonlar bulunabilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Session store örneği
SET session:abcd1234 "user:123" EX 3600
GET session:abcd1234

# Rate limiting örneği (token bucket)
MULTI
INCR user:123:api:count
EXPIRE user:123:api:count 60
EXEC
# Sonuç 10'dan büyükse erişimi engelle

# Pub/Sub örneği
SUBSCRIBE notifications
PUBLISH notifications "Yeni mesajınız var"

# Distributed lock örneği
SET lock:resource1 "unique_value" NX PX 30000
# İşlem bittiğinde
EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 lock:resource1 "unique_value"</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">23. Redis Cluster ve Sentinel farkı</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Sentinel → HA, failover. Cluster → sharding + HA, scale-out.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <table class="min-w-full divide-y divide-gray-200 mt-3">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Özellik</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Redis Sentinel</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Redis Cluster</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Amaç</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Yüksek erişilebilirlik (HA) ve failover
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">Veri bölümlendirme (sharding) ve
                                            ölçeklenebilirlik</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Mimari</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Master-slave replikasyon + Sentinel'ler
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">16384 hash slot bölümlü mimari</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Veri Dağıtımı</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Tüm veri master'da, slave'lerde kopya
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">Veri farklı node'lara bölünmüş (sharded)
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Ölçeklenebilirlik</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Okuma işlemleri için ölçeklenebilir
                                            (slave'ler)</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Hem okuma hem yazma için ölçeklenebilir
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Karmaşıklık</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Daha az karmaşık, kurulumu kolay</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Daha karmaşık, yönetimi zordur</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">24. Redis persistence seçenekleri</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">RDB → snapshot, scheduled saves. AOF → append-only log, every write
                                recorded. Hybrid → RDB + AOF.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>RDB (Redis Database):</strong> Belirli zaman aralıklarında veritabanının
                                    anlık görüntüsünü (snapshot) diske yazar. Daha küçük dosya boyutu, daha hızlı
                                    yeniden başlatma sağlar. Ancak son iki snapshot arasındaki veriler kaybolabilir.
                                </li>
                                <li><strong>AOF (Append Only File):</strong> Her yazma işlemini log dosyasına ekler.
                                    Daha fazla veri güvenliği sağlar, ancak dosya boyutu RDB'den daha büyüktür. AOF
                                    dosyası büyüdükçe otomatik olarak yeniden yazılabilir.</li>
                                <li><strong>Hybrid (RDB + AOF):</strong> Hem RDB hem AOF'nin avantajlarını birleştirir.
                                    Yeniden başlatma için RDB kullanılır, son durum için AOF log'u uygulanır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Redis.conf dosyasında persistence ayarları

# RDB ayarları
save 900 1      # 900 saniye içinde en az 1 değişiklik olursa kaydet
save 300 10     # 300 saniye içinde en az 10 değişiklik olursa kaydet
save 60 10000   # 60 saniye içinde en az 10000 değişiklik olursa kaydet

# AOF ayarları
appendonly yes      # AOF'yi etkinleştir
appendfilename "appendonly.aof"
appendfsync everysec   # Her saniye diske yaz
no-appendfsync-on-rewrite no   # Rewrite sırasında fsync'i durdurma

# Hybrid persistence
aof-use-rdb-preamble yes   # AOF dosyasının başına RDB formatı ekle</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">25. Redis ile distributed lock nasıl yapılır?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">SET key value NX PX <timeout>. Redlock algorithm önerilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Basit Lock:</strong> SET komutunu NX (Not eXists) ve PX (expire in
                                    milliseconds) parametreleri ile kullanarak basit bir distributed lock
                                    oluşturulabilir.</li>
                                <li><strong>Redlock Algorithm:</strong> Redis yaratıcısı Salvatore Sanfilippo tarafından
                                    önerilen, birden fazla Redis master'ı kullanarak daha güvenli bir distributed lock
                                    algoritmasıdır.</li>
                                <li><strong>Lock Süresi:</strong> Lock'un expire süresi, işlemin maksimum tamamlanma
                                    süresinden biraz daha uzun olmalıdır.</li>
                                <li><strong>Lock Açma:</strong> Lock'u açarken, sadece sahibi olan client'ın açabilmesi
                                    için atomic komutlar kullanılmalıdır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Basit Redis lock
SET lock:resource1 "unique_value" NX PX 30000

# Lock'u kontrol etme ve açma (atomik işlem)
EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 lock:resource1 "unique_value"

# Redlock algoritması örneği (Redisson kütüphanesi)
Config config = new Config();
config.useSingleServer().setAddress("redis://localhost:6379");
RedissonClient redisson = Redisson.create(config);

RLock lock = redisson.getLock("myLock");
try {
    // Lock'u 10 saniye bekle, 30 saniye otomatik aç
    boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
    if (locked) {
        // Kritik bölge
        System.out.println("Lock alındı, işlem yapılıyor...");
    }
} finally {
    lock.unlock();
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ElasticSearch Soruları -->
                <div id="elasticsearch" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">ElasticSearch Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">31. ElasticSearch nedir, kullanım alanları</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Full-text search engine, analytics. JSON document indexleme. Log
                                analizi, search API, autocomplete.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>ElasticSearch:</strong> Apache Lucene tabanlı, dağıtık bir full-text arama
                                    ve analiz motorudur. JSON formatında belgeleri indeksler ve karmaşık sorguları hızlı
                                    bir şekilde işler.</li>
                                <li><strong>Kullanım Alanları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Full-text arama motorları (e-ticaret, içerik platformları)</li>
                                        <li>Log analizi ve monitoring (ELK Stack: ElasticSearch, Logstash, Kibana)</li>
                                        <li>Business intelligence ve veri analizi</li>
                                        <li>Uygulama performans monitoring</li>
                                        <li>Coğrafi veri arama ve analizi</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Dağıtık mimari ile yüksek ölçeklenebilirlik</li>
                                        <li>Gerçek zamanlı veri işleme</li>
                                        <li>Karmaşık sorgu yetenekleri</li>
                                        <li>Yüksek erişilebilirlik ve dayanıklılık</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># ElasticSearch cluster başlatma
# Docker ile
docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:8.11.0

# Basit indeks oluşturma ve belge ekleme
PUT /products
{
  "mappings": {
    "properties": {
      "name": {"type": "text"},
      "description": {"type": "text"},
      "price": {"type": "float"},
      "category": {"type": "keyword"}
    }
  }
}

POST /products/_doc/1
{
  "name": "Laptop",
  "description": "High performance laptop",
  "price": 1299.99,
  "category": "Electronics"
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">32. Index, type, document nedir</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Index → table karşılığı. Type → category (deprecated ES 7+).
                                Document → JSON veri birimi.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Index:</strong> ElasticSearch'teki verilerin mantıksal olarak gruplandığı
                                    birimdir. İlişkisel veritabanlarındaki "table" kavramına benzer. Bir veya daha fazla
                                    shard'dan oluşur.</li>
                                <li><strong>Type:</strong> Bir index içindeki belgeleri kategorize etmek için kullanılan
                                    bir kavramdır. ElasticSearch 7.0 ve sonraki sürümlerde deprecated olmuştur ve 8.0'da
                                    tamamen kaldırılmıştır. İlişkisel veritabanlarındaki "tablo içindeki alt tablo"
                                    kavramına benzer.</li>
                                <li><strong>Document:</strong> ElasticSearch'te saklanan temel veri birimidir. JSON
                                    formatında olur ve bir veya daha fazla field içerir. İlişkisel veritabanlarındaki
                                    "satır" kavramına benzer.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Index oluşturma
PUT /products

# Document ekleme
POST /products/_doc/1
{
  "name": "Smartphone",
  "description": "Latest model with 5G",
  "price": 899.99,
  "category": "Electronics",
  "stock": 100
}

# Document sorgulama
GET /products/_doc/1

# Tüm index'leri listeleme
GET /_cat/indices?v</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">33. ElasticSearch CRUD Spring Boot</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Spring Data Elasticsearch kullanılır. Repository interface →
                                ElasticsearchRepository<T,ID>. Flux/Mono ile reactive REST query yapılabilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Data ElasticSearch:</strong> Spring Boot uygulamalarında
                                    ElasticSearch ile entegrasyonu kolaylaştıran bir projedir. Repository pattern
                                    kullanarak veri erişimi sağlar.</li>
                                <li><strong>ElasticsearchRepository:</strong> Temel CRUD operasyonlarını ve özel
                                    sorguları tanımlamak için kullanılan interface'dir.</li>
                                <li><strong>Reactive Entegrasyon:</strong> Spring WebFlux ile reactive programlama için
                                    ReactiveElasticsearchRepository kullanılabilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>

# application.properties
spring.elasticsearch.uris=http://localhost:9200

# Document sınıfı
@Document(indexName = "products")
public class Product {
    @Id
    private String id;
    private String name;
    private String description;
    private double price;
    private String category;
    
    // getters, setters
}

# Repository interface
public interface ProductRepository extends ElasticsearchRepository<Product, String> {
    List<Product> findByName(String name);
    List<Product> findByCategory(String category);
}

# Service sınıfı
@Service
public class ProductService {
    private final ProductRepository productRepository;
    
    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }
    
    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }
    
    public Optional<Product> findById(String id) {
        return productRepository.findById(id);
    }
    
    public List<Product> findByName(String name) {
        return productRepository.findByName(name);
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">34. ElasticSearch bulk API neden kullanılır</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Çoklu insert/update → network ve performance optimize. Chunk'larla
                                gönderilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Bulk API:</strong> ElasticSearch'te birden fazla belgeyi tek bir istekte
                                    indeksleme, güncelleme veya silme işlemi için kullanılan bir API'dir.</li>
                                <li><strong>Performans Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Ağ gecikmesini azaltır (tek istek yerine çoklu işlem)</li>
                                        <li>ElasticSearch'in batch processing optimizasyonlarından faydalanır</li>
                                        <li>İndeksleme işlemlerini hızlandırır</li>
                                    </ul>
                                </li>
                                <li><strong>Kullanım Alanları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Büyük veri setlerinin aktarımı</li>
                                        <li>Veri migrasyonu</li>
                                        <li>Log verilerinin toplanması</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Bulk API kullanımı
POST /_bulk
{ "index" : { "_index" : "products", "_id" : "1" } }
{ "name" : "Laptop", "description" : "High performance", "price" : 1299.99, "category" : "Electronics" }
{ "index" : { "_index" : "products", "_id" : "2" } }
{ "name" : "Smartphone", "description" : "Latest model", "price" : 899.99, "category" : "Electronics" }
{ "index" : { "_index" : "products", "_id" : "3" } }
{ "name" : "Tablet", "description" : "10 inch display", "price" : 499.99, "category" : "Electronics" }

# Java ile Bulk API kullanımı (Spring Data Elasticsearch)
@Service
public class BulkIndexService {
    private final ElasticsearchOperations elasticsearchOperations;
    
    public BulkIndexService(ElasticsearchOperations elasticsearchOperations) {
        this.elasticsearchOperations = elasticsearchOperations;
    }
    
    public void bulkIndex(List<Product> products) {
        List<IndexQuery> queries = products.stream()
            .map(product -> new IndexQueryBuilder()
                .withId(product.getId())
                .withObject(product)
                .build())
            .collect(Collectors.toList());
            
        elasticsearchOperations.bulkIndex(queries);
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">35. ElasticSearch replikasyon ve shard</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Shard → index partition. Replica → failover ve read scalability.
                                Optimize index + search performansı.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Shard:</strong> Bir index'in bölünmüş parçalarıdır. Her shard, bir Lucene
                                    index'idir ve ElasticSearch cluster'ındaki farklı node'larda dağıtılabilir.
                                    Shard'lar, veriyi yatay olarak böler ve paralel işlemeye olanak tanır.</li>
                                <li><strong>Primary Shard:</strong> Orijinal veriyi içeren shard'dır. Her index,
                                    oluşturulurken belirlenen sayıda primary shard içerir ve bu sayı daha sonra
                                    değiştirilemez.</li>
                                <li><strong>Replica Shard:</strong> Primary shard'ın kopyasıdır. Veri güvenliği ve okuma
                                    performansı için kullanılır. Replica sayısı dinamik olarak değiştirilebilir.</li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Yüksek erişilebilirlik (bir node çöktüğünde replica devreye girer)</li>
                                        <li>Okuma performansını artırma (sorgular paralel olarak çalışabilir)</li>
                                        <li>Yüksek veri güvenliği (veri birden fazla shard'da kopyalanır)</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre># Index oluşturma ve shard ayarları
PUT /my_index
{
  "settings": {
    "index": {
      "number_of_shards": 3,      # Primary shard sayısı
      "number_of_replicas": 2     # Her primary shard için replica sayısı
    }
  },
  "mappings": {
    "properties": {
      "title": {"type": "text"},
      "content": {"type": "text"}
    }
  }
}

# Shard ve replica bilgilerini görme
GET /my_index/_settings

# Cluster sağlık durumu
GET /_cluster/health?pretty

# Shard durumunu görme
GET /_cat/shards/my_index?v</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spring Cloud & Microservices Soruları -->
                <div id="spring-cloud" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Spring Cloud & Microservices Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">16. Spring Cloud Config Server nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Microservices için merkezi konfig yönetimi. Config Git repo
                                üzerinden servisler tarafından alınabilir. @RefreshScope ile runtime config update
                                mümkün.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Cloud Config Server:</strong> Mikroservis mimarilerinde
                                    konfigürasyonları merkezi olarak yönetmek için kullanılan bir araçtır. Konfigürasyon
                                    dosyaları genellikle Git, SVN veya yerel dosya sisteminde saklanır.</li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Ortam bazlı konfigürasyon yönetimi (dev, test, prod)</li>
                                        <li>Çalışma zamanında konfigürasyon güncelleme</li>
                                        <li>Sürüm kontrolü ile konfigürasyon değişikliklerini takip etme</li>
                                        <li>Güvenli konfigürasyon yönetimi (şifreli bilgiler)</li>
                                    </ul>
                                </li>
                                <li><strong>@RefreshScope:</strong> Bu anotasyon, konfigürasyon değişikliklerinin servis
                                    yeniden başlatılmadan uygulanmasını sağlar.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Config Server için Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>

# Config Server uygulama sınıfı
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}

# application.properties
server.port=8888
spring.cloud.config.server.git.uri=https://github.com/username/config-repo
spring.cloud.config.server.git.clone-on-start=true

# Client tarafında (mikroservis)
<!-- Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>

# bootstrap.properties
spring.cloud.config.uri=http://localhost:8888
spring.cloud.config.name=application
spring.cloud.config.profile=dev

# Konfigürasyon sınıfında refreshable alan
@RefreshScope
@RestController
public class GreetingController {
    @Value("${message:Hello default}")
    private String message;
    
    @GetMapping("/message")
    public String getMessage() {
        return message;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">17. Spring Cloud Eureka nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Service discovery / registry. Client → kendini register eder, diğer
                                servisleri bulur.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Cloud Eureka:</strong> Netflix Eureka tabanlı bir service discovery
                                    mekanizmasıdır. Mikroservislerin birbirlerini bulmasını ve iletişim kurmasını
                                    sağlar.</li>
                                <li><strong>Çalışma Prensibi:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Eureka Server: Servis kayıt defteri olarak çalışır</li>
                                        <li>Eureka Client: Mikroservislerin kendilerini Eureka Server'a kaydetmesini ve
                                            diğer servisleri bulmasını sağlar</li>
                                        <li>Her servis, başladığında Eureka Server'a kendini kaydeder</li>
                                        <li>Servisler arası iletişimde, servis isimleri kullanılır ve Eureka bu isimleri
                                            fiziksel adreslere çözümler</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Dinamik servis keşfi</li>
                                        <li>Yüksek erişilebilirlik</li>
                                        <li>Load balancing desteği</li>
                                        <li>Hizmet kesintisi durumunda tolerans</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Eureka Server için Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

# Eureka Server uygulama sınıfı
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

# Eureka Server application.properties
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

# Eureka Client için Maven dependency
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

# Eureka Client application.properties
spring.application.name=product-service
server.port=8080
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

# Servis keşfi ile diğer servislere erişim
@RestController
public class ProductController {
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping("/products/{id}")
    public Product getProduct(@PathVariable Long id) {
        // Service discovery kullanarak diğer servislere erişim
        List<ServiceInstance> instances = discoveryClient.getInstances("inventory-service");
        if (instances != null && !instances.isEmpty()) {
            ServiceInstance serviceInstance = instances.get(0);
            String url = serviceInstance.getUri().toString() + "/inventory/" + id;
            Inventory inventory = restTemplate.getForObject(url, Inventory.class);
            // ...
        }
        // ...
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">18. Spring Cloud Gateway vs Zuul</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Zuul → blocking, servlet based. Gateway → reactive, non-blocking,
                                filtre + route destekli.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <table class="min-w-full divide-y divide-gray-200 mt-3">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Özellik</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Zuul</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Spring Cloud Gateway</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Temel Teknoloji</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Servlet, blocking I/O</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Spring WebFlux, reactive, non-blocking
                                            I/O</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Performans</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Düşük ila orta yük için uygun</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Yüksek yük için daha iyi performans</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Filtreleme</td>
                                        <td class="px-6 py-4 whitespace-nowrap">ZuulFilters</td>
                                        <td class="px-6 py-4 whitespace-nowrap">GatewayFilter, GlobalFilter</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Programlama Modeli</td>
                                        <td class="px-6 py-4 whitespace-nowrap">İmperatif (komutcu)</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Declarative (bildirimsel) ve functional
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Entegrasyon</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Netflix OSS ekosistemi ile entegre</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Spring ekosistemi ile daha iyi
                                            entegrasyon</td>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Cloud Gateway için Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

# application.yml
spring:
  cloud:
    gateway:
      routes:
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            - StripPrefix=1
            - name: CircuitBreaker
              args:
                name: productServiceCircuitBreaker
                fallbackUri: forward:/fallback/products
        - id: inventory-service
          uri: lb://inventory-service
          predicates:
            - Path=/api/inventory/**
          filters:
            - StripPrefix=1

# Gateway uygulama sınıfı
@SpringBootApplication
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r.path("/api/users/**")
                .filters(f -> f.stripPrefix(1)
                    .addRequestHeader("X-Request-Source", "gateway"))
                .uri("lb://user-service"))
            .build();
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">19. Circuit Breaker ne işe yarar?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Hatalı servis çağrılarını keser. Retry ve fallback mekanizması
                                sağlar. Resilience4j ile uygulanır.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Circuit Breaker:</strong> Dağıtık sistemlerde, bir servisin uzun süre yanıt
                                    vermemesi veya hata vermesi durumunda, diğer servislerin bu hatadan etkilenmesini
                                    önlemek için kullanılan bir desendir.</li>
                                <li><strong>Çalışma Prensibi:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Kapalı (Closed):</strong> Normal durumda, tüm istekler hedef servise
                                            yönlendirilir.</li>
                                        <li><strong>Açık (Open):</strong> Belirli bir eşik değerine ulaşan hata
                                            sayısından sonra, circuit breaker açılır ve tüm istekler engellenir.</li>
                                        <li><strong>Yarı Açık (Half-Open):</strong> Belirli bir süre sonra, circuit
                                            breaker sınırlı sayıda isteğe izin verir. Bu istekler başarılı olursa,
                                            circuit breaker tekrar kapatılır; başarısız olursa, açık kalır.</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Servis kesintilerinin sistem genelinde yayılmasını önler</li>
                                        <li>Kaynak tüketimini azaltır</li>
                                        <li>Fallback mekanizmaları ile kullanıcı deneyimini korur</li>
                                        <li>Sistemin genel dayanıklılığını artırır</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Resilience4j için Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>

# application.yml
resilience4j:
  circuitbreaker:
    configs:
      default:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 10
        slidingWindowType: COUNT_BASED
    instances:
        productService:
          baseConfig: default
          waitDurationInOpenState: 10s
          failureRateThreshold: 60
          slidingWindowSize: 20

# Servis sınıfı
@Service
public class ProductService {
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private CircuitBreakerFactory circuitBreakerFactory;
    
    public Product getProductById(Long id) {
        return circuitBreakerFactory.create("productService")
            .run(() -> {
                String url = "http://product-service/api/products/" + id;
                return restTemplate.getForObject(url, Product.class);
            }, throwable -> {
                // Fallback metodu
                return getFallbackProduct(id);
            });
    }
    
    private Product getFallbackProduct(Long id) {
        // Fallback ürün oluştur
        Product fallbackProduct = new Product();
        fallbackProduct.setId(id);
        fallbackProduct.setName("Fallback Product");
        fallbackProduct.setDescription("Product service is currently unavailable");
        fallbackProduct.setPrice(0.0);
        return fallbackProduct;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">20. API rate limiting nasıl yapılır?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Token bucket / Leaky bucket. Redis kullanılarak dağıtık rate
                                limiting.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Rate Limiting:</strong> API'ların belirli bir zaman diliminde alabileceği
                                    istek sayısını sınırlamak için kullanılan bir tekniktir. Bu, servisleri aşırı
                                    yüklenmeden korur ve kötüye kullanımı önler.</li>
                                <li><strong>Algoritmalar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Token Bucket:</strong> Belirli bir kapasiteye sahip bir "kova" ve bu
                                            kovaya belirli aralıklarla eklenen "token"lar kullanılır. Her istek için bir
                                            token gerekir ve token yoksa istek reddedilir.</li>
                                        <li><strong>Leaky Bucket:</strong> İstekler bir kovaya eklenir ve kovadan sabit
                                            bir hızla sızdırılır. Kova doluysa yeni istekler reddedilir.</li>
                                        <li><strong>Fixed Window Counter:</strong> Belirli zaman pencerelerinde istek
                                            sayısını sınırlar.</li>
                                        <li><strong>Sliding Window Log:</strong> Her istek zaman damgası ile kaydedilir
                                            ve belirli bir zaman dilimindeki istek sayısı kontrol edilir.</li>
                                    </ul>
                                </li>
                                <li><strong>Dağıtık Rate Limiting:</strong> Mikroservis mimarilerinde, birden fazla
                                    servis örneği arasında tutarlı rate limiting sağlamak için Redis gibi merkezi bir
                                    veri deposu kullanılır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Cloud Gateway ile rate limiting -->
# application.yml
spring:
  cloud:
    gateway:
      routes:
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                key-resolver: "#{@userKeyResolver}"
                
# KeyResolver bean tanımı
@Configuration
public class RateLimiterConfig {
    @Bean
    public KeyResolver userKeyResolver() {
        // IP adresine göre rate limiting
        return exchange -> {
            String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
            return Mono.just(clientIp);
        };
        
        // Kullanıcı kimliğine göre rate limiting
        /*
        return exchange -> {
            return exchange.getPrincipal()
                .map(Principal::getName)
                .defaultIfEmpty("anonymous");
        };
        */
    }
}

# Redis ile özel rate limiting implementasyonu
@Service
public class RateLimiterService {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String RATE_LIMITER_PREFIX = "rate_limiter:";
    private static final int REQUEST_LIMIT = 100;
    private static final int TIME_WINDOW = 60; // 60 saniye
    
    public boolean allowRequest(String key) {
        String redisKey = RATE_LIMITER_PREFIX + key;
        
        // Redis'de geçerli zaman dilimindeki istek sayısını al
        Long currentCount = redisTemplate.opsForValue().increment(redisKey);
        
        if (currentCount != null && currentCount == 1) {
            // İlk istek, expire zamanı ayarla
            redisTemplate.expire(redisKey, TIME_WINDOW, TimeUnit.SECONDS);
        }
        
        // İstek sayısı limiti aştı mı kontrol et
        return currentCount != null && currentCount <= REQUEST_LIMIT;
    }
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spring Boot & Core Soruları -->
                <div id="spring-boot" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Spring Boot & Core Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">1. Spring Boot starter'ları ne işe yarar?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Uygulamayı hızlı başlatmak için bağımlılıkları gruplar. Örn:
                                spring-boot-starter-web → Spring MVC + Tomcat + JSON support.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Boot Starter'lar:</strong> Spring Boot uygulamaları için gerekli
                                    bağımlılıkları içeren, önceden yapılandırılmış POM dosyalarıdır. Bu sayede
                                    geliştiriciler, her bir bağımlılığı ayrı ayrı yönetmek yerine tek bir starter
                                    ekleyerek ilgili tüm bağımlılıkları projeye dahil edebilirler.</li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Hızlı proje kurulumu</li>
                                        <li>Uygun versiyon uyumu</li>
                                        <li>Gereksiz bağımlılıkları azaltma</li>
                                        <li>Yapılandırma basitleştirme</li>
                                    </ul>
                                </li>
                                <li><strong>Yaygın Starter'lar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>spring-boot-starter-web:</strong> Web uygulamaları için (Spring MVC,
                                            Tomcat, JSON)</li>
                                        <li><strong>spring-boot-starter-data-jpa:</strong> JPA veri erişimi için
                                            (Hibernate, veri kaynakları)</li>
                                        <li><strong>spring-boot-starter-security:</strong> Spring Security için</li>
                                        <li><strong>spring-boot-starter-test:</strong> Testler için (JUnit, Mockito)
                                        </li>
                                        <li><strong>spring-boot-starter-actuator:</strong> Üretim özellikleri için
                                            (health, metrics)</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Maven ile Spring Boot Web Starter ekleme -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Bu tek bağımlılık aşağıdaki bağımlılıkları otomatik olarak ekler: -->
<!-- - spring-boot-starter -->
<!-- - spring-boot-starter-json -->
<!-- - spring-boot-starter-tomcat -->
<!-- - spring-web -->
<!-- - spring-webmvc -->
<!-- - ve diğer ilgili bağımlılıklar -->

<!-- Özel Starter oluşturma örneği -->
<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-custom-starter</artifactId>
    <version>1.0.0</version>
</dependency></pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">2. Spring Boot auto-configuration nasıl çalışır?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">@EnableAutoConfiguration + classpath scanning. Beans, classpath ve
                                properties'e göre otomatik konfig.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Auto-configuration:</strong> Spring Boot'un en önemli özelliklerinden
                                    biridir. Classpath'teki bağımlılıklara göre Spring uygulamasını otomatik olarak
                                    yapılandırır.</li>
                                <li><strong>Çalışma Mekanizması:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>@EnableAutoConfiguration:</strong> Bu anotasyon, Spring Boot'un
                                            otomatik yapılandırma mekanizmasını etkinleştirir.</li>
                                        <li><strong>spring.factories:</strong> META-INF/spring.factories dosyasında,
                                            EnableAutoConfiguration anahtarına bağlı olarak yapılandırma sınıfları
                                            listelenir.</li>
                                        <li><strong>@Conditional:</strong> Auto-configuration sınıfları, çeşitli
                                            @Conditional anotasyonlarını kullanarak hangi koşullarda çalışacağını
                                            belirler.</li>
                                    </ul>
                                </li>
                                <li><strong>Yaygın Conditional Anotasyonları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>@ConditionalOnClass:</strong> Belirtilen sınıf classpath'te mevcutsa
                                            bean oluşturur.</li>
                                        <li><strong>@ConditionalOnMissingBean:</strong> Belirtilen türde bir bean
                                            ApplicationContext'te yoksa bean oluşturur.</li>
                                        <li><strong>@ConditionalOnProperty:</strong> Belirtilen özellik belirli bir
                                            değere sahipse bean oluşturur.</li>
                                        <li><strong>@ConditionalOnWebApplication:</strong> Uygulama bir web
                                            uygulamasıysa bean oluşturur.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Otomatik yapılandırma örneği -->
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.url", matchIfMissing = false)
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource(DataSourceProperties properties) {
        return properties.initializeDataSourceBuilder().build();
    }
}

# spring.factories dosyası içeriği
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfigure.DataSourceAutoConfiguration

# application.properties ile yapılandırma
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">3. @SpringBootApplication neyi kapsar?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">@Configuration + @EnableAutoConfiguration + @ComponentScan.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>@SpringBootApplication:</strong> Spring Boot uygulamalarında ana sınıfı
                                    işaretlemek için kullanılan birleşik bir anotasyondur. Bu anotasyon, aşağıdaki üç
                                    anotasyonun işlevselliğini bir araya getirir:</li>
                                <li><strong>@Configuration:</strong> Sınıfın Spring yapılandırma sınıfı olduğunu
                                    belirtir. Bu sınıfta @Bean anotasyonlu metotlar aracılığıyla Spring context'ine
                                    bean'ler eklenebilir.</li>
                                <li><strong>@EnableAutoConfiguration:</strong> Spring Boot'un otomatik yapılandırma
                                    mekanizmasını etkinleştirir. Classpath'teki bağımlılıklara göre uygun bean'leri
                                    otomatik olarak yapılandırır.</li>
                                <li><strong>@ComponentScan:</strong> Belirtilen paket ve alt paketlerindeki @Component,
                                    @Service, @Repository, @Controller gibi anotasyonlu sınıfları tarayarak Spring
                                    context'ine ekler. Varsayılan olarak, bu anotasyonun kullanıldığı sınıfın paketini
                                    tarar.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// @SpringBootApplication kullanımı
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
    
    // @Configuration sayesinde burada bean tanımlayabiliriz
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}

// Ayrı ayrı anotasyonlarla eşdeğer kullanım
@Configuration
@EnableAutoConfiguration
@ComponentScan(basePackages = "com.example")
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">4. Spring Boot Actuator nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Application health, metrics, info endpoint'leri. Custom endpoint
                                oluşturulabilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Boot Actuator:</strong> Spring Boot uygulamalarını izlemek ve
                                    yönetmek için kullanılan bir dizi üretim özelliği sağlar. HTTP endpoint'leri veya
                                    JMX aracılığıyla uygulama hakkında bilgi toplamaya olanak tanır.</li>
                                <li><strong>Temel Özellikleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Health Endpoint:</strong> Uygulamanın sağlık durumunu kontrol eder.
                                        </li>
                                        <li><strong>Metrics Endpoint:</strong> Uygulama metriklerini (memory, CPU, HTTP
                                            istatistikleri vb.) sağlar.</li>
                                        <li><strong>Info Endpoint:</strong> Uygulama bilgilerini (versiyon, git
                                            bilgileri vb.) gösterir.</li>
                                        <li><strong>Environment Endpoint:</strong> Spring Environment'deki özellikleri
                                            gösterir.</li>
                                        <li><strong>Beans Endpoint:</strong> ApplicationContext'teki tüm bean'leri
                                            listeler.</li>
                                        <li><strong>Mappings Endpoint:</strong> Tüm @RequestMapping path'lerini
                                            gösterir.</li>
                                    </ul>
                                </li>
                                <li><strong>Güvenlik:</strong> Actuator endpoint'leri hassas bilgiler içerebileceğinden,
                                    genellikle Spring Security ile korunur ve sadece yetkili kullanıcıların erişimine
                                    açılır.</li>
                                <li><strong>Özelleştirme:</strong> Varsayılan endpoint'ler özelleştirilebilir ve özel
                                    endpoint'ler oluşturulabilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Actuator bağımlılığı -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

# application.properties ile endpoint yapılandırma
# Tüm endpoint'leri açma
management.endpoints.web.exposure.include=*

# Sadece belirli endpoint'leri açma
management.endpoints.web.exposure.include=health,info,metrics

# Health endpoint detaylarını gösterme
management.endpoint.health.show-details=always

# Özel health indicator oluşturma
@Component
public class CustomHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        // Özel sağlık kontrolü
        int errorCode = check(); // özel bir kontrol metodu
        if (errorCode != 0) {
            return Health.down()
                .withDetail("Error Code", errorCode)
                .build();
        }
        return Health.up().build();
    }
    
    private int check() {
        // Uygulamaya özel sağlık kontrolü
        return 0; // 0 = sağlıklı
    }
}

# Özel endpoint oluşturma
@Component
@Endpoint(id = "custom")
public class CustomEndpoint {
    
    @ReadOperation
    public Map<String, Object> customEndpoint() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "OK");
        response.put("timestamp", System.currentTimeMillis());
        return response;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">5. Spring Boot vs Spring MVC</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Boot → production-ready default config + embedded server. MVC →
                                manual konfig ve dependency management.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <table class="min-w-full divide-y divide-gray-200 mt-3">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Özellik</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Spring Boot</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Spring MVC</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Amaç</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Hızlı uygulama geliştirme, konfigürasyon
                                            basitleştirme</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Web uygulamaları için MVC framework'ü
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Konfigürasyon</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Otomatik konfigürasyon, minimum XML</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Manuel konfigürasyon, genellikle XML
                                            veya Java konfigürasyonu</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Sunucu</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Embedded server (Tomcat, Jetty,
                                            Undertow)</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Dış sunucu gerekebilir (WAR dosyası)
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Bağımlılıklar</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Starter POM'lar ile basitleştirilmiş
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">Manuel bağımlılık yönetimi</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Üretim Hazırlığı</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Actuator, health checks, metrics</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Ekstra konfigürasyon gerekli</td>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="code-block mt-3">
                                <pre><!-- Spring MVC ile basit web uygulaması -->
<!-- pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.21</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
    </dependency>
</dependencies>

<!-- web.xml -->
<web-app>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-context.xml</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>

<!-- spring-context.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/mvc
           http://www.springframework.org/schema/mvc/spring-mvc.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">
           
    <context:component-scan base-package="com.example"/>
    <mvc:annotation-driven/>
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
</beans>

<!-- Spring Boot ile aynı uygulama -->
<!-- pom.xml -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.5</version>
</parent>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>

<!-- Application.java -->
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spring Batch Soruları -->
                <div id="spring-batch" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Spring Batch Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">11. Spring Batch temel bileşenleri</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Job → iş akışı. Step → iş adımı. ItemReader, ItemProcessor,
                                ItemWriter → chunk-based processing.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Batch:</strong> Büyük veri setlerini işlemek için tasarlanmış, açık
                                    kaynaklı bir batch processing framework'üdür. İşlem günlükleri, yeniden başlatma,
                                    istatistikler ve kaynak yönetimi gibi özellikler sunar.</li>
                                <li><strong>Temel Bileşenler:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Job:</strong> Batch işleminin tamamını temsil eden en üst düzey
                                            bileşendir. Bir veya daha fazla step'ten oluşur.</li>
                                        <li><strong>Step:</strong> Job'un içindeki mantıksal işlem adımlarıdır. Her
                                            step, ItemReader, ItemProcessor ve ItemWriter bileşenlerini içerir.</li>
                                        <li><strong>ItemReader:</strong> Veri kaynağından verileri okumak için
                                            kullanılır. Veritabanı, dosya, JMS gibi çeşitli kaynaklardan veri
                                            okuyabilir.</li>
                                        <li><strong>ItemProcessor:</strong> Okunan verileri işlemek için kullanılır.
                                            Veri dönüştürme, zenginleştirme, filtreleme gibi işlemler yapabilir.</li>
                                        <li><strong>ItemWriter:</strong> İşlenmiş verileri hedefe yazmak için
                                            kullanılır. Veritabanı, dosya, JMS gibi çeşitli hedeflere veri yazabilir.
                                        </li>
                                    </ul>
                                </li>
                                <li><strong>Chunk-based Processing:</strong> Spring Batch'in en yaygın kullanım
                                    modelidir. Belirli sayıda veri (chunk) okunur, işlenir ve yazılır. Bu işlem chunk
                                    boyutu kadar tekrarlanır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Batch Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-batch</artifactId>
</dependency>

<!-- Job konfigürasyonu -->
@Configuration
@EnableBatchProcessing
public class BatchConfiguration {
    
    @Autowired
    private JobBuilderFactory jobBuilderFactory;
    
    @Autowired
    private StepBuilderFactory stepBuilderFactory;
    
    // ItemReader - veritabanından veri okuma
    @Bean
    public ItemReader<User> reader(DataSource dataSource) {
        return new JdbcCursorItemReaderBuilder<User>()
            .name("userReader")
            .dataSource(dataSource)
            .sql("SELECT id, name, email FROM users")
            .rowMapper(new UserRowMapper())
            .build();
    }
    
    // ItemProcessor - veri işleme
    @Bean
    public ItemProcessor<User, ProcessedUser> processor() {
        return user -> {
            // Veri dönüştürme
            ProcessedUser processedUser = new ProcessedUser();
            processedUser.setId(user.getId());
            processedUser.setFullName(user.getName().toUpperCase());
            processedUser.setEmailDomain(user.getEmail().split("@")[1]);
            return processedUser;
        };
    }
    
    // ItemWriter - veri yazma
    @Bean
    public ItemWriter<ProcessedUser> writer(DataSource dataSource) {
        return new JdbcBatchItemWriterBuilder<ProcessedUser>()
            .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
            .sql("INSERT INTO processed_users (id, full_name, email_domain) VALUES (:id, :fullName, :emailDomain)")
            .dataSource(dataSource)
            .build();
    }
    
    // Step tanımlama
    @Bean
    public Step importUserStep(ItemReader<User> reader, 
                              ItemProcessor<User, ProcessedUser> processor,
                              ItemWriter<ProcessedUser> writer) {
        return stepBuilderFactory.get("importUserStep")
            .<User, ProcessedUser>chunk(100)  // Her seferinde 100 kayıt işle
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .build();
    }
    
    // Job tanımlama
    @Bean
    public Job importUserJob(JobCompletionNotificationListener listener, Step step1) {
        return jobBuilderFactory.get("importUserJob")
            .incrementer(new RunIdIncrementer())
            .listener(listener)
            .flow(step1)
            .end()
            .build();
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">12. Tasklet ve chunk-based farkı</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Tasklet → tek adımlık job, simple task. Chunk → büyük veri
                                setlerini parçalara ayırıp process.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <table class="min-w-full divide-y divide-gray-200 mt-3">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Özellik</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Tasklet</th>
                                        <th
                                            class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                            Chunk-based</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-white divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Kullanım Amacı</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Tek seferlik, basit görevler</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Büyük veri setlerini işlemek</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">İşlem Modeli</td>
                                        <td class="px-6 py-4 whitespace-nowrap">execute() metodu tek seferlik çalışır
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">Oku-İşle-Yaz döngüsü tekrarlanır</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Veri Akışı</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Veri akışı yok, doğrudan işlem yapılır
                                        </td>
                                        <td class="px-6 py-4 whitespace-nowrap">ItemReader → ItemProcessor → ItemWriter
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Örnek Kullanım</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Dosya silme, e-posta gönderme, rapor
                                            oluşturma</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Veritabanı verilerini işleme, CSV
                                            dosyasını okuyup DB'ye yazma</td>
                                    </tr>
                                    <tr>
                                        <td class="px-6 py-4 whitespace-nowrap">Transaction Yönetimi</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Tek transaction</td>
                                        <td class="px-6 py-4 whitespace-nowrap">Her chunk için ayrı transaction</td>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="code-block mt-3">
                                <pre>// Tasklet örneği
@Component
public class FileDeletingTasklet implements Tasklet {
    
    private String directoryPath;
    
    public FileDeletingTasklet(String directoryPath) {
        this.directoryPath = directoryPath;
    }
    
    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        File directory = new File(directoryPath);
        File[] files = directory.listFiles();
        
        if (files != null) {
            for (File file : files) {
                if (file.delete()) {
                    System.out.println("Deleted file: " + file.getName());
                }
            }
        }
        
        return RepeatStatus.FINISHED;
    }
}

// Tasklet step konfigürasyonu
@Bean
public Step deleteFilesStep(FileDeletingTasklet tasklet) {
    return stepBuilderFactory.get("deleteFilesStep")
        .tasklet(tasklet)
        .build();
}

// Chunk-based step konfigürasyonu
@Bean
public Step processUsersStep(ItemReader<User> reader, 
                           ItemProcessor<User, ProcessedUser> processor,
                           ItemWriter<ProcessedUser> writer) {
    return stepBuilderFactory.get("processUsersStep")
        .<User, ProcessedUser>chunk(100)  // Her seferinde 100 kayıt işle
        .reader(reader)
        .processor(processor)
        .writer(writer)
        .build();
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">13. JobParameters ve ExecutionContext</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">JobParameters → job instance'ları için parametre. ExecutionContext
                                → job step'leri arasında state saklama.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>JobParameters:</strong> Bir job çalıştırıldığında girilen parametrelerdir.
                                    Her JobInstance, benzersiz JobParameters kombinasyonu ile tanımlanır. Bu sayede aynı
                                    job farklı parametrelerle birden fazla kez çalıştırılabilir.</li>
                                <li><strong>ExecutionContext:</strong> Job veya Step çalışması sırasında oluşan durum
                                    bilgilerini saklamak için kullanılır. JobExecutionContext tüm job boyunca,
                                    StepExecutionContext ise sadece ilgili step boyunca geçerlidir.</li>
                                <li><strong>Farkları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>JobParameters job başlamadan önce belirlenir ve sonradan değiştirilemez.
                                        </li>
                                        <li>ExecutionContext job veya step çalışması sırasında dinamik olarak
                                            değiştirilebilir.</li>
                                        <li>JobParameters job instance'ı benzersiz kılar.</li>
                                        <li>ExecutionContext job veya step'in durumunu takip eder ve yeniden başlatma
                                            için kullanılır.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// JobParameters kullanımı
@Component
public class JobParameterDemo implements StepExecutionListener {
    
    private String inputFile;
    private String outputFile;
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        JobParameters jobParameters = stepExecution.getJobParameters();
        this.inputFile = jobParameters.getString("inputFile");
        this.outputFile = jobParameters.getString("outputFile");
        
        System.out.println("Input file: " + inputFile);
        System.out.println("Output file: " + outputFile);
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return null;
    }
}

// ExecutionContext kullanımı
@Component
public class ExecutionContextDemo implements StepExecutionListener {
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        // StepExecutionContext'e veri ekleme
        ExecutionContext stepContext = stepExecution.getExecutionContext();
        stepContext.put("startTime", System.currentTimeMillis());
        stepContext.put("processedCount", 0);
        
        // JobExecutionContext'e veri ekleme
        JobExecution jobExecution = stepExecution.getJobExecution();
        ExecutionContext jobContext = jobExecution.getExecutionContext();
        jobContext.put("jobStartTime", System.currentTimeMillis());
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        // ExecutionContext'ten veri okuma
        ExecutionContext stepContext = stepExecution.getExecutionContext();
        Long startTime = stepContext.getLong("startTime");
        Integer processedCount = stepContext.getInt("processedCount");
        
        Long duration = System.currentTimeMillis() - startTime;
        System.out.println("Step processed " + processedCount + " records in " + duration + " ms");
        
        return null;
    }
}

// ItemProcessor içinde ExecutionContext kullanımı
@Component
public class TrackingItemProcessor implements ItemProcessor<User, ProcessedUser>, StepExecutionListener {
    
    private StepExecution stepExecution;
    
    @Override
    public ProcessedUser process(User user) throws Exception {
        // İşlenen kayıt sayısını artır
        ExecutionContext stepContext = stepExecution.getExecutionContext();
        int processedCount = stepContext.getInt("processedCount", 0) + 1;
        stepContext.putInt("processedCount", processedCount);
        
        // Veri işleme
        ProcessedUser processedUser = new ProcessedUser();
        processedUser.setId(user.getId());
        processedUser.setFullName(user.getName().toUpperCase());
        
        return processedUser;
    }
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return null;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">14. Retry ve skip mekanizması</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Fault tolerance için item-level retry. Skip policy ile hatalı kayıt
                                geçilebilir.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Retry Mekanizması:</strong> Spring Batch'te, bir item işlenirken hata
                                    oluştuğunda, o item'ı belirli bir sayıda yeniden deneme mekanizmasıdır. Bu, geçici
                                    hataların (veritabanı bağlantı sorunları, ağ sorunları vb.) neden olduğu işleme
                                    hatalarını aşmak için kullanılır.</li>
                                <li><strong>Skip Mekanizması:</strong> Bir item işlenirken sürekli hata veriyorsa, bu
                                    item'ı atlayarak işleme devam etme mekanizmasıdır. Bu, bozuk verilerin tüm işlemin
                                    durmasına engel olur.</li>
                                <li><strong>Kullanım Alanları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Retry:</strong> Geçici hatalar için (veritabanı deadlock, network
                                            timeout)</li>
                                        <li><strong>Skip:</strong> Kalıcı hatalar için (bozuk veri formatı, geçersiz
                                            veri)</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// Retry ve skip konfigürasyonu
@Bean
public Step processUsersStep(ItemReader<User> reader, 
                           ItemProcessor<User, ProcessedUser> processor,
                           ItemWriter<ProcessedUser> writer) {
    return stepBuilderFactory.get("processUsersStep")
        .<User, ProcessedUser>chunk(100)
        .reader(reader)
        .processor(processor)
        .writer(writer)
        .faultTolerant()  // Hata toleransını etkinleştir
        .retryLimit(3)    // Her item için maksimum 3 kez yeniden dene
        .retry(DataIntegrityViolationException.class)  // Sadece bu hata türünde retry yap
        .skipLimit(10)    // Maksimum 10 item'ı skip et
        .skip(InvalidDataException.class)  // Sadece bu hata türünde skip yap
        .noSkip(ItemNotFoundException.class)  // Bu hata türünde skip yapma
        .listener(skipListener())  // Skip olaylarını dinle
        .build();
}

@Bean
public SkipListener<User, ProcessedUser> skipListener() {
    return new SkipListener<User, ProcessedUser>() {
        @Override
        public void onSkipInRead(Throwable t) {
            System.out.println("READ SKIP: " + t.getMessage());
        }
        
        @Override
        public void onSkipInWrite(ProcessedUser item, Throwable t) {
            System.out.println("WRITE SKIP: " + item + ", ERROR: " + t.getMessage());
        }
        
        @Override
        public void onSkipInProcess(User item, Throwable t) {
            System.out.println("PROCESS SKIP: " + item + ", ERROR: " + t.getMessage());
        }
    };
}

// Özel retry politikası
@Bean
public RetryTemplate retryTemplate() {
    RetryTemplate retryTemplate = new RetryTemplate();
    
    // Retry politikası
    SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
    retryPolicy.setMaxAttempts(3);
    
    // Backoff politikası
    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
    backOffPolicy.setInitialInterval(100);
    backOffPolicy.setMultiplier(2.0);
    backOffPolicy.setMaxInterval(2000);
    
    retryTemplate.setRetryPolicy(retryPolicy);
    retryTemplate.setBackOffPolicy(backOffPolicy);
    
    return retryTemplate;
}

// ItemProcessor içinde retry kullanımı
@Component
public class RetryItemProcessor implements ItemProcessor<User, ProcessedUser> {
    
    @Autowired
    private RetryTemplate retryTemplate;
    
    @Override
    public ProcessedUser process(User user) throws Exception {
        return retryTemplate.execute(context -> {
            // İşlemi dene
            return processWithRetry(user);
        });
    }
    
    private ProcessedUser processWithRetry(User user) throws Exception {
        // Burada gerçek iş mantığı
        if (user.getName() == null || user.getName().isEmpty()) {
            throw new InvalidDataException("User name cannot be empty");
        }
        
        ProcessedUser processedUser = new ProcessedUser();
        processedUser.setId(user.getId());
        processedUser.setFullName(user.getName().toUpperCase());
        
        // Veritabanı işlemi simülasyonu
        if (Math.random() < 0.1) {  // %10 ihtimalle hata
            throw new DataIntegrityViolationException("Database constraint violation");
        }
        
        return processedUser;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">15. Parallel step execution</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Multi-threaded Step. Partitioning → büyük veri setlerini paralel
                                step'lerde işleme.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Parallel Processing:</strong> Spring Batch'te, işlemleri paralelleştirerek
                                    performansı artırmak için kullanılan bir tekniktir. İki ana yaklaşım vardır:
                                    Multi-threaded Step ve Partitioning.</li>
                                <li><strong>Multi-threaded Step:</strong> Aynı step içindeki chunk'ları farklı
                                    thread'lerde paralel olarak işlemek için kullanılır. Bu, genellikle CPU-bound
                                    işlemler için uygundur.</li>
                                <li><strong>Partitioning:</strong> Büyük veri setlerini daha küçük parçalara (partition)
                                    bölerek, her bir parçayı ayrı bir worker step'te işlemek için kullanılır. Bu,
                                    genellikle I/O-bound işlemler için uygundur.</li>
                                <li><strong>Farkları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Multi-threaded Step, tek bir step içinde paralelleştirme sağlar.</li>
                                        <li>Partitioning, birden fazla step oluşturarak paralelleştirme sağlar.</li>
                                        <li>Partitioning, uzak sistemlerde (grid computing) çalışmaya daha uygundur.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// Multi-threaded Step konfigürasyonu
@Bean
public Step multiThreadedStep(ItemReader<User> reader, 
                             ItemProcessor<User, ProcessedUser> processor,
                             ItemWriter<ProcessedUser> writer) {
    return stepBuilderFactory.get("multiThreadedStep")
        .<User, ProcessedUser>chunk(100)
        .reader(reader)
        .processor(processor)
        .writer(writer)
        .taskExecutor(taskExecutor())  // TaskExecutor belirt
        .throttleLimit(20)  // Maksimum eş zamanlı thread sayısı
        .build();
}

@Bean
public TaskExecutor taskExecutor() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.setCorePoolSize(5);
    taskExecutor.setMaxPoolSize(10);
    taskExecutor.setQueueCapacity(25);
    taskExecutor.setThreadNamePrefix("Batch-Thread-");
    taskExecutor.initialize();
    return taskExecutor;
}

// Partitioning konfigürasyonu
// 1. Partitioner oluşturma
@Bean
public Partitioner partitioner() {
    return new Partitioner() {
        @Override
        public Map<String, ExecutionContext> partition(int gridSize) {
            Map<String, ExecutionContext> result = new HashMap<>();
            
            // Veritabanından min ve max ID'leri al
            int minId = jdbcTemplate.queryForObject("SELECT MIN(id) FROM users", Integer.class);
            int maxId = jdbcTemplate.queryForObject("SELECT MAX(id) FROM users", Integer.class);
            
            int range = (maxId - minId) / gridSize + 1;
            
            for (int i = 0; i < gridSize; i++) {
                ExecutionContext value = new ExecutionContext();
                value.putInt("minValue", minId + (i * range));
                value.putInt("maxValue", minId + ((i + 1) * range) - 1);
                result.put("partition" + i, value);
            }
            
            return result;
        }
    };
}

// 2. Partition step konfigürasyonu
@Bean
public Step partitionStep(Partitioner partitioner) {
    return stepBuilderFactory.get("partitionStep")
        .partitioner(workerStep().getName(), partitioner)
        .step(workerStep())
        .gridSize(4)  // 4 partition oluştur
        .taskExecutor(taskExecutor())
        .build();
}

// 3. Worker step konfigürasyonu
@Bean
public Step workerStep() {
    return stepBuilderFactory.get("workerStep")
        .<User, ProcessedUser>chunk(100)
        .reader(partitionedItemReader(null))  // ExecutionContext'ten oku
        .processor(processor())
        .writer(writer())
        .build();
}

// 4. Partitioned ItemReader
@Bean
@StepScope
public ItemReader<User> partitionedItemReader(
        @Value("#{stepExecutionContext['minValue']}") int minValue,
        @Value("#{stepExecutionContext['maxValue']}") int maxValue) {
    
    return new JdbcCursorItemReaderBuilder<User>()
        .name("partitionedUserReader")
        .dataSource(dataSource)
        .sql("SELECT id, name, email FROM users WHERE id BETWEEN " + minValue + " AND " + maxValue)
        .rowMapper(new UserRowMapper())
        .build();
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spring Caching & AOP / Events Soruları -->
                <div id="spring-caching" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Spring Caching & AOP / Events Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">21. Spring Cache abstraction kullanımı</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">@Cacheable, @CachePut, @CacheEvict. Ehcache, Redis, Caffeine
                                entegrasyonu.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Cache Abstraction:</strong> Spring, farklı cache sağlayıcılarını
                                    (Ehcache, Redis, Caffeine, Hazelcast vb.) kullanmak için tutarlı bir arayüz sağlar.
                                    Bu sayede uygulama kodu değiştirmeden farklı cache implementasyonları arasında geçiş
                                    yapabilirsiniz.</li>
                                <li><strong>Temel Anotasyonlar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>@Cacheable:</strong> Metodu cache'lemek için kullanılır. Metot
                                            çağrıldığında önce cache kontrol edilir, eğer sonuç cache'te varsa metot
                                            çalıştırılmadan cache'teki sonuç döndürülür.</li>
                                        <li><strong>@CachePut:</strong> Metodu her zaman çalıştırır ve sonucu cache'e
                                            ekler. Genellikle cache güncellemek için kullanılır.</li>
                                        <li><strong>@CacheEvict:</strong> Cache'ten veri silmek için kullanılır. Belirli
                                            bir anahtarı veya tüm cache'i temizleyebilir.</li>
                                        <li><strong>@Caching:</strong> Birden fazla cache anotasyonunu birleştirmek için
                                            kullanılır.</li>
                                        <li><strong>@CacheConfig:</strong> Sınıf seviyesinde cache ayarlarını belirtmek
                                            için kullanılır.</li>
                                    </ul>
                                </li>
                                <li><strong>Cache Sağlayıcıları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Caffeine:</strong> Yüksek performanslı, Java tabanlı bir cache
                                            kütüphanesidir.</li>
                                        <li><strong>Ehcache:</strong> Java tabanlı, açık kaynaklı bir cache
                                            kütüphanesidir.</li>
                                        <li><strong>Redis:</strong> Dağıtık, in-memory veri yapısı deposudur.</li>
                                        <li><strong>Hazelcast:</strong> Dağıtık, ölçeklenebilir bir veri platformudur.
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Cache Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Caffeine cache dependency -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>

<!-- Redis cache dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

# application.properties ile cache yapılandırma
# Caffeine cache yapılandırması
spring.cache.type=caffeine
spring.cache.cache-names=users,products
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s

# Redis cache yapılandırması
spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379

# Cache kullanımı
@Service
@CacheConfig(cacheNames = "users")
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Metodu cache'leme
    @Cacheable(key = "#id")
    public User getUserById(Long id) {
        System.out.println("Getting user from DB with id: " + id);
        return userRepository.findById(id).orElse(null);
    }
    
    // Cache güncelleme
    @CachePut(key = "#user.id")
    public User updateUser(User user) {
        System.out.println("Updating user in DB with id: " + user.getId());
        return userRepository.save(user);
    }
    
    // Cache'ten veri silme
    @CacheEvict(key = "#id")
    public void deleteUser(Long id) {
        System.out.println("Deleting user from DB with id: " + id);
        userRepository.deleteById(id);
    }
    
    // Tüm cache'i temizleme
    @CacheEvict(allEntries = true)
    public void clearAllCache() {
        System.out.println("Clearing all users cache");
    }
    
    // Koşullu cache'leme
    @Cacheable(key = "#id", condition = "#id > 10")
    public User getUserByIdIfIdGreaterThanTen(Long id) {
        System.out.println("Getting user from DB with id: " + id);
        return userRepository.findById(id).orElse(null);
    }
    
    // Cache'e özel anahtar ile ekleme
    @Cacheable(key = "'user:' + #email")
    public User getUserByEmail(String email) {
        System.out.println("Getting user from DB with email: " + email);
        return userRepository.findByEmail(email);
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">22. Cache aside pattern</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">DB’den okuma ve cache’e yazma. Update/delete işlemlerinde cache
                                temizleme.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Cache Aside Pattern:</strong> Uygulama katmanında cache mantığını
                                    uyguladığımız bir desendir. Bu desende, uygulama kodu veritabanı ve cache arasında
                                    bir koordinatör görevi görür.</li>
                                <li><strong>Temel Adımlar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Okuma İşlemi:</strong> Uygulama önce cache'den veriye bakar. Eğer
                                            veri cache'te yoksa, veritabanından okur ve cache'e ekler.</li>
                                        <li><strong>Yazma İşlemi:</strong> Uygulama veriyi önce veritabanına yazar,
                                            sonra cache'teki ilgili veriyi günceller veya siler.</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Basit ve anlaşılır bir yapıya sahiptir.</li>
                                        <li>Doğrudan uygulama kontrolündedir.</li>
                                        <li>Cache ve veritabanı arasındaki tutarlılığı yönetmeyi kolaylaştırır.</li>
                                    </ul>
                                </li>
                                <li><strong>Dezavantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Cache mantığı uygulama koduna dağılır.</li>
                                        <li>Boş cache durumunda (cache stampede) sorunlara yol açabilir.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// Cache Aside Pattern implementasyonu
@Service
public class ProductServiceWithCacheAside {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private CacheManager cacheManager;
    
    private static final String PRODUCTS_CACHE = "products";
    
    // Okuma işlemi
    public Product getProductById(Long id) {
        // Cache'ten al
        Cache cache = cacheManager.getCache(PRODUCTS_CACHE);
        Product product = cache.get(id, Product.class);
        
        if (product == null) {
            // Cache'te yoksa veritabanından al
            product = productRepository.findById(id).orElse(null);
            
            if (product != null) {
                // Cache'e ekle
                cache.put(id, product);
            }
        }
        
        return product;
    }
    
    // Yazma işlemi
    public Product updateProduct(Product product) {
        // Veritabanını güncelle
        Product updatedProduct = productRepository.save(product);
        
        // Cache'i güncelle
        Cache cache = cacheManager.getCache(PRODUCTS_CACHE);
        cache.put(updatedProduct.getId(), updatedProduct);
        
        return updatedProduct;
    }
    
    // Silme işlemi
    public void deleteProduct(Long id) {
        // Veritabanından sil
        productRepository.deleteById(id);
        
        // Cache'ten sil
        Cache cache = cacheManager.getCache(PRODUCTS_CACHE);
        cache.evict(id);
    }
    
    // Cache'i tamamen temizleme
    public void clearAllCache() {
        Cache cache = cacheManager.getCache(PRODUCTS_CACHE);
        cache.clear();
    }
}

// Spring ile @Cacheable kullanarak cache aside pattern
@Service
public class ProductServiceWithAnnotation {
    
    @Autowired
    private ProductRepository productRepository;
    
    // Okuma işlemi - @Cacheable ile cache'e ekleme
    @Cacheable(value = "products", key = "#id")
    public Product getProductById(Long id) {
        System.out.println("Getting product from DB with id: " + id);
        return productRepository.findById(id).orElse(null);
    }
    
    // Yazma işlemi - @CachePut ile cache güncelleme
    @CachePut(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        System.out.println("Updating product in DB with id: " + product.getId());
        return productRepository.save(product);
    }
    
    // Silme işlemi - @CacheEvict ile cache'ten silme
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        System.out.println("Deleting product from DB with id: " + id);
        productRepository.deleteById(id);
    }
    
    // Tüm cache'i temizleme
    @CacheEvict(value = "products", allEntries = true)
    public void clearAllProductsCache() {
        System.out.println("Clearing all products cache");
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">23. Distributed cache</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Redis cluster veya Hazelcast. Consistency ve TTL yönetimi.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Distributed Cache:</strong> Birden fazla sunucu arasında paylaşılan, dağıtık
                                    bir cache sistemidir. Mikroservis mimarilerinde ve ölçeklenebilir uygulamalarda
                                    önemlidir.</li>
                                <li><strong>Popüler Distributed Cache Sistemleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Redis:</strong> In-memory veri yapısı deposu, string, hash, list,
                                            set gibi veri tiplerini destekler. Pub/Sub, transaction gibi özellikler
                                            sunar.</li>
                                        <li><strong>Hazelcast:</strong> Java tabanlı, dağıtık bir veri platformudur.
                                            Map, Queue, MultiMap gibi veri yapıları sağlar.</li>
                                        <li><strong>Memcached:</strong> Basit, yüksek performanslı bir dağıtık cache
                                            sistemidir.</li>
                                        <li><strong>Apache Ignite:</strong> Dağıtık veritabanı, caching ve processing
                                            platformudur.</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Yüksek erişilebilirlik ve ölçeklenebilirlik</li>
                                        <li>Birden fazla uygulama örneği arasında veri tutarlılığı</li>
                                        <li>Tek bir uygulama örneğindeki cache kaybı sorununu önleme</li>
                                    </ul>
                                </li>
                                <li><strong>Consistency (Tutarlılık) Modelleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Strong Consistency:</strong> Tüm düğümlerde veri anında güncellenir.
                                        </li>
                                        <li><strong>Eventual Consistency:</strong> Veri güncellemeleri zamanla tüm
                                            düğümlere yayılır.</li>
                                    </ul>
                                </li>
                                <li><strong>TTL (Time To Live):</strong> Cache'teki verilerin ne kadar süre kalacağını
                                    belirler. TTL sonunda veri otomatik olarak cache'ten silinir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Redis için Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- Hazelcast için Maven dependency -->
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-spring</artifactId>
</dependency>

# application.properties - Redis yapılandırması
spring.redis.host=localhost
spring.redis.port=6379
spring.cache.type=redis
spring.cache.redis.time-to-live=600000  # 10 dakika

# application.properties - Hazelcast yapılandırması
spring.cache.type=hazelcast
spring.hazelcast.config=classpath:hazelcast.yml

# hazelcast.yml
hazelcast:
  network:
    port: 5701
    join:
      multicast:
        enabled: true
  map:
    products:
      time-to-live-seconds: 600
      eviction-policy: LRU
      max-size: 5000

# Redis ile distributed cache kullanımı
@Service
public class DistributedProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String PRODUCT_CACHE_KEY_PREFIX = "product:";
    private static final long CACHE_EXPIRE_HOURS = 1;
    
    // Ürünü cache'ten al veya veritabanından oku ve cache'e ekle
    public Product getProductById(Long id) {
        String key = PRODUCT_CACHE_KEY_PREFIX + id;
        
        // Önce Redis'ten dene
        Product product = (Product) redisTemplate.opsForValue().get(key);
        
        if (product == null) {
            // Redis'te yoksa veritabanından al
            product = productRepository.findById(id).orElse(null);
            
            if (product != null) {
                // Redis'e ekle ve TTL ayarla
                redisTemplate.opsForValue().set(key, product, CACHE_EXPIRE_HOURS, TimeUnit.HOURS);
            }
        }
        
        return product;
    }
    
    // Ürünü güncelle ve cache'i de güncelle
    public Product updateProduct(Product product) {
        // Veritabanını güncelle
        Product updatedProduct = productRepository.save(product);
        
        // Redis'te güncelle
        String key = PRODUCT_CACHE_KEY_PREFIX + updatedProduct.getId();
        redisTemplate.opsForValue().set(key, updatedProduct, CACHE_EXPIRE_HOURS, TimeUnit.HOURS);
        
        return updatedProduct;
    }
    
    // Ürünü sil ve cache'ten kaldır
    public void deleteProduct(Long id) {
        // Veritabanından sil
        productRepository.deleteById(id);
        
        // Redis'ten sil
        String key = PRODUCT_CACHE_KEY_PREFIX + id;
        redisTemplate.delete(key);
    }
    
    // Birden fazla ürünü cache'e ekle
    public void cacheProducts(List<Product> products) {
        Map<String, Object> productMap = new HashMap<>();
        
        for (Product product : products) {
            String key = PRODUCT_CACHE_KEY_PREFIX + product.getId();
            productMap.put(key, product);
        }
        
        // Toplu olarak Redis'e ekle
        redisTemplate.opsForValue().multiSet(productMap);
        
        // Her bir anahtar için TTL ayarla
        for (String key : productMap.keySet()) {
            redisTemplate.expire(key, CACHE_EXPIRE_HOURS, TimeUnit.HOURS);
        }
    }
}

# Hazelcast ile distributed cache kullanımı
@Service
public class HazelcastProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private HazelcastInstance hazelcastInstance;
    
    private IMap<Long, Product> getProductCache() {
        return hazelcastInstance.getMap("products");
    }
    
    public Product getProductById(Long id) {
        IMap<Long, Product> productCache = getProductCache();
        
        // Önce Hazelcast'ten dene
        Product product = productCache.get(id);
        
        if (product == null) {
            // Hazelcast'te yoksa veritabanından al
            product = productRepository.findById(id).orElse(null);
            
            if (product != null) {
                // Hazelcast'e ekle
                productCache.put(id, product);
            }
        }
        
        return product;
    }
    
    public Product updateProduct(Product product) {
        // Veritabanını güncelle
        Product updatedProduct = productRepository.save(product);
        
        // Hazelcast'te güncelle
        IMap<Long, Product> productCache = getProductCache();
        productCache.put(updatedProduct.getId(), updatedProduct);
        
        return updatedProduct;
    }
    
    public void deleteProduct(Long id) {
        // Veritabanından sil
        productRepository.deleteById(id);
        
        // Hazelcast'ten sil
        IMap<Long, Product> productCache = getProductCache();
        productCache.remove(id);
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">24. Spring AOP nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Aspect Oriented Programming. Cross-cutting concerns: logging,
                                metrics, security, transactions.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring AOP (Aspect-Oriented Programming):</strong> Uygulama kodunu modüler
                                    hale getirmek için kullanılan bir programlama paradigmasıdır. Cross-cutting concerns
                                    (kesen endişeler) olarak bilinen, birden fazla modülü etkileyen işlevselliği
                                    (logging, security, transaction management vb.) ana iş mantığından ayırmayı sağlar.
                                </li>
                                <li><strong>Temel Kavramlar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Aspect:</strong> Cross-cutting concern'i modüler hale getiren
                                            sınıftır.</li>
                                        <li><strong>Join Point:</strong> Program yürütme akışındaki bir noktadır (metot
                                            çağrısı, exception fırlatma vb.).</li>
                                        <li><strong>Pointcut:</strong> Hangi join point'lerin yakalanacağını belirten
                                            ifadedir.</li>
                                        <li><strong>Advice:</strong> Bir join point'te yürütülen eylemdir (metodun
                                            öncesinde/sonrasında/çevresinde çalışacak kod).</li>
                                        <li><strong>Target Object:</strong> Bir veya daha fazla aspect tarafından
                                            tavsiye edilen nesnedir.</li>
                                        <li><strong>Proxy:</strong> Target nesnesine yönelik calls'leri uygulamak için
                                            oluşturulan nesnedir.</li>
                                    </ul>
                                </li>
                                <li><strong>Advice Türleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>@Before:</strong> Join point'ten önce çalışır.</li>
                                        <li><strong>@After:</strong> Join point'ten sonra çalışır (normal veya exception
                                            çıkışı).</li>
                                        <li><strong>@AfterReturning:</strong> Metot normal bir şekilde tamamlandığında
                                            çalışır.</li>
                                        <li><strong>@AfterThrowing:</strong> Metot exception fırlattığında çalışır.</li>
                                        <li><strong>@Around:</strong> Metodun öncesinde ve sonrasında çalışır, metodu
                                            tamamen sarmalar.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring AOP Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

// Logging Aspect
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
    
    // Service katmanındaki tüm metotları yakala
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    // Service katmanındaki metotlardan önce çalış
    @Before("serviceLayer()")
    public void logBeforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        logger.info("Method {} called with arguments: {}", methodName, Arrays.toString(args));
    }
    
    // Service katmanındaki metotlardan sonra çalış
    @AfterReturning(pointcut = "serviceLayer()", returning = "result")
    public void logAfterMethod(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        
        logger.info("Method {} returned with value: {}", methodName, result);
    }
    
    // Service katmanındaki metotlar exception fırlattığında çalış
    @AfterThrowing(pointcut = "serviceLayer()", throwing = "exception")
    public void logAfterThrowing(JoinPoint joinPoint, Throwable exception) {
        String methodName = joinPoint.getSignature().getName();
        
        logger.error("Method {} threw exception: {}", methodName, exception.getMessage());
    }
    
    // Metodu tamamen sarmala
    @Around("serviceLayer()")
    public Object logAroundMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        long startTime = System.currentTimeMillis();
        
        try {
            logger.info("Entering method: {} with arguments: {}", methodName, Arrays.toString(args));
            
            // Metodu çalıştır
            Object result = joinPoint.proceed();
            
            long endTime = System.currentTimeMillis();
            logger.info("Exiting method: {} with execution time: {} ms", methodName, (endTime - startTime));
            
            return result;
        } catch (Throwable throwable) {
            logger.error("Exception in method: {}", methodName, throwable);
            throw throwable;
        }
    }
}

// Performance Monitoring Aspect
@Aspect
@Component
public class PerformanceAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceAspect.class);
    
    // Controller katmanındaki tüm metotları yakala
    @Pointcut("execution(* com.example.controller.*.*(..))")
    public void controllerLayer() {}
    
    @Around("controllerLayer()")
    public Object logPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            // Metodu çalıştır
            Object result = joinPoint.proceed();
            
            long endTime = System.currentTimeMillis();
            long executionTime = endTime - startTime;
            
            // Yavaş metotları logla
            if (executionTime > 1000) {
                logger.warn("SLOW METHOD: {} executed in {} ms", 
                    joinPoint.getSignature().toShortString(), executionTime);
            } else {
                logger.info("Method: {} executed in {} ms", 
                    joinPoint.getSignature().toShortString(), executionTime);
            }
            
            return result;
        } catch (Throwable throwable) {
            logger.error("Exception in method: {}", joinPoint.getSignature().toShortString(), throwable);
            throw throwable;
        }
    }
}

// Security Aspect
@Aspect
@Component
public class SecurityAspect {
    
    // @Secured anotasyonlu metotları yakala
    @Pointcut("@annotation(org.springframework.security.access.annotation.Secured)")
    public void securedMethods() {}
    
    @Before("securedMethods()")
    public void checkSecurity(JoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        
        Secured secured = method.getAnnotation(Secured.class);
        String[] roles = secured.value();
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        // Kullanıcının rollerini kontrol et
        for (String role : roles) {
            if (!authentication.getAuthorities().contains(new SimpleGrantedAuthority(role))) {
                throw new AccessDeniedException("User does not have required role: " + role);
            }
        }
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">25. @Aspect ve advice türleri</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">@Before, @After, @Around, @AfterReturning, @AfterThrowing.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>@Aspect:</strong> Bir sınıfın aspect olduğunu belirtmek için kullanılan
                                    anotasyondur. Aspect sınıfları, cross-cutting concerns'leri modüler hale getirir.
                                </li>
                                <li><strong>Advice Türleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>@Before:</strong> Bir join point'ten önce çalışır. Metot
                                            çağrıldığında, metot gövdesi çalıştırılmadan önce advice çalıştırılır.</li>
                                        <li><strong>@After:</strong> Bir join point'ten sonra çalışır. Metot normal bir
                                            şekilde tamamlandığında veya exception fırlattığında çalışır.</li>
                                        <li><strong>@AfterReturning:</strong> Bir join point normal bir şekilde
                                            tamamlandığında çalışır. Metot exception fırlatmazsa çalışır.</li>
                                        <li><strong>@AfterThrowing:</strong> Bir join point exception fırlattığında
                                            çalışır. Metot exception fırlatırsa çalışır.</li>
                                        <li><strong>@Around:</strong> Bir join point'i tamamen sarmalar. Metodun
                                            öncesinde ve sonrasında kod çalıştırmanıza olanak tanır. En güçlü advice
                                            türüdür.</li>
                                    </ul>
                                </li>
                                <li><strong>Pointcut İfadeleri:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>execution:</strong> Metot execution'larını eşleştirmek için
                                            kullanılır.</li>
                                        <li><strong>within:</strong> Belirli türdeki sınıfları eşleştirmek için
                                            kullanılır.</li>
                                        <li><strong>this:</strong> Spring AOP proxy'sini belirli bir türe eşleştirmek
                                            için kullanılır.</li>
                                        <li><strong>target:</strong> Hedef nesneyi belirli bir türe eşleştirmek için
                                            kullanılır.</li>
                                        <li><strong>args:</strong> Metot argümanlarını eşleştirmek için kullanılır.</li>
                                        <li><strong>@annotation:</strong> Belirli bir anotasyona sahip metotları
                                            eşleştirmek için kullanılır.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre>// Aspect sınıfı örneği
@Aspect
@Component
public class UserServiceAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(UserServiceAspect.class);
    
    // UserService sınıfındaki tüm metotları yakala
    @Pointcut("within(com.example.service.UserService)")
    public void userServiceMethods() {}
    
    // UserService sınıfındaki tüm metotlardan önce çalış
    @Before("userServiceMethods()")
    public void logBeforeUserServiceMethods(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("Executing UserService method: {}", methodName);
    }
    
    // UserService sınıfındaki tüm metotlardan sonra çalış
    @After("userServiceMethods()")
    public void logAfterUserServiceMethods(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("Finished executing UserService method: {}", methodName);
    }
    
    // UserService sınıfındaki metotlar normal tamamlandığında çalış
    @AfterReturning(pointcut = "userServiceMethods()", returning = "result")
    public void logAfterReturningUserServiceMethods(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("UserService method: {} returned with value: {}", methodName, result);
    }
    
    // UserService sınıfındaki metotlar exception fırlattığında çalış
    @AfterThrowing(pointcut = "userServiceMethods()", throwing = "exception")
    public void logAfterThrowingUserServiceMethods(JoinPoint joinPoint, Exception exception) {
        String methodName = joinPoint.getSignature().getName();
        logger.error("UserService method: {} threw exception: {}", methodName, exception.getMessage());
    }
    
    // UserService sınıfındaki metotları tamamen sarmala
    @Around("userServiceMethods()")
    public Object logAroundUserServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        logger.info("Before executing UserService method: {} with arguments: {}", methodName, Arrays.toString(args));
        
        try {
            // Metodu çalıştır
            Object result = joinPoint.proceed();
            
            logger.info("After executing UserService method: {} with result: {}", methodName, result);
            
            return result;
        } catch (Throwable throwable) {
            logger.error("Exception in UserService method: {}", methodName, throwable);
            throw throwable;
        }
    }
    
    // Belirli bir anotasyona sahip metotları yakala
    @Pointcut("@annotation(com.example.annotation.Loggable)")
    public void loggableMethods() {}
    
    @Before("loggableMethods()")
    public void logBeforeLoggableMethods(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("Executing loggable method: {}", methodName);
    }
    
    // Belirli bir paketteki tüm servis metotlarını yakala
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void allServiceMethods() {}
    
    @Around("allServiceMethods()")
    public Object logAllServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String className = joinPoint.getTarget().getClass().getSimpleName();
        String methodName = joinPoint.getSignature().getName();
        
        logger.info("Entering {}.{}", className, methodName);
        
        try {
            Object result = joinPoint.proceed();
            logger.info("Exiting {}.{}", className, methodName);
            return result;
        } catch (Throwable throwable) {
            logger.error("Exception in {}.{}", className, methodName, throwable);
            throw throwable;
        }
    }
    
    // Belirli argümanlara sahip metotları yakala
    @Pointcut("execution(* com.example.service.*.*(..)) && args(id,..)")
    public void methodsWithId(Long id) {}
    
    @Before("methodsWithId(id)")
    public void logMethodsWithId(JoinPoint joinPoint, Long id) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("Executing method: {} with id: {}", methodName, id);
    }
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spring Integration & DevOps / Production Soruları -->
                <div id="spring-integration" class="category-content hidden">
                    <h2 class="text-2xl font-semibold mb-6 text-indigo-700">Spring Integration & DevOps / Production
                        Soruları</h2>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">31. Spring Integration nedir?</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Enterprise Integration Patterns (EIP). Channels, routers,
                                transformers, filters.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Integration:</strong> Spring tabanlı uygulamalara Enterprise
                                    Integration Patterns (EIP) sağlayan bir framework'tür. Bu framework, farklı
                                    sistemler arasında mesajlaşma ve entegrasyon sağlamak için kullanılır.</li>
                                <li><strong>Temel Bileşenler:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Message:</strong> Sistemler arasında taşınan veri birimidir. Header
                                            ve payload içerir.</li>
                                        <li><strong>Channel:</strong> Mesajların taşındığı yol veya boru hattıdır.
                                            Producer'lar ve consumer'lar arasında aracı görevi görür.</li>
                                        <li><strong>Endpoint:</strong> Mesajlaşma sistemindeki bir bileşeni uygulama
                                            koduna bağlayan arayüzdür.</li>
                                        <li><strong>Router:</strong> Gelen mesajları belirli kriterlere göre farklı
                                            kanallara yönlendirir.</li>
                                        <li><strong>Transformer:</strong> Mesajın içeriğini veya yapısını değiştirir.
                                        </li>
                                        <li><strong>Filter:</strong> Belirli koşullara uymayan mesajları engeller.</li>
                                        <li><strong>Service Activator:</strong> Mesajı alır ve bir servis metodu
                                            çağırır.</li>
                                        <li><strong>Gateway:</strong> Uygulama kodu ile mesajlaşma sistemi arasındaki
                                            arayüzü sağlar.</li>
                                    </ul>
                                </li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Loose coupling (gevşek bağlantı) sağlar.</li>
                                        <li>Karmaşık entegrasyon senaryolarını basitleştirir.</li>
                                        <li>Test edilebilirliği artırır.</li>
                                        <li>Yeniden kullanılabilir bileşenler sağlar.</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Integration Maven dependency -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-integration</artifactId>
</dependency>

<!-- HTTP, File, JMS gibi adaptörler için -->
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-http</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-file</artifactId>
</dependency>

// Spring Integration konfigürasyon sınıfı
@Configuration
@EnableIntegration
public class IntegrationConfig {
    
    // Gelen HTTP isteklerini işleyen kanal
    @Bean
    public DirectChannel httpRequestChannel() {
        return new DirectChannel();
    }
    
    // İşlenmiş yanıtları taşıyan kanal
    @Bean
    public DirectChannel httpResponseChannel() {
        return new DirectChannel();
    }
    
    // HTTP gelen istekleri işleyen endpoint
    @Bean
    public MessageHandler httpInboundEndpoint() {
        HttpRequestHandlingMessagingGateway handler = new HttpRequestHandlingMessagingGateway();
        handler.setRequestChannel(httpRequestChannel());
        handler.setReplyChannel(httpResponseChannel());
        return handler;
    }
    
    // Gelen isteği işleyen servis aktivatörü
    @Bean
    public ServiceActivator httpRequestServiceActivator() {
        MethodInvokingMessageProcessor processor = new MethodInvokingMessageProcessor(new HttpRequestHandler(), "handleRequest");
        return new ServiceActivatingHandler(processor);
    }
    
    // HTTP yanıtı için çıkış kanalı adaptörü
    @Bean
    public MessageHandler httpOutboundEndpoint() {
        HttpRequestHandlingMessagingGateway handler = new HttpRequestHandlingMessagingGateway(true);
        handler.setRequestChannel(httpResponseChannel());
        return handler;
    }
}

// HTTP isteklerini işleyen servis sınıfı
@Service
public class HttpRequestHandler {
    
    public String handleRequest(String payload) {
        // Gelen isteği işle
        System.out.println("Processing request: " + payload);
        
        // İşlenmiş yanıtı döndür
        return "Processed: " + payload;
    }
}

// DSL (Domain Specific Language) ile konfigürasyon
@Configuration
public class IntegrationDslConfig {
    
    @Bean
    public IntegrationFlow fileProcessingFlow() {
        return IntegrationFlows
            .from(Files.inboundAdapter(new File("/tmp/input"))
                .preventDuplicates(true)
                .autoCreateDirectory(true)
                .patternFilter("*.txt"))
            .transform(Transformers.fileToString())
            .transform(payload -> {
                // Metni büyük harfe çevir
                return ((String) payload).toUpperCase();
            })
            .handle(Files.outboundAdapter(new File("/tmp/output"))
                .fileNameGenerator(message -> {
                    // Dosya adını oluştur
                    return "processed_" + message.getHeaders().get(FileHeaders.FILENAME);
                }))
            .get();
    }
    
    @Bean
    public IntegrationFlow httpProcessingFlow() {
        return IntegrationFlows
            .from(Http.inboundGateway("/api/process")
                .requestChannel("httpRequestChannel")
                .replyChannel("httpResponseChannel"))
            .transform(Transformers.objectToString())
            .handle("httpRequestHandler", "handleRequest")
            .get();
    }
}

// Dosya işleme için servis sınıfı
@Service
public class FileProcessingService {
    
    public String processFileContent(String content) {
        // Dosya içeriğini işle
        System.out.println("Processing file content: " + content.substring(0, Math.min(content.length(), 100)));
        
        // İşlenmiş içeriği döndür
        return "Processed: " + content.length() + " characters";
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">32. Messaging integration (Kafka/RabbitMQ)</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">@EnableBinding ile input/output channel tanımlama. Stream
                                processing ve reactive pipelines.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Integration with Messaging Systems:</strong> Spring Integration,
                                    Kafka, RabbitMQ gibi mesajlaşma sistemleriyle entegre olmak için özel adaptörler ve
                                    bağlantılar sağlar. Bu sayede uygulamalar arasında asenkron ve olay tabanlı iletişim
                                    kurulabilir.</li>
                                <li><strong>Spring Cloud Stream:</strong> Spring Integration'ın üstünde bir abstraction
                                    katmanıdır. Mesajlaşma sistemleriyle (Kafka, RabbitMQ) çalışmayı basitleştirir ve
                                    binder'lar aracılığıyla farklı mesajlaşma sistemleri arasında geçiş yapılmasına
                                    olanak tanır.</li>
                                <li><strong>Temel Kavramlar:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>Binder:</strong> Spring Cloud Stream ile mesajlaşma sistemi
                                            arasındaki bağlantıyı sağlayan bileşendir.</li>
                                        <li><strong>Binding:</strong> Uygulama kodu ile mesajlaşma sistemi arasındaki
                                            köprüyü oluşturur.</li>
                                        <li><strong>@EnableBinding:</strong> Mesajlaşma kanallarını etkinleştirmek için
                                            kullanılan anotasyondur.</li>
                                        <li><strong>@StreamListener:</strong> Gelen mesajları dinlemek için kullanılan
                                            anotasyondur.</li>
                                        <li><strong>@SendTo:</strong> İşlenmiş mesajları bir çıkış kanalına göndermek
                                            için kullanılan anotasyondur.</li>
                                    </ul>
                                </li>
                                <li><strong>Reactive Programming:</strong> Spring WebFlux ve Reactor ile birlikte
                                    kullanıldığında, reaktif ve non-blocking mesaj işleme akışları oluşturulabilir.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Spring Cloud Stream için Maven dependency -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-kafka</artifactId>
</dependency>

<!-- veya RabbitMQ için -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>

# application.properties - Kafka yapılandırması
spring.cloud.stream.kafka.binder.brokers=localhost:9092
spring.cloud.stream.bindings.input.destination=user-events
spring.cloud.stream.bindings.input.group=user-service
spring.cloud.stream.bindings.output.destination=user-notifications

# application.properties - RabbitMQ yapılandırması
spring.cloud.stream.rabbit.binder.host=localhost
spring.cloud.stream.rabbit.binder.port=5672
spring.cloud.stream.bindings.input.destination=user.events
spring.cloud.stream.bindings.input.group=user-service
spring.cloud.stream.bindings.output.destination=user.notifications

// Kafka/RabbitMQ için binding interface
public interface UserEventChannels {
    
    String INPUT = "input";
    String OUTPUT = "output";
    
    @Input(INPUT)
    SubscribableChannel userEvents();
    
    @Output(OUTPUT)
    MessageChannel userNotifications();
}

// Uygulama ana sınıfı
@SpringBootApplication
@EnableBinding(UserEventChannels.class)
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

// Olay dinleyici ve işleyici
@Service
public class UserEventHandler {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserEventChannels channels;
    
    // Gelen kullanıcı olaylarını dinle
    @StreamListener(UserEventChannels.INPUT)
    @SendTo(UserEventChannels.OUTPUT)
    public UserNotification handleUserEvent(UserEvent event) {
        System.out.println("Received user event: " + event);
        
        // Olaya göre işlem yap
        User user = userService.processUserEvent(event);
        
        // Bildirim oluştur
        UserNotification notification = new UserNotification();
        notification.setUserId(user.getId());
        notification.setMessage("User processed: " + user.getName());
        notification.setTimestamp(LocalDateTime.now());
        
        return notification;
    }
}

// Reactive ile mesaj işleme
@Service
public class ReactiveUserEventHandler {
    
    @Autowired
    private ReactiveUserService userService;
    
    @Autowired
    private UserEventChannels channels;
    
    // Gelen kullanıcı olaylarını reaktif olarak dinle
    @StreamListener(UserEventChannels.INPUT)
    public Flux<UserNotification> handleUserEventsFlux(Flux<UserEvent> events) {
        return events
            .flatMap(event -> userService.processUserEvent(event)
                .map(user -> {
                    UserNotification notification = new UserNotification();
                    notification.setUserId(user.getId());
                    notification.setMessage("User processed: " + user.getName());
                    notification.setTimestamp(LocalDateTime.now());
                    return notification;
                }))
            .doOnNext(notification -> System.out.println("Sending notification: " + notification));
    }
}

// Olay gönderme servisi
@Service
public class UserEventPublisher {
    
    @Autowired
    private UserEventChannels channels;
    
    public void publishUserEvent(UserEvent event) {
        // Mesaj oluştur
        Message<UserEvent> message = MessageBuilder.withPayload(event)
            .setHeader(MessageHeaders.CONTENT_TYPE, "application/json")
            .build();
        
        // Mesajı gönder
        channels.userNotifications().send(message);
    }
    
    // Reactive ile olay gönderme
    public Mono<Void> publishUserEventReactive(UserEvent event) {
        return Mono.fromRunnable(() -> {
            Message<UserEvent> message = MessageBuilder.withPayload(event)
                .setHeader(MessageHeaders.CONTENT_TYPE, "application/json")
                .build();
            
            channels.userNotifications().send(message);
        });
    }
}

// Functional style ile Spring Cloud Stream (Spring Boot 2.x+)
@SpringBootApplication
public class FunctionalUserServiceApplication {
    
    @Bean
    public Function<UserEvent, UserNotification> processUserEvent() {
        return event -> {
            System.out.println("Processing user event: " + event);
            
            // Olayı işle
            User user = new User();
            user.setId(event.getUserId());
            user.setName(event.getUserName());
            
            // Bildirim oluştur
            UserNotification notification = new UserNotification();
            notification.setUserId(user.getId());
            notification.setMessage("User processed: " + user.getName());
            notification.setTimestamp(LocalDateTime.now());
            
            return notification;
        };
    }
    
    @Bean
    public Function<Flux<UserEvent>, Flux<UserNotification>> processUserEvents() {
        return eventFlux -> eventFlux
            .flatMap(event -> {
                System.out.println("Processing user event: " + event);
                
                // Olayı işle
                User user = new User();
                user.setId(event.getUserId());
                user.setName(event.getUserName());
                
                // Bildirim oluştur
                UserNotification notification = new UserNotification();
                notification.setUserId(user.getId());
                notification.setMessage("User processed: " + user.getName());
                notification.setTimestamp(LocalDateTime.now());
                
                return Mono.just(notification);
            });
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">33. File, FTP, HTTP integration</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Spring Integration adapter'ları ile batch veya streaming data
                                çekme.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Integration Adapters:</strong> Spring Integration, çeşitli
                                    protokoller ve sistemlerle entegrasyon sağlamak için özel adapter'lar sunar. Bu
                                    adapter'lar, dosya sistemleri, FTP/SFTP, HTTP, JMS, AMQP gibi farklı sistemlerle
                                    iletişim kurmayı kolaylaştırır.</li>
                                <li><strong>File Adapter:</strong> Dosya sistemleriyle entegrasyon sağlar. Dosya
                                    oluşturma, okuma, yazma ve izleme işlemleri için kullanılır.</li>
                                <li><strong>FTP/SFTP Adapter:</strong> FTP/SFTP sunucularıyla dosya transferi için
                                    kullanılır. Uzak dosya sistemleriyle entegrasyon sağlar.</li>
                                <li><strong>HTTP Adapter:</strong> HTTP/HTTPS protokolleri üzerinden iletişim kurmak
                                    için kullanılır. REST veya SOAP servisleriyle entegrasyon sağlar.</li>
                                <li><strong>Avantajları:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li>Farklı sistemlerle standart bir arayüz üzerinden iletişim kurma</li>
                                        <li>Otomatik dosya işleme ve transferi</li>
                                        <li>Hata yönetimi ve yeniden deneme mekanizmaları</li>
                                        <li>Batch ve streaming veri işleme yetenekleri</li>
                                    </ul>
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- File, FTP, HTTP için Spring Integration dependencies -->
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-file</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-ftp</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-http</artifactId>
</dependency>

// File Integration konfigürasyonu
@Configuration
public class FileIntegrationConfig {
    
    @Value("${input.directory:${java.io.tmpdir}/input}")
    private String inputDirectory;
    
    @Value("${output.directory:${java.io.tmpdir}/output}")
    private String outputDirectory;
    
    // Dosya giriş akışı
    @Bean
    public IntegrationFlow fileInboundFlow() {
        return IntegrationFlows
            .from(Files.inboundAdapter(new File(inputDirectory))
                .preventDuplicates(true)
                .autoCreateDirectory(true)
                .patternFilter("*.txt"))
            .transform(Transformers.fileToString())
            .channel("fileProcessingChannel")
            .get();
    }
    
    // Dosya işleme akışı
    @Bean
    public IntegrationFlow fileProcessingFlow() {
        return IntegrationFlows
            .from("fileProcessingChannel")
            .transform(payload -> {
                // Dosya içeriğini işle
                String content = (String) payload;
                return content.toUpperCase();
            })
            .handle(Files.outboundAdapter(new File(outputDirectory))
                .fileNameGenerator(message -> {
                    // İşlenmiş dosya adını oluştur
                    String originalFilename = (String) message.getHeaders().get(FileHeaders.FILENAME);
                    return "processed_" + originalFilename;
                }))
            .get();
    }
}

// FTP Integration konfigürasyonu
@Configuration
public class FtpIntegrationConfig {
    
    @Value("${ftp.host:localhost}")
    private String ftpHost;
    
    @Value("${ftp.port:21}")
    private int ftpPort;
    
    @Value("${ftp.username:anonymous}")
    private String ftpUsername;
    
    @Value("${ftp.password:}")
    private String ftpPassword;
    
    @Value("${ftp.remote.directory:/}")
    private String ftpRemoteDirectory;
    
    @Value("${ftp.local.directory:${java.io.tmpdir}/ftp}")
    private String ftpLocalDirectory;
    
    // FTP istemci fabrikası
    @Bean
    public DefaultFtpSessionFactory ftpSessionFactory() {
        DefaultFtpSessionFactory sessionFactory = new DefaultFtpSessionFactory();
        sessionFactory.setHost(ftpHost);
        sessionFactory.setPort(ftpPort);
        sessionFactory.setUsername(ftpUsername);
        sessionFactory.setPassword(ftpPassword);
        return sessionFactory;
    }
    
    // FTP giriş akışı
    @Bean
    public IntegrationFlow ftpInboundFlow() {
        return IntegrationFlows
            .from(Ftp.inboundAdapter(ftpSessionFactory())
                .remoteDirectory(ftpRemoteDirectory)
                .localDirectory(new File(ftpLocalDirectory))
                .autoCreateLocalDirectory(true)
                .filter(new FtpSimplePatternFileListFilter("*.txt")))
            .channel("ftpProcessingChannel")
            .get();
    }
    
    // FTP çıkış akışı
    @Bean
    public IntegrationFlow ftpOutboundFlow() {
        return IntegrationFlows
            .from("ftpOutputChannel")
            .handle(Ftp.outboundAdapter(ftpSessionFactory())
                .remoteDirectory(ftpRemoteDirectory)
                .fileNameGenerator(message -> {
                    // Dosya adını oluştur
                    return "upload_" + System.currentTimeMillis() + ".txt";
                }))
            .get();
    }
}

// HTTP Integration konfigürasyonü
@Configuration
public class HttpIntegrationConfig {
    
    // HTTP giriş akışı
    @Bean
    public IntegrationFlow httpInboundFlow() {
        return IntegrationFlows
            .from(Http.inboundGateway("/api/process")
                .requestChannel("httpProcessingChannel")
                .replyChannel("httpResponseChannel")
                .requestMapping(requestMapping -> requestMapping
                    .methods(HttpMethod.POST)
                    .consumes("application/json")))
            .transform(Transformers.objectToString())
            .handle("httpRequestHandler", "handleRequest")
            .get();
    }
    
    // HTTP çıkış akışı
    @Bean
    public IntegrationFlow httpOutboundFlow() {
        return IntegrationFlows
            .from("httpOutputChannel")
            .handle(Http.outboundGateway("http://example.com/api/external")
                .httpMethod(HttpMethod.POST)
                .expectedResponseType(String.class))
            .channel("httpResponseChannel")
            .get();
    }
}

// HTTP isteklerini işleyen servis
@Service
public class HttpRequestHandler {
    
    public String handleRequest(String payload) {
        // Gelen isteği işle
        System.out.println("Processing HTTP request: " + payload);
        
        // İşlenmiş yanıtı döndür
        return "Processed: " + payload;
    }
}

// HTTP isteği gönderen servis
@Service
public class HttpRequestSender {
    
    @Autowired
    private MessageChannel httpOutputChannel;
    
    @Autowired
    private MessageChannel httpResponseChannel;
    
    public String sendHttpRequest(String payload) {
        // Mesaj oluştur
        Message<String> message = MessageBuilder.withPayload(payload)
            .setHeader(HttpHeaders.CONTENT_TYPE, "application/json")
            .build();
        
        // Mesajı gönder ve yanıtı al
        httpOutputChannel.send(message);
        
        // Bu örnekte basitleştirme için doğrudan yanıt dönüyoruz
        // Gerçek uygulamada, yanıtı asenkron olarak işlemek gerekir
        return "Request sent: " + payload;
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">34. Spring Boot DevOps – Actuator endpoints</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">/actuator/health, /actuator/metrics, /actuator/env. Custom
                                endpoints.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Spring Boot Actuator:</strong> Spring Boot uygulamalarını izlemek ve
                                    yönetmek için kullanılan bir dizi üretim özelliği sağlar. HTTP endpoint'leri veya
                                    JMX aracılığıyla uygulama hakkında bilgi toplamaya olanak tanır.</li>
                                <li><strong>Temel Endpoint'ler:</strong>
                                    <ul class="list-disc pl-5 mt-1">
                                        <li><strong>/actuator/health:</strong> Uygulamanın sağlık durumunu kontrol eder.
                                            Veritabanı bağlantısı, disk alanı, memory gibi bileşenlerin durumunu
                                            gösterir.</li>
                                        <li><strong>/actuator/metrics:</strong> Uygulama metriklerini (memory, CPU, HTTP
                                            istatistikleri, JVM metrikleri vb.) sağlar.</li>
                                        <li><strong>/actuator/env:</strong> Spring Environment'deki özellikleri
                                            gösterir.</li>
                                        <li><strong>/actuator/info:</strong> Uygulama bilgilerini (versiyon, git
                                            bilgileri, build bilgileri vb.) gösterir.</li>
                                        <li><strong>/actuator/beans:</strong> ApplicationContext'teki tüm bean'leri
                                            listeler.</li>
                                        <li><strong>/actuator/mappings:</strong> Tüm @RequestMapping path'lerini
                                            gösterir.</li>
                                        <li><strong>/actuator/configprops:</strong> Tüm @ConfigurationProperties
                                            bean'lerini gösterir.</li>
                                        <li><strong>/actuator/conditions:</strong> Otomatik konfigürasyon koşullarını
                                            gösterir.</li>
                                    </ul>
                                </li>
                                <li><strong>Özel Endpoint'ler:</strong> Spring Boot 2.x ile birlikte, uygulama spesifik
                                    endpoint'ler oluşturmak mümkündür. Bu endpoint'ler, uygulamanın özel metriklerini
                                    veya durum bilgilerini dışarıya açmak için kullanılır.</li>
                                <li><strong>Güvenlik:</strong> Actuator endpoint'leri hassas bilgiler içerebileceğinden,
                                    genellikle Spring Security ile korunur ve sadece yetkili kullanıcıların erişimine
                                    açılır.</li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Actuator bağımlılığı -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

# application.properties ile endpoint yapılandırma
# Tüm endpoint'leri açma
management.endpoints.web.exposure.include=*

# Sadece belirli endpoint'leri açma
management.endpoints.web.exposure.include=health,info,metrics

# Health endpoint detaylarını gösterme
management.endpoint.health.show-details=always

# Endpoint'leri özel bir path altında açma
management.endpoints.web.base-path=/admin

# Özellikleri hassas olarak işaretleme
management.endpoint.env.show-values=ALWAYS

# Custom endpoint oluşturma
@Component
@Endpoint(id = "custom", enableByDefault = true)
public class CustomEndpoint {
    
    @ReadOperation
    public Map<String, Object> customEndpoint() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "OK");
        response.put("timestamp", System.currentTimeMillis());
        response.put("version", "1.0.0");
        
        // Özel metrikler
        Map<String, Object> metrics = new HashMap<>();
        metrics.put("activeUsers", 150);
        metrics.put("databaseConnections", 10);
        metrics.put("cacheHitRatio", 0.85);
        
        response.put("metrics", metrics);
        
        return response;
    }
    
    @ReadOperation
    public String getCustomInfo(@Selector String infoType) {
        switch (infoType) {
            case "version":
                return "1.0.0";
            case "status":
                return "OK";
            default:
                return "Unknown info type: " + infoType;
        }
    }
    
    @WriteOperation
    public void updateCustomInfo(@Selector String infoType, String value) {
        System.out.println("Updating " + infoType + " with value: " + value);
        // Burada özel güncelleme mantığı
    }
    
    @DeleteOperation
    public void deleteCustomInfo(@Selector String infoType) {
        System.out.println("Deleting " + infoType);
        // Burada özel silme mantığı
    }
}

// Health indicator oluşturma
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        // Özel sağlık kontrolü
        int errorCode = check(); // özel bir kontrol metodu
        if (errorCode != 0) {
            return Health.down()
                .withDetail("Error Code", errorCode)
                .withDetail("Error Message", "Custom service is not available")
                .build();
        }
        return Health.up()
            .withDetail("Message", "Custom service is available")
            .build();
    }
    
    private int check() {
        // Uygulamaya özel sağlık kontrolü
        // 0 = sağlıklı, diğer değerler = hata kodları
        return 0;
    }
}

// Metrics oluşturma
@Component
public class CustomMetrics {
    
    private final Counter requestCounter;
    private final Timer requestTimer;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.requestCounter = Counter.builder("custom.requests")
            .description("Number of custom requests")
            .register(meterRegistry);
            
        this.requestTimer = Timer.builder("custom.request.timer")
            .description("Custom request processing time")
            .register(meterRegistry);
    }
    
    public void incrementRequestCounter() {
        requestCounter.increment();
    }
    
    public void recordRequestTime(long duration, TimeUnit unit) {
        requestTimer.record(duration, unit);
    }
}

// Metrics kullanımı
@RestController
@RequestMapping("/api/custom")
public class CustomController {
    
    @Autowired
    private CustomMetrics customMetrics;
    
    @GetMapping
    public ResponseEntity<String> getCustomData() {
        long startTime = System.currentTimeMillis();
        
        try {
            // Metriği artır
            customMetrics.incrementRequestCounter();
            
            // İş mantığı
            String result = "Custom data response";
            
            return ResponseEntity.ok(result);
        } finally {
            // Süreyi kaydet
            long duration = System.currentTimeMillis() - startTime;
            customMetrics.recordRequestTime(duration, TimeUnit.MILLISECONDS);
        }
    }
}</pre>
                            </div>
                        </div>
                    </div>

                    <div class="question-card bg-white rounded-lg shadow-md p-6 mb-6">
                        <h3 class="text-lg font-semibold mb-2">35. Monitoring ve logging</h3>
                        <div class="flex justify-between items-center">
                            <p class="text-gray-600">Micrometer + Prometheus + Grafana. Sleuth + Zipkin ile distributed
                                tracing.</p>
                            <button class="toggle-answer text-indigo-600 hover:text-indigo-800">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                        <div class="answer-content mt-4 text-gray-700">
                            <p><strong>Detaylı Cevap:</strong></p>
                            <ul class="list-disc pl-5 mt-2 space-y-2">
                                <li><strong>Monitoring ve Logging:</strong> Mikroservis uygulamalarında, sistem
                                    performansını izlemek ve hataları teşhis etmek için monitoring ve logging sistemleri
                                    kritik öneme sahiptir.</li>
                                <li><strong>Micrometer:</strong> Spring Boot 2.x ile birlikte gelen, uygulama
                                    metriklerini toplamak için kullanılan bir kütüphanedir. Prometheus, InfluxDB, Atlas,
                                    Graphite gibi farklı monitoring sistemlerine metrik göndermeyi destekler.</li>
                                <li><strong>Prometheus:</strong> Açık kaynaklı bir monitoring ve alerting sistemidir.
                                    Zaman serisi verilerini toplar, depolar ve sorgular.</li>
                                <li><strong>Grafana:</strong> Metrik verilerini görselleştirmek için kullanılan açık
                                    kaynaklı bir platformdur. Prometheus, InfluxDB gibi veri kaynaklarından veri alarak
                                    panolar oluşturur.</li>
                                <li><strong>Spring Cloud Sleuth:</strong> Mikroservis mimarilerinde dağıtık izleme
                                    (distributed tracing) sağlamak için kullanılan bir kütüphanedir. Her isteğe
                                    benzersiz bir traceId ve spanId ekler.</li>
                                <li><strong>Zipkin:</strong> Dağıtık izleme sistemidir. Spring Cloud Sleuth tarafından
                                    toplanan verileri Zipkin'e göndererek, servisler arası istek akışını görselleştirir.
                                </li>
                            </ul>
                            <div class="code-block mt-3">
                                <pre><!-- Micrometer ve Prometheus için bağımlılıklar -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>

<!-- Spring Cloud Sleuth ve Zipkin için bağımlılıklar -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>

# application.properties ile monitoring yapılandırması
# Prometheus endpoint'ini açma
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.metrics.export.prometheus.enabled=true

# Zipkin yapılandırması
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0  # %100 oranında örnekleme

# Logback yapılandırması (logback-spring.xml)
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/base.xml"/>
    
    <!-- Konsol log formatı -->
    <property name="CONSOLE_LOG_PATTERN" 
              value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr([%X{traceId}-%X{spanId}]){cyan} %clr([${LOG_LEVEL_PATTERN:-%5p}]) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"/>
    
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>
    
    <!-- Dosya log formatı -->
    <property name="FILE_LOG_PATTERN" 
              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}-%X{spanId}] [%thread] %-5level %logger{36} - %msg%n"/>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
    </appender>
    
    <!-- JSON formatında loglama (ELK entegrasyonu için) -->
    <appender name="LOGSTASH" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/logstash.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/logstash.%d{yyyy-MM-dd}.json</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"appname":"myapp","profile":"${spring.profiles.active:-default}"}</customFields>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
        <appender-ref ref="LOGSTASH"/>
    </root>
</configuration>

// Özel metrikler oluşturma
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    private final Counter productRequestCounter;
    private final Timer productRequestTimer;
    
    public ProductController(MeterRegistry meterRegistry) {
        this.productRequestCounter = Counter.builder("product.requests")
            .description("Number of product requests")
            .tag("endpoint", "products")
            .register(meterRegistry);
            
        this.productRequestTimer = Timer.builder("product.request.timer")
            .description("Product request processing time")
            .tag("endpoint", "products")
            .register(meterRegistry);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable Long id) {
        return Timer.sample(productRequestTimer, () -> {
            productRequestCounter.increment();
            
            // Ürünü getir
            Product product = productService.getProductById(id);
            
            if (product == null) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(product);
        });
    }
}

// MDC (Mapped Diagnostic Context) kullanarak log zenginleştirme
@Component
public class LoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) 
            throws ServletException, IOException {
        
        // MDC'ye traceId ve spanId ekle
        String traceId = request.getHeader("X-Trace-Id");
        if (traceId != null) {
            MDC.put("traceId", traceId);
        }
        
        String spanId = request.getHeader("X-Span-Id");
        if (spanId != null) {
            MDC.put("spanId", spanId);
        }
        
        // Kullanıcı bilgisi ekle
        String user = request.getRemoteUser();
        if (user != null) {
            MDC.put("user", user);
        }
        
        // İstek bilgilerini ekle
        MDC.put("method", request.getMethod());
        MDC.put("uri", request.getRequestURI());
        MDC.put("query", request.getQueryString());
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            // MDC'yi temizle
            MDC.clear();
        }
    }
}

// Structured logging kullanımı
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);
    
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest orderRequest) {
        // Structured log oluştur
        MDC.put("orderId", UUID.randomUUID().toString());
        MDC.put("customerId", orderRequest.getCustomerId());
        MDC.put("amount", orderRequest.getTotalAmount().toString());
        
        try {
            logger.info("Creating new order");
            
            // Siparişi oluştur
            Order order = orderService.createOrder(orderRequest);
            
            logger.info("Order created successfully");
            
            return ResponseEntity.status(HttpStatus.CREATED).body(order);
        } catch (Exception e) {
            MDC.put("error", e.getMessage());
            logger.error("Failed to create order", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        } finally {
            MDC.remove("orderId");
            MDC.remove("customerId");
            MDC.remove("amount");
            MDC.remove("error");
        }
    }
}</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Sidebar toggle for mobile
            const openSidebar = document.getElementById('openSidebar');
            const closeSidebar = document.getElementById('closeSidebar');
            const sidebar = document.getElementById('sidebar');

            openSidebar.addEventListener('click', function () {
                sidebar.classList.add('open');
            });

            closeSidebar.addEventListener('click', function () {
                sidebar.classList.remove('open');
            });

            // Category selection
            const categoryItems = document.querySelectorAll('.category-item');
            const categoryContents = document.querySelectorAll('.category-content');

            categoryItems.forEach(item => {
                item.addEventListener('click', function () {
                    const category = this.getAttribute('data-category');

                    // Update active category
                    categoryItems.forEach(cat => cat.classList.remove('active'));
                    this.classList.add('active');

                    // Show selected category content
                    categoryContents.forEach(content => {
                        if (content.id === category) {
                            content.classList.remove('hidden');
                        } else {
                            content.classList.add('hidden');
                        }
                    });

                    // Close sidebar on mobile after selection
                    if (window.innerWidth < 768) {
                        sidebar.classList.remove('open');
                    }
                });
            });

            // Toggle answer
            const toggleButtons = document.querySelectorAll('.toggle-answer');

            toggleButtons.forEach(button => {
                button.addEventListener('click', function () {
                    const answerContent = this.closest('.question-card').querySelector('.answer-content');
                    const icon = this.querySelector('i');

                    answerContent.classList.toggle('active');

                    if (answerContent.classList.contains('active')) {
                        icon.classList.remove('fa-chevron-down');
                        icon.classList.add('fa-chevron-up');
                    } else {
                        icon.classList.remove('fa-chevron-up');
                        icon.classList.add('fa-chevron-down');
                    }
                });
            });

            // Search functionality
            const searchInput = document.getElementById('searchInput');

            searchInput.addEventListener('input', function () {
                const searchTerm = this.value.toLowerCase();
                const questionCards = document.querySelectorAll('.question-card');

                questionCards.forEach(card => {
                    const questionText = card.querySelector('h3').textContent.toLowerCase();
                    const answerText = card.querySelector('p').textContent.toLowerCase();

                    if (questionText.includes(searchTerm) || answerText.includes(searchTerm)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                });
            });
        });
    </script>
</body>

</html>
