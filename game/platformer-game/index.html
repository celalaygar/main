<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Platformer - Tailwind + JS (Responsive & Mobile)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { -webkit-tap-highlight-color: transparent; background: linear-gradient(180deg,#071024,#04203a); }
    canvas { display:block; border-radius:12px; background: linear-gradient(180deg,#0b1220,#072033); box-shadow: 0 8px 30px rgba(2,6,23,0.7); }
    .touch-btn{ width:64px; height:64px; border-radius:12px; }
    .game-wrap{ max-width:1100px; width:100%; }
    /* küçük cihazda kontroller hafif saydam */
    @media(max-width:640px){
      .mobile-controls button{ opacity:0.95; }
    }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-6 text-slate-100">

  <div class="game-wrap w-full">
    <header class="flex flex-col md:flex-row items-center justify-between gap-4 mb-4">
      <div class="flex items-center gap-4">
        <h1 class="text-2xl md:text-3xl font-bold">Mini Platformer</h1>
        <div class="hidden md:flex gap-2 text-sm text-slate-300">
          <span class="bg-white/5 px-3 py-1 rounded-md">Seviye: <span id="level">1</span></span>
          <span class="bg-white/5 px-3 py-1 rounded-md">Puan: <span id="score">0</span></span>
          <span class="bg-white/5 px-3 py-1 rounded-md">Can: <span id="lives">3</span></span>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <button id="startBtn" class="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 text-black rounded-md font-medium shadow">Başlat</button>
        <button id="pauseBtn" class="px-4 py-2 bg-yellow-400 hover:bg-yellow-500 text-black rounded-md font-medium shadow">Duraklat</button>
        <button id="resetBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md font-medium shadow">Yeniden Başlat</button>
      </div>
    </header>

    <main class="grid md:grid-cols-3 gap-6">
      <section class="md:col-span-2 flex justify-center">
        <div id="canvasHolder" class="w-full">
          <canvas id="gameCanvas"></canvas>
        </div>
      </section>

      <aside class="flex flex-col gap-4">
        <div class="bg-white/5 p-4 rounded-lg">
          <div class="text-slate-200">Puan: <strong id="scoreSide">0</strong></div>
          <div class="text-slate-200">Can: <strong id="livesSide">3</strong></div>
          <div class="text-slate-200">Seviye: <strong id="levelSide">1</strong></div>
        </div>

        <div class="bg-white/5 p-4 rounded-lg">
          <h3 class="font-semibold mb-2">Nasıl Oynanır</h3>
          <ul class="text-sm text-slate-300 list-disc list-inside space-y-1">
            <li>Masaüstü: Ok tuşları ile hareket, Boşluk veya Yukarı ok ile zıpla.</li>
            <li>Mobil: Altdaki butonlarla sola/sağa hareket ve zıpla.</li>
            <li>Tüm yıldızları toplayıp kapıya ulaşırsan seviye geçersin.</li>
          </ul>
        </div>

        <div class="bg-white/5 p-4 rounded-lg md:hidden flex flex-col items-center gap-3">
          <div class="flex gap-3">
            <button id="btnLeft" class="touch-btn bg-slate-700 hover:bg-slate-600 text-xl">◀</button>
            <button id="btnRight" class="touch-btn bg-slate-700 hover:bg-slate-600 text-xl">▶</button>
          </div>
          <button id="btnJump" class="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 text-black rounded-md font-medium">Zıpla</button>
        </div>
      </aside>
    </main>

    <footer class="mt-6 text-center text-xs text-slate-400">Responsive Platformer • Tailwind + Canvas + JS</footer>
  </div>

<script>
/* =========================
   Responsive Platformer Game
   - Canvas scales to holder width
   - Simple physics, platforms, collectibles, goal
   - Keyboard + mobile touch buttons
   ========================= */

const canvas = document.getElementById('gameCanvas');
const holder = document.getElementById('canvasHolder');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');

const scoreSide = document.getElementById('scoreSide');
const livesSide = document.getElementById('livesSide');
const levelSide = document.getElementById('levelSide');

const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnJump = document.getElementById('btnJump');

let WIDTH, HEIGHT, SCALE;

// responsive canvas sizing
function resizeCanvas(){
  const maxW = holder.clientWidth;
  const desiredW = Math.min(maxW, 900);
  // keep ~4:3 ratio
  let desiredH = Math.min(window.innerHeight * 0.72, desiredW * 0.65);
  WIDTH = Math.floor(desiredW);
  HEIGHT = Math.floor(desiredH);
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  // base unit size for drawing
  SCALE = WIDTH / 800; // base layout on 800px width
}
window.addEventListener('resize', ()=> { resizeCanvas(); draw(); });
resizeCanvas();

/* GAME STATE */
let level = 1;
let score = 0;
let lives = 3;
let running = false;
let paused = false;

/* world layout uses tile grid (cols x rows) but we draw in pixels */
const TILE_SIZE = 40; // base tile size (will be scaled by SCALE in drawing)
let tilesX = Math.floor(WIDTH / (TILE_SIZE * SCALE));
let tilesY = Math.floor(HEIGHT / (TILE_SIZE * SCALE));

/* Player */
let player = {
  x: 80, y: 0, w: 34, h: 46,
  vx: 0, vy: 0,
  speed: 240, // px/s
  jumpVel: -520,
  grounded: false,
  facing: 1
};

/* World objects */
let platforms = []; // {x,y,w,h}
let stars = [];     // collectibles {x,y,r, collected}
let goal = null;    // goal rect {x,y,w,h}
let gravity = 1600; // px/s^2

/* timing */
let lastTime = 0;

/* helpful scaling helpers */
function s(n){ return n * SCALE; } // for drawing sizes relative to base

/* build a simple level generator (different each level) */
function buildLevel(l){
  platforms = [];
  stars = [];
  // recalc tile counts
  tilesX = Math.max(10, Math.floor(WIDTH / (TILE_SIZE * SCALE)));
  tilesY = Math.max(8, Math.floor(HEIGHT / (TILE_SIZE * SCALE)));

  // ground
  platforms.push({ x:0, y: HEIGHT - s(48), w: WIDTH, h: s(48) });

  // some floating platforms (pattern changes with level)
  const rows = Math.min(6, 3 + l);
  for (let r=0; r<rows; r++){
    const count = 2 + (r%3);
    for (let i=0;i<count;i++){
      const pw = s(120 + (i*10));
      const px = s(40 + i * 220 + ((r%2)*80)) + (Math.random()*80*(r+1));
      const py = s(HEIGHT*0.15 + r * s(80)) + Math.random()*s(30);
      // keep within bounds
      const nx = Math.max(20, Math.min(px % (WIDTH - pw - 40), WIDTH - pw - 20));
      platforms.push({ x: nx, y: py, w: pw, h: s(18) });
    }
  }

  // some walls (left/right) occasional
  platforms.push({ x: s(12), y: s(HEIGHT*0.4), w: s(24), h: s(140) });
  platforms.push({ x: WIDTH - s(36), y: s(HEIGHT*0.52), w: s(24), h: s(180) });

  // place stars scattered above platforms
  for (const p of platforms){
    if (p.h < s(100)) {
      // place a star sometimes on platform
      if (Math.random() < 0.5 && stars.length < 8 + l*2){
        stars.push({ x: p.x + p.w/2 + (Math.random()*s(40)-s(20)), y: p.y - s(20), r: s(8), collected:false });
      }
    }
  }

  // add some random free-floating stars
  for (let i=0;i<3 + l;i++){
    stars.push({ x: s(80 + i*160 + Math.random()*80), y: s(50 + i*40 + Math.random()*100), r: s(8), collected:false });
  }

  // goal at far right top-ish
  goal = { x: WIDTH - s(120), y: s(HEIGHT*0.15), w: s(80), h: s(80) };

  // reset player
  player.x = s(60);
  player.y = s(HEIGHT - 200);
  player.vx = 0;
  player.vy = 0;
  player.grounded = false;
}

/* collision helpers: axis-aligned rectangle intersection */
function rectsOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

/* physics step (dt seconds) */
function step(dt){
  if (!running || paused) return;

  // apply horizontal input - velocities updated via input flags
  // player.vx already set by input handler (px/s)
  // apply gravity
  player.vy += gravity * dt;

  // integrate
  const nextX = player.x + player.vx * dt;
  const nextY = player.y + player.vy * dt;

  // prepare AABB for movement detection
  const horizBox = { x: nextX, y: player.y, w: player.w, h: player.h };
  const vertBox = { x: player.x, y: nextY, w: player.w, h: player.h };

  // horizontal collision against platforms
  let collidedX = false;
  for (const p of platforms){
    if (rectsOverlap(horizBox, p)){
      collidedX = true;
      if (player.vx > 0){
        // hit right side of platform: place to left
        player.x = p.x - player.w - 0.5;
      } else if (player.vx < 0) {
        player.x = p.x + p.w + 0.5;
      }
      player.vx = 0;
      break;
    }
  }
  if (!collidedX) player.x = nextX;

  // vertical collision
  let collidedY = false;
  player.grounded = false;
  for (const p of platforms){
    if (rectsOverlap(vertBox, p)){
      collidedY = true;
      if (player.vy > 0){
        // landing on top
        player.y = p.y - player.h - 0.5;
        player.vy = 0;
        player.grounded = true;
      } else if (player.vy < 0){
        // hitting bottom of platform
        player.y = p.y + p.h + 0.5;
        player.vy = 0;
      }
      break;
    }
  }
  if (!collidedY) player.y = nextY;

  // world bounds: left/right wrap or clamp - we'll clamp
  if (player.x < 0) player.x = 0;
  if (player.x + player.w > WIDTH) player.x = WIDTH - player.w;
  // bottom -> lose life and respawn
  if (player.y > HEIGHT + s(40)){
    loseLife();
  }

  // collect stars
  for (const st of stars){
    if (!st.collected){
      const starBox = { x: st.x - st.r, y: st.y - st.r, w: st.r*2, h: st.r*2 };
      const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
      if (rectsOverlap(playerBox, starBox)){
        st.collected = true;
        score += 50;
      }
    }
  }

  // check goal (only if all stars collected)
  const remaining = stars.filter(s => !s.collected).length;
  const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
  if (remaining === 0 && rectsOverlap(playerBox, goal)){
    // level complete
    levelComplete();
  }
}

/* lose life */
function loseLife(){
  lives--;
  if (lives <= 0){
    running = false;
    setTimeout(()=> {
      alert(`Oyun bitti! Skor: ${score}`);
      resetGame();
    }, 50);
  } else {
    // respawn player on current level start spot
    player.x = s(60);
    player.y = s(HEIGHT - 200);
    player.vx = 0;
    player.vy = 0;
  }
  updateUI();
}

/* level complete */
function levelComplete(){
  running = false;
  setTimeout(()=> {
    level++;
    score += 500;
    buildLevel(level);
    running = true;
  }, 500);
  updateUI();
}

/* rendering */
function draw(){
  // clear
  ctx.clearRect(0,0,WIDTH,HEIGHT);

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,HEIGHT);
  g.addColorStop(0, '#061129');
  g.addColorStop(1, '#071024');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // draw platforms
  for (const p of platforms){
    ctx.fillStyle = '#2b6cb0';
    roundRect(ctx, p.x, p.y, p.w, p.h, 8 * SCALE, true);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(p.x + 6*SCALE, p.y + 6*SCALE, Math.max(0, p.w - 12*SCALE), Math.max(0, p.h - 12*SCALE));
  }

  // draw stars
  for (const st of stars){
    if (st.collected) continue;
    drawStar(st.x, st.y, st.r, '#ffd166', '#ffb703');
  }

  // draw goal
  ctx.fillStyle = '#34d399';
  roundRect(ctx, goal.x, goal.y, goal.w, goal.h, 10*SCALE, true);
  ctx.fillStyle = '#052e16';
  ctx.font = `${16 * SCALE}px Inter, Arial`;
  ctx.fillText('GOAL', goal.x + goal.w*0.15, goal.y + goal.h*0.55);

  // draw player (simple rectangle with face)
  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.scale(player.facing, 1);
  ctx.translate(- (player.x + player.w/2), - (player.y + player.h/2));
  // body
  ctx.fillStyle = '#ffd43b';
  roundRect(ctx, player.x, player.y, player.w, player.h, 6*SCALE, true);
  // eyes
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(player.x + player.w*0.65, player.y + player.h*0.35, 3*SCALE, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // HUD
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(0,0,WIDTH,50*SCALE);
  ctx.fillStyle = '#fff';
  ctx.font = `${16 * SCALE}px Inter, Arial`;
  ctx.fillText(`Seviye: ${level}`, 12 * SCALE, 32 * SCALE);
  ctx.fillText(`Puan: ${score}`, 140 * SCALE, 32 * SCALE);
  ctx.fillText(`Can: ${lives}`, 280 * SCALE, 32 * SCALE);
}

/* small helper: rounded rect */
function roundRect(ctx,x,y,w,h,r,fill){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
}

/* draw star symbol */
function drawStar(cx, cy, r, color1, color2){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.fillStyle = color1;
  ctx.beginPath();
  for (let i=0;i<5;i++){
    ctx.lineTo(Math.cos((18 + i*72) / 180 * Math.PI) * r, -Math.sin((18 + i*72) / 180 * Math.PI) * r);
    ctx.lineTo(Math.cos((54 + i*72) / 180 * Math.PI) * r/2, -Math.sin((54 + i*72) / 180 * Math.PI) * r/2);
  }
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = color2;
  ctx.beginPath();
  ctx.arc(0,0, r*0.18, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* GAME LOOP */
function loop(ts){
  if (!lastTime) lastTime = ts;
  const dt = Math.min(0.05, (ts - lastTime) / 1000); // clamp dt
  step(dt);
  draw();
  lastTime = ts;
  requestAnimationFrame(loop);
}

/* INPUT HANDLING */
// keyboard
const input = { left:false, right:false, jump:false };
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
  if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') {
    if (!input.jump){
      // only trigger jump on keydown
      attemptJump();
    }
    input.jump = true;
  }
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
  if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') input.jump = false;
});

// mobile buttons
btnLeft?.addEventListener('touchstart', (e)=>{ e.preventDefault(); input.left = true; });
btnLeft?.addEventListener('touchend', (e)=>{ e.preventDefault(); input.left = false; });
btnRight?.addEventListener('touchstart', (e)=>{ e.preventDefault(); input.right = true; });
btnRight?.addEventListener('touchend', (e)=>{ e.preventDefault(); input.right = false; });
btnJump?.addEventListener('touchstart', (e)=>{ e.preventDefault(); attemptJump(); });

// apply continuous movement each frame (in step) by setting player.vx
function applyInput(){
  let targetVx = 0;
  if (input.left) { targetVx = -player.speed; player.facing = -1; }
  if (input.right) { targetVx = player.speed; player.facing = 1; }
  // smooth acceleration could be applied; we'll set directly
  player.vx = targetVx;
}

/* attempt jump */
function attemptJump(){
  if (player.grounded){
    player.vy = player.jumpVel;
    player.grounded = false;
  } else {
    // allow coyote-time or double-jump optionally (not implemented)
  }
}

/* START / PAUSE / RESET UI */
startBtn.addEventListener('click', ()=>{
  if (!running){
    running = true;
    paused = false;
    lastTime = 0;
    requestAnimationFrame(loop);
  }
});
pauseBtn.addEventListener('click', ()=>{
  paused = !paused;
  pauseBtn.textContent = paused ? 'Devam Et' : 'Duraklat';
});
resetBtn.addEventListener('click', ()=> resetGame());

/* update UI labels */
function updateUI(){
  scoreEl.textContent = score;
  livesEl.textContent = lives;
  levelEl.textContent = level;

  scoreSide.textContent = score;
  livesSide.textContent = lives;
  levelSide.textContent = level;
}

/* main step override to include input */
const originalStep = step;
step = function(dt){
  applyInput();
  originalStep(dt);
  updateUI();
};

/* reset game and start level 1 */
function resetGame(){
  level = 1;
  score = 0;
  lives = 3;
  buildLevel(level);
  running = false;
  paused = false;
  lastTime = 0;
  updateUI();
  draw();
}

/* initialize */
buildLevel(level);
draw();
updateUI();

/* ensure canvas resizes correctly and rebuild levels on resize to keep layout consistent */
let resizeTimer = null;
window.addEventListener('resize', ()=>{
  // debounce
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{
    resizeCanvas();
    buildLevel(level);
    draw();
  }, 120);
});

/* start auto-loop but paused until user presses Start */
requestAnimationFrame(loop);

</script>
</body>
</html>
