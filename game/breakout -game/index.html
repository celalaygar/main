<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Breakout / Arkanoid — Tailwind + JS (Responsive)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { -webkit-tap-highlight-color: transparent; }
    canvas { display:block; border-radius: .5rem; background: linear-gradient(180deg,#071027,#0b1220); box-shadow: 0 8px 30px rgba(2,6,23,0.7); margin:0 auto; }
    .btn { @apply px-4 py-2 rounded-md font-semibold shadow-md transition; }
    .control-btn { width:56px; height:56px; border-radius:9999px; }
    /* küçük ekranlarda butonları hafif küçült */
    @media (max-width:480px){ .control-btn{width:48px;height:48px} }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-900 via-slate-800 to-slate-900 text-white flex items-center justify-center p-6">

  <div class="w-full max-w-4xl">
    <header class="flex items-center justify-between mb-4">
      <h1 class="text-xl md:text-2xl font-bold">Breakout / Arkanoid</h1>
      <div class="flex items-center gap-3">
        <div class="bg-white/5 px-3 py-2 rounded-md text-sm font-mono">Puan: <span id="score">0</span></div>
        <div class="bg-white/5 px-3 py-2 rounded-md text-sm font-mono">Can: <span id="lives">3</span></div>
        <div class="bg-white/5 px-3 py-2 rounded-md text-sm font-mono">En yüksek: <span id="best">0</span></div>
      </div>
    </header>

    <main class="grid md:grid-cols-3 gap-4">
      <section class="md:col-span-2 flex justify-center">
        <div id="canvasWrap" class="w-full">
          <canvas id="gameCanvas"></canvas>
        </div>
      </section>

      <aside class="flex flex-col gap-4">
        <div class="bg-white/5 p-3 rounded-md">
          <div class="flex gap-2">
            <button id="startBtn" class="btn bg-emerald-500 hover:bg-emerald-600 text-black">Başlat</button>
            <button id="pauseBtn" class="btn bg-yellow-400 hover:bg-yellow-500 text-black">Duraklat</button>
            <button id="resetBtn" class="btn bg-red-600 hover:bg-red-700 text-white">Yeniden</button>
          </div>
          <div class="text-sm text-slate-300 mt-3">
            Kontroller: Fare / Dokunmatik sürükle veya ← → ok tuşları.
          </div>
        </div>

        <div class="bg-white/5 p-3 rounded-md">
          <h2 class="font-semibold">Açıklama</h2>
          <p class="text-sm text-slate-300 mt-2">Top tüm tuğlaları kırınca seviye atlanır (yeni dizilim). Paddle'ı sürükleyerek topu yönlendir.</p>
        </div>

        <div class="hidden md:flex md:flex-col gap-2">
          <div class="text-xs text-slate-400">Mobil kontroller:</div>
          <div class="flex gap-2">
            <button id="leftControl" class="control-btn bg-slate-700 hover:bg-slate-600 text-xl">◀</button>
            <button id="rightControl" class="control-btn bg-slate-700 hover:bg-slate-600 text-xl">▶</button>
          </div>
        </div>
      </aside>
    </main>

    <!-- mobil alt paddle sürükleme ipucu -->
    <div class="md:hidden mt-4 text-center text-sm text-slate-300">Mobil: paddle'ı sürükleyin veya alt okları kullanın.</div>
  </div>

<script>
/* Responsive Breakout / Arkanoid
   - Tek dosya
   - Canvas responsive: canvas width = min(containerWidth, 900)
   - DevicePixelRatio destekli for sharpness
*/

// UI
const canvas = document.getElementById('gameCanvas');
const wrap = document.getElementById('canvasWrap');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const bestEl = document.getElementById('best');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const leftControl = document.getElementById('leftControl');
const rightControl = document.getElementById('rightControl');

let ctx = canvas.getContext('2d');

// Game settings (logical)
let GAME = {
  cols: 10,           // brick columns (will adapt)
  rows: 5,            // brick rows
  brickPadding: 8,    // px (will scale)
  paddleWidthRatio: 0.18, // paddle width as fraction of canvas width
  paddleHeight: 14,
  ballRadius: 8,
  brickTopOffsetRatio: 0.06, // distance from top as fraction
  brickHeightRatio: 0.06, // brick height relative to canvas height
  speedMultiplier: 1,   // increases per level
};

// dynamic state
let cw = 600, ch = 360;      // canvas css pixels
let DPR = Math.max(1, window.devicePixelRatio || 1);
let paddle = null;
let ball = null;
let bricks = [];
let score = 0;
let lives = 3;
let best = parseInt(localStorage.getItem('breakoutBest') || '0', 10);
bestEl.textContent = best;
let running = false;
let paused = false;
let animationId = null;
let lastTime = 0;
let level = 1;

// responsive sizing
function resizeCanvas(){
  const maxWidth = Math.min(900, wrap.clientWidth);
  cw = Math.floor(maxWidth);
  ch = Math.floor(cw * 0.6); // 3:5 ratio height
  // scale for DPR
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.width = Math.floor(cw * DPR);
  canvas.height = Math.floor(ch * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // scale drawing to CSS pixels
  // recalc layout
  rebuildLevelLayout();
  draw(); // immediate draw
}
window.addEventListener('resize', resizeCanvas);

// build bricks and paddles based on current canvas size
function rebuildLevelLayout(){
  // adapt columns based on width
  GAME.cols = Math.max(8, Math.floor(cw / 60)); // ~60px per brick
  GAME.rows = Math.max(4, Math.floor((ch * 0.28) / 30)); // depends on height
  GAME.brickPadding = Math.max(6, Math.floor(cw * 0.012));
  GAME.brickHeight = Math.max(18, Math.floor(ch * GAME.brickHeightRatio));
  GAME.brickTopOffset = Math.floor(ch * GAME.brickTopOffsetRatio);

  // create bricks grid width-wise
  const totalPaddingX = GAME.brickPadding * (GAME.cols + 1);
  const brickWidth = Math.floor((cw - totalPaddingX) / GAME.cols);
  GAME.brickWidth = brickWidth;

  paddle = {
    w: Math.max(60, Math.floor(cw * GAME.paddleWidthRatio)),
    h: GAME.paddleHeight,
    x: (cw - Math.max(60, Math.floor(cw * GAME.paddleWidthRatio))) / 2,
    y: ch - 30,
    speed: Math.max(8, cw * 0.02),
  };

  ball = {
    x: cw / 2,
    y: paddle.y - 12,
    vx: 4 * GAME.speedMultiplier,
    vy: -4 * GAME.speedMultiplier,
    r: Math.max(6, GAME.ballRadius),
    stuck: true // stuck to paddle until start
  };

  // bricks array
  bricks = [];
  for (let r = 0; r < GAME.rows; r++){
    for (let c = 0; c < GAME.cols; c++){
      const x = GAME.brickPadding + c*(GAME.brickWidth + GAME.brickPadding);
      const y = GAME.brickTopOffset + r*(GAME.brickHeight + GAME.brickPadding);
      bricks.push({
        x, y,
        w: GAME.brickWidth,
        h: GAME.brickHeight,
        hp: 1 + Math.floor((level-1)/2), // higher levels tougher
        alive: true,
        color: brickColorForRow(r)
      });
    }
  }
}

// brick color helper
function brickColorForRow(r){
  const palette = ['#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#06b6d4'];
  return palette[r % palette.length];
}

// drawing
function clear(){
  ctx.clearRect(0,0,cw,ch);
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,ch);
  g.addColorStop(0, '#071027');
  g.addColorStop(1, '#071021');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,cw,ch);
}

function drawPaddle(){
  ctx.fillStyle = '#e2e8f0';
  roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 6, true, false);
}

function drawBall(){
  ctx.beginPath();
  ctx.fillStyle = '#ffd166';
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fill();
  // small shine
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.arc(ball.x - ball.r*0.4, ball.y - ball.r*0.4, Math.max(1, ball.r*0.35), 0, Math.PI*2);
  ctx.fill();
}

function drawBricks(){
  for (const b of bricks){
    if (!b.alive) continue;
    ctx.fillStyle = b.color;
    roundRect(ctx, b.x, b.y, b.w, b.h, 6, true, false);
    // small inner highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(b.x + 3, b.y + 3, b.w - 6, b.h - 6);
  }
}

function drawHUD(){
  // optionally draw center message when paused
  if (!running){
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0,ch/2 - 40, cw, 80);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '18px system-ui';
    ctx.fillText('Başlamak için Başlat', cw/2, ch/2);
  }
  if (paused){
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0,ch/2 - 40, cw, 80);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '18px system-ui';
    ctx.fillText('Duraklatıldı', cw/2, ch/2);
  }
}

function draw(){
  clear();
  drawBricks();
  drawPaddle();
  drawBall();
  // if level cleared, show message
  if (bricks.every(b => !b.alive)){
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0, ch/2 - 36, cw, 72);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '20px system-ui';
    ctx.fillText('Seviye Tamamlandı! Yeniden başlat ile devam et.', cw/2, ch/2);
  }
}

// rounded rect
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// physics / collisions
function rectCircleColliding(cx, cy, cr, rx, ry, rw, rh){
  // find closest point
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function updatePhysics(delta){
  if (!running || paused) return;

  // ball sticky to paddle before start
  if (ball.stuck){
    ball.x = clamp(ball.x, paddle.x + ball.r, paddle.x + paddle.w - ball.r);
    ball.y = paddle.y - ball.r - 2;
  } else {
    ball.x += ball.vx * (delta/16);
    ball.y += ball.vy * (delta/16);

    // wall collisions
    if (ball.x - ball.r <= 0){
      ball.x = ball.r;
      ball.vx = -ball.vx;
    } else if (ball.x + ball.r >= cw){
      ball.x = cw - ball.r;
      ball.vx = -ball.vx;
    }
    if (ball.y - ball.r <= 0){
      ball.y = ball.r;
      ball.vy = -ball.vy;
    }

    // paddle collision
    if (rectCircleColliding(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0){
      // place ball above paddle
      ball.y = paddle.y - ball.r - 1;
      // compute hit position relative to paddle center (-1..1)
      const rel = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      const maxBounce = Math.PI / 3; // 60 degrees
      const angle = rel * maxBounce;
      // speed magnitude
      const speed = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
      // new velocity
      ball.vx = speed * Math.sin(angle);
      ball.vy = -Math.abs(speed * Math.cos(angle));
      // slight speedup
      ball.vx *= 1.02;
      ball.vy *= 1.02;
    }

    // bottom (lose life)
    if (ball.y - ball.r > ch){
      loseLife();
    }

    // bricks collision (iterate alive bricks)
    for (const b of bricks){
      if (!b.alive) continue;
      if (rectCircleColliding(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)){
        // simple collision response: reflect based on side
        // find penetration direction
        const overlapLeft = (ball.x + ball.r) - b.x;
        const overlapRight = (b.x + b.w) - (ball.x - ball.r);
        const overlapTop = (ball.y + ball.r) - b.y;
        const overlapBottom = (b.y + b.h) - (ball.y - ball.r);
        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

        if (minOverlap === overlapLeft) {
          ball.vx = -Math.abs(ball.vx);
          ball.x = b.x - ball.r - 1;
        } else if (minOverlap === overlapRight) {
          ball.vx = Math.abs(ball.vx);
          ball.x = b.x + b.w + ball.r + 1;
        } else if (minOverlap === overlapTop) {
          ball.vy = -Math.abs(ball.vy);
          ball.y = b.y - ball.r - 1;
        } else {
          ball.vy = Math.abs(ball.vy);
          ball.y = b.y + b.h + ball.r + 1;
        }

        // hit brick
        b.hp--;
        if (b.hp <= 0){
          b.alive = false;
          score += 10;
        } else {
          score += 5;
        }
        updateUI();
        // small speed bump for difficulty
        if (Math.random() < 0.2){
          ball.vx *= 1.03;
          ball.vy *= 1.03;
        }
        break; // only one brick per frame
      }
    }
  }
}

function loseLife(){
  lives--;
  updateUI();
  if (lives <= 0){
    endGame();
  } else {
    // reset ball to paddle
    ball.stuck = true;
    ball.vx = 4 * Math.sign((Math.random()-.5)) ;
    ball.vy = -4;
    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - ball.r - 2;
  }
}

function endGame(){
  running = false;
  paused = false;
  if (score > best){
    best = score;
    localStorage.setItem('breakoutBest', best);
    bestEl.textContent = best;
  }
  setTimeout(()=> {
    alert('Oyun bitti! Skor: ' + score);
  }, 50);
}

// UI sync
function updateUI(){
  scoreEl.textContent = score;
  livesEl.textContent = lives;
  bestEl.textContent = best;
}

// game loop
function loop(timestamp){
  if (!lastTime) lastTime = timestamp;
  const delta = timestamp - lastTime;
  lastTime = timestamp;

  updatePhysics(delta);
  draw();

  // level complete?
  if (bricks.every(b => !b.alive)){
    running = false;
    // next level: increase difficulty
    level++;
    GAME.speedMultiplier *= 1.08;
    setTimeout(()=> {
      // rebuild with new params
      rebuildLevelLayout();
      // reset ball/paddle
      paddle.x = (cw - paddle.w)/2;
      ball.x = cw/2; ball.y = paddle.y - ball.r - 2;
      ball.stuck = true;
      running = true;
    }, 700);
  }

  animationId = requestAnimationFrame(loop);
}

// start/pause/reset
function startGame(){
  if (!running){
    running = true;
    paused = false;
    if (ball.stuck) {
      // release the ball
      ball.stuck = false;
    }
    lastTime = 0;
    animationId = requestAnimationFrame(loop);
  }
}
function togglePause(){
  if (!running) return;
  paused = !paused;
  pauseBtn.textContent = paused ? 'Devam Et' : 'Duraklat';
}
function resetGame(fullReset = true){
  cancelAnimationFrame(animationId);
  level = 1;
  GAME.speedMultiplier = 1;
  score = 0;
  lives = 3;
  running = false;
  paused = false;
  // rebuild
  rebuildLevelLayout();
  paddle.x = (cw - paddle.w)/2;
  ball.x = cw/2; ball.y = paddle.y - ball.r - 2;
  ball.vx = 4; ball.vy = -4; ball.stuck = true;
  updateUI();
  draw();
}

// input handlers
let dragging = false;
let dragOffsetX = 0;

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  // if click on paddle area -> start dragging
  if (x >= paddle.x && x <= paddle.x + paddle.w && e.clientY - rect.top >= paddle.y){
    dragging = true;
    dragOffsetX = x - paddle.x;
  } else {
    // else release ball if stuck
    if (ball.stuck) {
      ball.stuck = false;
    }
  }
});
window.addEventListener('mousemove', (e)=>{
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  let x = (e.clientX - rect.left) - dragOffsetX;
  paddle.x = clamp(x, 0, cw - paddle.w);
  if (ball.stuck){
    ball.x = paddle.x + paddle.w/2;
  }
});
window.addEventListener('mouseup', ()=> dragging = false);

// touch
canvas.addEventListener('touchstart', (e)=>{
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = (t.clientX - rect.left);
  if (x >= paddle.x && x <= paddle.x + paddle.w){
    dragging = true;
    dragOffsetX = x - paddle.x;
  } else {
    if (ball.stuck) ball.stuck = false;
  }
  e.preventDefault();
});
canvas.addEventListener('touchmove', (e)=>{
  if (!dragging) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  let x = (t.clientX - rect.left) - dragOffsetX;
  paddle.x = clamp(x, 0, cw - paddle.w);
  if (ball.stuck) ball.x = paddle.x + paddle.w/2;
  e.preventDefault();
});
window.addEventListener('touchend', ()=> dragging = false);

// keyboard
window.addEventListener('keydown', (e)=>{
  if (e.key === 'ArrowLeft') {
    paddle.x = clamp(paddle.x - paddle.speed, 0, cw - paddle.w);
    if (ball.stuck) ball.x = paddle.x + paddle.w/2;
    e.preventDefault();
  } else if (e.key === 'ArrowRight') {
    paddle.x = clamp(paddle.x + paddle.speed, 0, cw - paddle.w);
    if (ball.stuck) ball.x = paddle.x + paddle.w/2;
    e.preventDefault();
  } else if (e.key === ' '){ // space to launch
    if (ball.stuck) ball.stuck = false;
    e.preventDefault();
  }
});

// mobile control buttons
leftControl?.addEventListener('mousedown', ()=> paddle.x = clamp(paddle.x - paddle.speed*2, 0, cw - paddle.w));
rightControl?.addEventListener('mousedown', ()=> paddle.x = clamp(paddle.x + paddle.speed*2, 0, cw - paddle.w));
leftControl?.addEventListener('touchstart', (e)=> { paddle.x = clamp(paddle.x - paddle.speed*2, 0, cw - paddle.w); e.preventDefault(); });
rightControl?.addEventListener('touchstart', (e)=> { paddle.x = clamp(paddle.x + paddle.speed*2, 0, cw - paddle.w); e.preventDefault(); });

// buttons
startBtn.addEventListener('click', ()=> { startGame(); });
pauseBtn.addEventListener('click', ()=> { togglePause(); });
resetBtn.addEventListener('click', ()=> { resetGame(); });

// init
resizeCanvas();
resetGame(true);

</script>
</body>
</html>
